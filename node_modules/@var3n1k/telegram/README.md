# Документация

## Импорт модуля

- Импорт модуля осуществляется через стандартные пакетные менеджеры `Node.JS`

  ```bash
    $ npm install @var3n1k/telegram
  ```

  ```bash
    $ yarn add @var3n1k/telegram
  ```

  ```bash
    $ pnpm add @var3n1k/telegram
  ```

- Работа модуля построена на библиотеке [server-core](https://github.com/var3n1k/ServerCore/pkgs/npm/server-core)

- [Инициализация бота](#инициализация-бота)
- [Использование функций модуля](#использование-функций-модуля)

## Инициализация бота

```ts
import * as ServerCore from '@var3n1k/server-core'

import * as Telegram from '@var3n1k/telegram'

const Core = new ServerCore.default({}, {}, {}, {}, [`.env`])

await Core.Init(async () => {
  const TelegramBotToken = ServerCore.Engine.Module.Classes.Process.Env.TELEGRAM_BOT_TOKEN as string // Токен бота телеграмм

  const TelegramBotEventHandlersPath = ServerCore.Engine.Module.Classes.FileSystem.GetPathFromSourceDirectory(import.meta.url, [`Events`]) // Путь к папке с обработчиками событий относительно текущего файла
  const TelegramBotMessageHandlersPath = ServerCore.Engine.Module.Classes.FileSystem.GetPathFromSourceDirectory(import.meta.url, [`Messages`]) // Путь к папке с обработчиками сообщений относительно текущего файла
  const TelegramBotActionComponentHandlersPath = ServerCore.Engine.Module.Classes.FileSystem.GetPathFromSourceDirectory(import.meta.url, [`Action`, `Components`]) // Путь к папке с обработчиками взаимодействий относительно текущего файла
  const TelegramBotCommandHandlersPath = ServerCore.Engine.Module.Classes.FileSystem.GetPathFromSourceDirectory(import.meta.url, [`Commands`]) // Путь к папке с обработчиками команд относительно текущего файла

  const TelegramBotClient = new Telegram.API.ChatBot.API.default(TelegramBotToken, {
    Handler: {
      Event: {
        Directory: TelegramBotEventHandlersPath,
      },
      Message: {
        Directory: TelegramBotMessageHandlersPath,
      },
      Action: {
        Component: {
          Directory: TelegramBotActionComponentHandlersPath,
        },
      },
      Command: {
        Directory: TelegramBotCommandHandlersPath,
      },
    },
  })

  await TelegramBotClient.Init()
})
```

## Использование функций модуля

- [Обработчик событий](#обработчик-событий)
- [Обработчик сообщений](#обработчик-сообщений)
- [Обработчик взаимодействий](#обработчик-взаимодействий)
- [Обработчик команд](#обработчик-команд)
- [Обработчик отложенных запросов](#обработчик-отложенных-запросов)

### Обработчик событий

- Для создания нового обработчика событий рекомендуется придерживаться следующего шаблона (после создания обработчика ручной импорт **НЕ ТРЕБУЕТСЯ**, обработчик будет подключен и запущен **АВТОМАТИЧЕСКИ**)

  ```ts
  import * as ServerCore from '@var3n1k/server-core'

  import * as Telegram from '@var3n1k/telegram'

  export default class EventHandler extends Telegram.API.ChatBot.API.Handler.Event.BaseEvent.default {
    constructor(api: Telegram.API.ChatBot.API.default) {
      const Validator = ServerCore.Engine.Module.Classes.Validator
      Validator.Strict(api, new Validator().Default.Class.Instance().Required().Of(Telegram.API.ChatBot.API.default))

      super(api, async (..._) => {
        const [
          EventName, // Названия доступных событий
          MultipleEventListener, // Функция многократного обработчика событий
        ] = _

        MultipleEventListener(EventName.message(`text`), async (eventContext) => {})
      })
    }
  }
  ```

### Обработчик сообщений

- Для создания нового обработчика сообщений рекомендуется придерживаться следующего шаблона (после создания обработчика ручной импорт **НЕ ТРЕБУЕТСЯ**, обработчик будет подключен и запущен **АВТОМАТИЧЕСКИ**)

  ```ts
  import * as ServerCore from '@var3n1k/server-core'

  import * as Telegram from '@var3n1k/telegram'

  const MessageContentPattern = /^.*$/ // Маска текста сообщений, по которой будет вызываться обработчик

  export default class MessageHandler extends Telegram.API.ChatBot.API.Handler.Message.BaseMessage.default {
    constructor(api: Telegram.API.ChatBot.API.default) {
      const Validator = ServerCore.Engine.Module.Classes.Validator
      Validator.Strict(api, new Validator().Default.Class.Instance().Required().Of(Telegram.API.ChatBot.API.default))

      super(
        api,
        MessageContentPattern,
        {
          Private: {
            Available: true, // Вызов обработчика в личных чатах
          },
          Public: {
            Chat: {
              Available: true, // Вызов обработчика в публичных чатах
            },
          },
        },
        {
          Private: async (..._) => {
            // Функция обработчика для личных чатов
            const [
              EventContext, // Интерфейс события
              Message, // Интерфейс сообщения
              MessageContent, // Текст сообщения
              MessageChat, // Интерфейс чата
              MessageAuthor, // Интерфейс пользователя
            ] = _

            const MessageAuthorName = this._API.FormUserName(MessageAuthor.username, MessageAuthor.first_name, MessageAuthor.last_name)

            await EventContext.reply(`<Сообщение>`)
          },
          Public: {
            Chat: async (..._) => {
              // Функция обработчика для публичных чатов
              const [
                EventContext, // Интерфейс события
                Message, // Интерфейс сообщения
                MessageContent, // Текст сообщения
                MessageChat, // Интерфейс чата
                MessageAuthor, // Интерфейс пользователя
              ] = _

              const MessageAuthorName = this._API.FormUserName(MessageAuthor.username, MessageAuthor.first_name, MessageAuthor.last_name)

              await EventContext.reply(`<Сообщение>`)
            },
          },
        }
      )
    }
  }
  ```

### Обработчик взаимодействий

- [Обработчик нажатий на кнопку](#обработчик-нажатий-на-кнопку)

#### Обработчик нажатий на кнопку

- Для создания нового обработчика нажатий на кнопку рекомендуется придерживаться следующего шаблона (после создания обработчика ручной импорт **НЕ ТРЕБУЕТСЯ**, обработчик будет подключен и запущен **АВТОМАТИЧЕСКИ**)

  ```ts
  import * as ServerCore from '@var3n1k/server-core'

  import * as Telegram from '@var3n1k/telegram'

  const ActionComponentIDPattern = /^.*$/ // Маска ID нажатой кнопки, по которой будет вызываться обработчик

  Telegram.API.ChatBot.API.Handler.Action.Component.Button.BaseButtonComponent.default.Settings.Public.Chat.Execution.Error.SetNotReadyMessageConstructor(async (..._) => {
    const Validator = ServerCore.Engine.Module.Classes.Validator

    const [
      EventContext, // Интерфейс события
      Message, // Интерфейс сообщения
      ActionData, // ID нажатой кнопки
      ActionChat, // Интерфейс чата
      ActionAuthor, // Интерфейс пользователя
    ] = _

    const ErrorMessage = `Приложение еще не запущено`

    return ErrorMessage
  })

  export default class ButtonHandler extends Telegram.API.ChatBot.API.Handler.Action.Component.Button.BaseButtonComponent.default {
    constructor(api: Telegram.API.ChatBot.API.default) {
      const Validator = ServerCore.Engine.Module.Classes.Validator
      Validator.Strict(api, new Validator().Default.Class.Instance().Required().Of(Telegram.API.ChatBot.API.default))

      super(
        api,
        ActionComponentIDPattern,
        {
          Private: {
            Available: true, // Вызов обработчика в личных чатах
            PerUser: async (actionUser) => {
              // Вызов обработчика для пользователя в личных чатах
              const IsActionAvailableForUser = true

              return IsActionAvailableForUser
            },
          },
          Public: {
            Chat: {
              Available: {
                // Вызов обработчика в публичных чатах
                PerChat: async (actionChat) => {
                  // Вызов обработчика в чатах, прошедших валидацию
                  const IsActionAvailableForChat = true

                  return IsActionAvailableForChat
                },
              },
              PerUser: async (actionChat, actionUser) => {
                // Вызов обработчика для пользователя в публичных чатах
                const IsActionAvailableForUser = true

                return IsActionAvailableForUser
              },
            },
          },
        },
        {
          Private: async (..._) => {
            // Функция обработчика для личных чатов
            const [
              EventContext, // Интерфейс события
              Message, // Интерфейс сообщения
              ActionData, // ID нажатой кнопки
              ActionChat, // Интерфейс чата
              ActionAuthor, // Интерфейс пользователя
            ] = _

            await EventContext.answerCbQuery()

            const ActionAuthorName = this._API.FormUserName(ActionAuthor.username, ActionAuthor.first_name, ActionAuthor.last_name)

            await EventContext.reply(`<Сообщение>`)
          },
          Public: {
            Chat: async (..._) => {
              // Функция обработчика для публичных чатов
              const [
                EventContext, // Интерфейс события
                Message, // Интерфейс сообщения
                ActionData, // ID нажатой кнопки
                ActionChat, // Интерфейс чата
                ActionAuthor, // Интерфейс пользователя
              ] = _

              await EventContext.answerCbQuery()

              const ActionAuthorName = this._API.FormUserName(ActionAuthor.username, ActionAuthor.first_name, ActionAuthor.last_name)

              await EventContext.reply(`<Сообщение>`)
            },
          },
        }
      )
    }
  }
  ```

### Обработчик команд

- [Обработчик слэш-команд](#обработчик-слэш-команд)

#### Обработчик слэш-команд

- Для создания нового обработчика слэш-команд рекомендуется придерживаться следующего шаблона (после создания обработчика ручной импорт **НЕ ТРЕБУЕТСЯ**, обработчик будет подключен и запущен **АВТОМАТИЧЕСКИ**)

  ```ts
  import * as ServerCore from '@var3n1k/server-core'

  import * as Telegram from '@var3n1k/telegram'

  const CommandName = `pricing` // Название команды
  const CommandDescription = `Наши услуги и расценки` // Описание команды

  Telegram.API.ChatBot.API.Handler.Command.Slash.BaseSlashCommand.default.Settings.Public.Chat.Execution.Error.SetNotReadyMessageConstructor(async (..._) => {
    const Validator = ServerCore.Engine.Module.Classes.Validator

    const [
      EventContext, // Интерфейс события
      Message, // Интерфейс сообщения
      CommandName, // Название команды (без `/`)
      CommandArguments, // Список аргументов команды (текст после названия команды, разделеныый по 1 пробельному знаку)
      CommandQuery, // Запрос команды (список аргументов команды, соединенный по 1 пробельному знаку)
      CommandChat, // Интерфейс чата
      CommandAuthor, // Интерфейс пользователя
    ] = _

    const ErrorMessage = `Приложение еще не запущено`

    return ErrorMessage
  })

  export default class SlashCommandHandler extends Telegram.API.ChatBot.API.Handler.Command.Slash.BaseSlashCommand.default {
    constructor(api: Telegram.API.ChatBot.API.default) {
      const Validator = ServerCore.Engine.Module.Classes.Validator
      Validator.Strict(api, new Validator().Default.Class.Instance().Required().Of(Telegram.API.ChatBot.API.default))

      super(
        api,
        CommandName,
        CommandDescription,
        {
          Private: {
            Available: true, // Вызов обработчика в личных чатах
            PerUser: async (actionUser) => {
              // Вызов обработчика для пользователя в личных чатах
              const IsActionAvailableForUser = true

              return IsActionAvailableForUser
            },
          },
          Public: {
            Chat: {
              Available: {
                // Вызов обработчика в публичных чатах
                PerChat: async (actionChat) => {
                  // Вызов обработчика в чатах, прошедших валидацию
                  const IsActionAvailableForChat = true

                  return IsActionAvailableForChat
                },
              },
              PerUser: async (actionChat, actionUser) => {
                // Вызов обработчика для пользователя в публичных чатах
                const IsActionAvailableForUser = true

                return IsActionAvailableForUser
              },
            },
          },
        },
        {
          Private: async (..._) => {
            // Функция обработчика для личных чатов
            const [
              EventContext, // Интерфейс события
              Message, // Интерфейс сообщения
              CommandName, // Название команды (без `/`)
              CommandArguments, // Список аргументов команды (текст после названия команды, разделеныый по 1 пробельному знаку)
              CommandQuery, // Запрос команды (список аргументов команды, соединенный по 1 пробельному знаку)
              CommandChat, // Интерфейс чата
              CommandAuthor, // Интерфейс пользователя
            ] = _

            const CommandAuthorName = this._API.FormUserName(CommandAuthor.username, CommandAuthor.first_name, CommandAuthor.last_name)

            await EventContext.reply(`<Сообщение>`)
          },
          Public: {
            Chat: async (..._) => {
              // Функция обработчика для публичных чатов
              const [
                EventContext, // Интерфейс события
                Message, // Интерфейс сообщения
                CommandName, // Название команды (без `/`)
                CommandArguments, // Список аргументов команды (текст после названия команды, разделеныый по 1 пробельному знаку)
                CommandQuery, // Запрос команды (список аргументов команды, соединенный по 1 пробельному знаку)
                CommandChat, // Интерфейс чата
                CommandAuthor, // Интерфейс пользователя
              ] = _

              const CommandAuthorName = this._API.FormUserName(CommandAuthor.username, CommandAuthor.first_name, CommandAuthor.last_name)

              await EventContext.reply(`<Сообщение>`)
            },
          },
        }
      )
    }
  }
  ```

### Обработчик отложенных запросов

- Обработчик `AwaitedHandler` используется для получения отложенных запросов от пользователя (отложенные сообщения или вложения)

  ```ts
  import * as ServerCore from '@var3n1k/server-core'

  import * as Telegram from '@var3n1k/telegram'

  import * as TelegramBot from '../../TelegramBot.js'

  const AwaitedMessageChannelID = 9876543210 // ID канала, в котором ожидается сообщение
  const AwaitedMessageUserID = 1234567890 // ID пользователя, от которого ожидается сообщение

  const AwaitedMessageTimeLimit = 20000 // Лимит ожидания сообщения в миллисекундах (20 секунд)

  const AwaitedMessageContent = await TelegramBot.AwaitedHandler.Message(AwaitedMessageChannelID, AwaitedMessageUserID, AwaitedMessageTimeLimit) // Текст полученного сообщения или `undefined`, если лимит ожидания исчерпан
  ```
