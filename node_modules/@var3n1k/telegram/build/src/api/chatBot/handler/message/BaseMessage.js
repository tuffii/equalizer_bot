import * as ServerCore from '@var3n1k/server-core';
import * as TelegramAPI from '../../__api.js';
export default class BaseMessage {
    // TODO: JSDoc
    Pattern;
    // TODO: JSDoc
    Access;
    // TODO: JSDoc
    _API;
    // TODO: JSDoc
    _Executable;
    // TODO: JSDoc
    constructor(api, pattern, access, executable) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        Validator.Strict(api, new Validator().Default.Class.Instance().Required().Of(TelegramAPI.default));
        Validator.Strict(pattern, new Validator().Default.RegExp().Required());
        Validator.Strict(access, new Validator().Default.Object()
            .Required()
            .Exact({
            Private: new Validator().Default.Object().Required().Exact({
                Available: new Validator().Default.Boolean().Required(),
            }),
            Public: new Validator().Default.Object()
                .Required()
                .Exact({
                Chat: new Validator().Default.Object().Required().Exact({
                    Available: new Validator().Default.Boolean().Required(),
                }),
            }),
        }));
        Validator.Strict(executable, new Validator().Default.Object()
            .Required()
            .Exact({
            Private: new Validator().Default.Function().Required(),
            Public: new Validator().Default.Object().Required().Exact({
                Chat: new Validator().Default.Function().Required(),
            }),
        }));
        this._API = api;
        this.Pattern = pattern;
        this.Access = access;
        this._Executable = executable;
        this.__RegisterMetrics();
    }
    // TODO: JSDoc
    async __BeforePrivateMessageExecution(..._) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const [EventContext, Message, MessageContent, MessageChat, MessageAuthor] = _;
    }
    // TODO: JSDoc
    async __AlternativePrivateMessageExecutable(..._) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const [EventContext, Message, MessageContent, MessageChat, MessageAuthor] = _;
    }
    // TODO: JSDoc
    async __AfterPrivateMessageExecution(..._) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const [EventContext, Message, MessageContent, MessageChat, MessageAuthor] = _;
    }
    // TODO: JSDoc
    __RegisterPrivateMessageHandler() {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        this._API.Event.Emitter.On(TelegramAPI.default.Event.Name.Message.Separate.Private.Send, async (eventContext, message, messageContent, messageChat, messageAuthor) => {
            const ReceivedMessageContent = messageContent;
            const ExpectedMessageContent = this.Pattern;
            const ReceivedMessageContentMatch = ExpectedMessageContent.test(ReceivedMessageContent);
            if (!ReceivedMessageContentMatch)
                return;
            const PrivateMessageParameters = [eventContext, message, messageContent, messageChat, messageAuthor];
            await this.__BeforePrivateMessageExecution(...PrivateMessageParameters);
            try {
                await this._Executable.Private(...PrivateMessageParameters);
                this._API.Log.Preset.Info(`Обработано сообщение в приватном чате от пользователя ${this._API.FormUserName(messageAuthor.username, messageAuthor.first_name, messageAuthor.last_name)} [`, messageAuthor.id, `]`);
            }
            catch (APIError) {
                this._API.Log.Preset.Warn(`При обработке сообщения в приватном чате от пользователя ${this._API.FormUserName(messageAuthor.username, messageAuthor.first_name, messageAuthor.last_name)} [`, messageAuthor.id, `] произошла непредвиденная ошибка`);
                if (Validator.TypeGuard.Default.IsError(APIError)) {
                    this._API.Log.Preset.Error(APIError, false);
                }
                await this.__AlternativePrivateMessageExecutable(...PrivateMessageParameters);
            }
            await this.__AfterPrivateMessageExecution(...PrivateMessageParameters);
        });
    }
    // TODO: JSDoc
    async __BeforePublicChatMessageExecution(..._) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const [EventContext, Message, MessageContent, MessageChat, MessageAuthor] = _;
    }
    // TODO: JSDoc
    async __AlternativePublicChatMessageExecutable(..._) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const [EventContext, Message, MessageContent, MessageChat, MessageAuthor] = _;
    }
    // TODO: JSDoc
    async __AfterPublicChatMessageExecution(..._) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const [EventContext, Message, MessageContent, MessageChat, MessageAuthor] = _;
    }
    // TODO: JSDoc
    __RegisterPublicChatMessageHandler() {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        this._API.Event.Emitter.On(TelegramAPI.default.Event.Name.Message.Separate.Public.Chat.Send, async (eventContext, message, messageContent, messageChat, messageAuthor) => {
            const ReceivedMessageContent = messageContent;
            const ExpectedMessageContent = this.Pattern;
            const ReceivedMessageContentMatch = ExpectedMessageContent.test(ReceivedMessageContent);
            if (!ReceivedMessageContentMatch)
                return;
            const PublicChatMessageParameters = [eventContext, message, messageContent, messageChat, messageAuthor];
            await this.__BeforePublicChatMessageExecution(...PublicChatMessageParameters);
            const MessageChatName = messageChat.type === `group` ? messageChat.title : messageChat.type === `supergroup` ? messageChat.title : messageChat.username;
            try {
                await this._Executable.Public.Chat(...PublicChatMessageParameters);
                this._API.Log.Preset.Info(`Обработано сообщение в публичном чате '${MessageChatName}' [`, messageChat.id, `] от пользователя ${this._API.FormUserName(messageAuthor.username, messageAuthor.first_name, messageAuthor.last_name)} [`, messageAuthor.id, `]`);
            }
            catch (APIError) {
                this._API.Log.Preset.Warn(`При обработке сообщения в публичном чате '${MessageChatName}' [`, messageChat.id, `] от пользователя ${this._API.FormUserName(messageAuthor.username, messageAuthor.first_name, messageAuthor.last_name)} [`, messageAuthor.id, `] произошла непредвиденная ошибка`);
                if (Validator.TypeGuard.Default.IsError(APIError)) {
                    this._API.Log.Preset.Error(APIError, false);
                }
                await this.__AlternativePublicChatMessageExecutable(...PublicChatMessageParameters);
            }
            await this.__AfterPublicChatMessageExecution(...PublicChatMessageParameters);
        });
    }
    // TODO: JSDoc
    __RegisterCommandHandler() {
        this.__RegisterPrivateMessageHandler();
        this.__RegisterPublicChatMessageHandler();
    }
    // TODO: JSDoc
    __RegisterHandlers() {
        this.__RegisterCommandHandler();
    }
    // TODO: JSDoc
    __RegisterMetrics() {
        this.__RegisterHandlers();
    }
}
//# sourceMappingURL=BaseMessage.js.map