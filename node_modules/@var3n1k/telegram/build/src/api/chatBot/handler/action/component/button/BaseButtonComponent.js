import * as ServerCore from '@var3n1k/server-core';
import * as TelegramAPI from '../../../../__api.js';
import * as BaseComponent from '../BaseComponent.js';
class BaseButtonComponent extends BaseComponent.default {
    // TODO: JSDoc
    static __Settings = {
        Private: {
            Execution: {
                Error: {
                    NotReady: {
                        Message: async (..._) => {
                            const Validator = ServerCore.Engine.Module.Classes.Validator;
                            const [EventContext, Action, ActionData, ActionChat, ActionAuthor] = _;
                            const ErrorMessage = `*Приложение еще не запущено. Попробуйте воспользоваться кнопкой \`${ActionData}\` снова через несколько минут*`;
                            return ErrorMessage;
                        },
                    },
                    ChannelRestricted: {
                        Message: async (..._) => {
                            const Validator = ServerCore.Engine.Module.Classes.Validator;
                            const [EventContext, Action, ActionData, ActionChat, ActionAuthor] = _;
                            const ErrorMessage = `*Кнопка \`${ActionData}\` отключена для приватных каналов. Попробуйте воспользоваться этой кнопкой на публичных серверах*`;
                            return ErrorMessage;
                        },
                    },
                    UserRestricted: {
                        Message: async (..._) => {
                            const Validator = ServerCore.Engine.Module.Classes.Validator;
                            const [EventContext, Action, ActionData, ActionChat, ActionAuthor] = _;
                            const ErrorMessage = `*Вам недоступен вызов кнопки \`${ActionData}\` в приватных каналах. Попробуйте воспользоваться этой кнопкой на публичных серверах*`;
                            return ErrorMessage;
                        },
                    },
                },
            },
        },
        Public: {
            Chat: {
                Execution: {
                    Error: {
                        NotReady: {
                            Message: async (..._) => {
                                const Validator = ServerCore.Engine.Module.Classes.Validator;
                                const [EventContext, Action, ActionData, ActionChat, ActionAuthor] = _;
                                const ErrorMessage = `*Приложение еще не запущено. Попробуйте воспользоваться кнопкой \`${ActionData}\` снова через несколько минут*`;
                                return ErrorMessage;
                            },
                        },
                        ChannelRestricted: {
                            Message: async (..._) => {
                                const Validator = ServerCore.Engine.Module.Classes.Validator;
                                const [EventContext, Action, ActionData, ActionChat, ActionAuthor] = _;
                                const ErrorMessage = `*Кнопка \`${ActionData}\` недоступна на этом сервере. Попробуйте воспользоваться этой кнопкой на других публичных серверах*`;
                                return ErrorMessage;
                            },
                        },
                        UserRestricted: {
                            Message: async (..._) => {
                                const Validator = ServerCore.Engine.Module.Classes.Validator;
                                const [EventContext, Action, ActionData, ActionChat, ActionAuthor] = _;
                                const ErrorMessage = `*Вам недоступен вызов кнопки \`${ActionData}\` на публичных серверах. Попробуйте воспользоваться этой кнопкой в приватных каналах*`;
                                return ErrorMessage;
                            },
                        },
                    },
                },
            },
        },
    };
    // TODO: JSDoc
    static get Settings() {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const Settings = {
            Private: {
                Execution: {
                    Error: {
                        SetNotReadyMessageConstructor: (_) => {
                            Validator.Strict(_, new Validator().Default.Function().Required());
                            this.__Settings.Private.Execution.Error.NotReady.Message = _;
                        },
                        SetChannelRestrictedConstructor: (_) => {
                            Validator.Strict(_, new Validator().Default.Function().Required());
                            this.__Settings.Private.Execution.Error.ChannelRestricted.Message = _;
                        },
                        SetUserRestrictedConstructor: (_) => {
                            Validator.Strict(_, new Validator().Default.Function().Required());
                            this.__Settings.Private.Execution.Error.UserRestricted.Message = _;
                        },
                    },
                },
            },
            Public: {
                Chat: {
                    Execution: {
                        Error: {
                            SetNotReadyMessageConstructor: (_) => {
                                Validator.Strict(_, new Validator().Default.Function().Required());
                                this.__Settings.Public.Chat.Execution.Error.NotReady.Message = _;
                            },
                            SetChannelRestrictedConstructor: (_) => {
                                Validator.Strict(_, new Validator().Default.Function().Required());
                                this.__Settings.Public.Chat.Execution.Error.ChannelRestricted.Message = _;
                            },
                            SetUserRestrictedConstructor: (_) => {
                                Validator.Strict(_, new Validator().Default.Function().Required());
                                this.__Settings.Public.Chat.Execution.Error.UserRestricted.Message = _;
                            },
                        },
                    },
                },
            },
        };
        return Settings;
    }
    // TODO: JSDoc
    constructor(api, data, access, executable) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        Validator.Strict(api, new Validator().Default.Class.Instance().Required().Of(TelegramAPI.default));
        Validator.Strict(data, new Validator().Default.RegExp().Required());
        Validator.Strict(access, new Validator().Default.Object()
            .Required()
            .Exact({
            Private: new Validator().Default.Object().Required().Exact({
                Available: new Validator().Default.Boolean().Required(),
                PerUser: new Validator().Default.Function().Required(),
            }),
            Public: new Validator().Default.Object()
                .Required()
                .Exact({
                Chat: new Validator().Default.Object()
                    .Required()
                    .Exact({
                    Available: new Validator().Default.Object().Required().Exact({
                        PerChat: new Validator().Default.Function().Required(),
                    }),
                    PerUser: new Validator().Default.Function().Required(),
                }),
            }),
        }));
        Validator.Strict(executable, new Validator().Default.Object()
            .Required()
            .Exact({
            Private: new Validator().Default.Function().Required(),
            Public: new Validator().Default.Object().Required().Exact({
                Chat: new Validator().Default.Function().Required(),
            }),
        }));
        super(api, data, access, executable);
        this.__RegisterMetrics();
    }
    // TODO: JSDoc
    async __ValidatePrivateReadyActionExecution(..._) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const [EventContext, Action, ActionData, ActionChat, ActionAuthor] = _;
        const ErrorMessage = await BaseButtonComponent.__Settings.Private.Execution.Error.NotReady.Message(..._);
        const IsBotReady = this._API.IsReady();
        if (!IsBotReady) {
            await EventContext.reply(`${ErrorMessage}`, { parse_mode: `Markdown` });
        }
        return IsBotReady;
    }
    // TODO: JSDoc
    async __ValidatePrivateChannelActionExecution(..._) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const [EventContext, Action, ActionData, ActionChat, ActionAuthor] = _;
        const ErrorMessage = await BaseButtonComponent.__Settings.Private.Execution.Error.ChannelRestricted.Message(..._);
        const IsActionAvailableForChannel = this.Access.Private.Available;
        if (!IsActionAvailableForChannel) {
            await EventContext.reply(`${ErrorMessage}`, { parse_mode: `Markdown` });
        }
        return IsActionAvailableForChannel;
    }
    // TODO: JSDoc
    async __ValidatePrivateUserActionExecution(..._) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const [EventContext, Action, ActionData, ActionChat, ActionAuthor] = _;
        const ErrorMessage = await BaseButtonComponent.__Settings.Private.Execution.Error.UserRestricted.Message(..._);
        const IsActionAvailableForUser = await this.Access.Private.PerUser(ActionAuthor);
        if (!IsActionAvailableForUser) {
            await EventContext.reply(`${ErrorMessage}`, { parse_mode: `Markdown` });
        }
        return IsActionAvailableForUser;
    }
    // TODO: JSDoc
    async __ValidatePublicChatReadyActionExecution(..._) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const [EventContext, Action, ActionData, ActionChat, ActionAuthor] = _;
        const ErrorMessage = await BaseButtonComponent.__Settings.Public.Chat.Execution.Error.NotReady.Message(..._);
        const IsBotReady = this._API.IsReady();
        if (!IsBotReady) {
            await EventContext.reply(`${ErrorMessage}`, { parse_mode: `Markdown` });
        }
        return IsBotReady;
    }
    // TODO: JSDoc
    async __ValidatePublicChatChannelActionExecution(..._) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const [EventContext, Action, ActionData, ActionChat, ActionAuthor] = _;
        const ErrorMessage = await BaseButtonComponent.__Settings.Public.Chat.Execution.Error.ChannelRestricted.Message(..._);
        const IsActionAvailableForChat = await this.Access.Public.Chat.Available.PerChat(ActionChat);
        if (!IsActionAvailableForChat) {
            await EventContext.reply(`${ErrorMessage}`, { parse_mode: `Markdown` });
        }
        return IsActionAvailableForChat;
    }
    // TODO: JSDoc
    async __ValidatePublicChatUserActionExecution(..._) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const [EventContext, Action, ActionData, ActionChat, ActionAuthor] = _;
        const ErrorMessage = await BaseButtonComponent.__Settings.Public.Chat.Execution.Error.UserRestricted.Message(..._);
        const IsActionAvailableForUser = await this.Access.Public.Chat.PerUser(ActionChat, ActionAuthor);
        if (!IsActionAvailableForUser) {
            await EventContext.reply(`${ErrorMessage}`, { parse_mode: `Markdown` });
        }
        return IsActionAvailableForUser;
    }
    // TODO: JSDoc
    async __ValidatePrivateActionExecution(..._) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const [EventContext, Action, ActionData, ActionChat, ActionAuthor] = _;
        const IsBotReady = await this.__ValidatePrivateReadyActionExecution(..._);
        if (!IsBotReady) {
            return IsBotReady;
        }
        const IsActionAvailableForChannel = await this.__ValidatePrivateChannelActionExecution(..._);
        if (!IsActionAvailableForChannel) {
            return IsActionAvailableForChannel;
        }
        const IsActionAvailableForUser = await this.__ValidatePrivateUserActionExecution(..._);
        if (!IsActionAvailableForUser) {
            return IsActionAvailableForUser;
        }
        const IsActionExecutionValid = IsBotReady && IsActionAvailableForChannel && IsActionAvailableForUser;
        return IsActionExecutionValid;
    }
    // TODO: JSDoc
    async __BeforePrivateActionExecution(..._) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const [EventContext, Action, ActionData, ActionChat, ActionAuthor] = _;
    }
    // TODO: JSDoc
    async __AlternativePrivateActionExecutable(..._) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const [EventContext, Action, ActionData, ActionChat, ActionAuthor] = _;
    }
    // TODO: JSDoc
    async __AfterPrivateActionExecution(..._) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const [EventContext, Action, ActionData, ActionChat, ActionAuthor] = _;
    }
    // TODO: JSDoc
    __RegisterPrivateActionHandler() {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        this._API.Event.Emitter.On(TelegramAPI.default.Event.Name.Action.Component.Button.Separate.Private.Send, async (eventContext, action, actionData, actionChat, actionAuthor) => {
            const ExpectedComponentData = this.Data;
            const ReceivedComponentData = actionData;
            const DoesReceivedComponentDataExist = !Validator.TypeGuard.Default.IsNullOrUndefined(ReceivedComponentData);
            if (DoesReceivedComponentDataExist) {
                const ReceivedComponentDataMatch = ExpectedComponentData.test(ReceivedComponentData);
                if (!ReceivedComponentDataMatch)
                    return;
                const PrivateActionParameters = [eventContext, action, actionData, actionChat, actionAuthor];
                const IsActionExecutionValid = await this.__ValidatePrivateActionExecution(...PrivateActionParameters);
                if (!IsActionExecutionValid) {
                    return;
                }
                await this.__BeforePrivateActionExecution(...PrivateActionParameters);
                try {
                    await this._Executable.Private(...PrivateActionParameters);
                    this._API.Log.Preset.Info(`Обработано нажатие на кнопку '${ReceivedComponentData}' в приватном чате от пользователя ${this._API.FormUserName(actionAuthor.username, actionAuthor.first_name, actionAuthor.last_name)} [`, actionAuthor.id, `]`);
                }
                catch (APIError) {
                    this._API.Log.Preset.Warn(`При обработке нажатия на кнопку '${ReceivedComponentData}' в приватном чате от пользователя ${this._API.FormUserName(actionAuthor.username, actionAuthor.first_name, actionAuthor.last_name)} [`, actionAuthor.id, `] произошла непредвиденная ошибка`);
                    if (Validator.TypeGuard.Default.IsError(APIError)) {
                        this._API.Log.Preset.Error(APIError, false);
                    }
                    await this.__AlternativePrivateActionExecutable(...PrivateActionParameters);
                }
                await this.__AfterPrivateActionExecution(...PrivateActionParameters);
            }
        });
    }
    // TODO: JSDoc
    async __ValidatePublicChatActionExecution(..._) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const [EventContext, Action, ActionData, ActionChat, ActionAuthor] = _;
        const IsBotReady = await this.__ValidatePublicChatReadyActionExecution(..._);
        if (!IsBotReady) {
            return IsBotReady;
        }
        const IsActionAvailableForChat = await this.__ValidatePublicChatChannelActionExecution(..._);
        if (!IsActionAvailableForChat) {
            return IsActionAvailableForChat;
        }
        const IsActionAvailableForUser = await this.__ValidatePublicChatUserActionExecution(..._);
        if (!IsActionAvailableForUser) {
            return IsActionAvailableForUser;
        }
        const IsActionExecutionValid = IsBotReady && IsActionAvailableForChat && IsActionAvailableForUser;
        return IsActionExecutionValid;
    }
    // TODO: JSDoc
    async __BeforePublicChatActionExecution(..._) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const [EventContext, Action, ActionData, ActionChat, ActionAuthor] = _;
    }
    // TODO: JSDoc
    async __AlternativePublicChatActionExecutable(..._) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const [EventContext, Action, ActionData, ActionChat, ActionAuthor] = _;
    }
    // TODO: JSDoc
    async __AfterPublicChatActionExecution(..._) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const [EventContext, Action, ActionData, ActionChat, ActionAuthor] = _;
    }
    // TODO: JSDoc
    __RegisterPublicChatActionHandler() {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        this._API.Event.Emitter.On(TelegramAPI.default.Event.Name.Action.Component.Button.Separate.Public.Chat.Send, async (eventContext, action, actionData, actionChat, actionAuthor) => {
            const ExpectedComponentData = this.Data;
            const ReceivedComponentData = actionData;
            const DoesReceivedComponentDataExist = !Validator.TypeGuard.Default.IsNullOrUndefined(ReceivedComponentData);
            if (DoesReceivedComponentDataExist) {
                const ReceivedComponentDataMatch = ExpectedComponentData.test(ReceivedComponentData);
                if (!ReceivedComponentDataMatch)
                    return;
                const ActionChatName = actionChat.type === `group` ? actionChat.title : actionChat.type === `supergroup` ? actionChat.title : actionAuthor.username;
                const PublicChatActionParameters = [eventContext, action, actionData, actionChat, actionAuthor];
                const IsActionExecutionValid = await this.__ValidatePublicChatActionExecution(...PublicChatActionParameters);
                if (!IsActionExecutionValid) {
                    return;
                }
                await this.__BeforePublicChatActionExecution(...PublicChatActionParameters);
                try {
                    await this._Executable.Public.Chat(...PublicChatActionParameters);
                    this._API.Log.Preset.Info(`Обработано нажатие на кнопку '${ReceivedComponentData}' в публичном чате '${ActionChatName}' [`, actionChat.id, `] от пользователя ${this._API.FormUserName(actionAuthor.username, actionAuthor.first_name, actionAuthor.last_name)} [`, actionAuthor.id, `]`);
                }
                catch (APIError) {
                    this._API.Log.Preset.Warn(`При обработке нажатия на кнопку '${ReceivedComponentData}' в публичном чате '${ActionChatName}' [`, actionChat.id, `] от пользователя ${this._API.FormUserName(actionAuthor.username, actionAuthor.first_name, actionAuthor.last_name)} [`, actionAuthor.id, `] произошла непредвиденная ошибка`);
                    if (Validator.TypeGuard.Default.IsError(APIError)) {
                        this._API.Log.Preset.Error(APIError, false);
                    }
                    await this.__AlternativePublicChatActionExecutable(...PublicChatActionParameters);
                }
                await this.__AfterPublicChatActionExecution(...PublicChatActionParameters);
            }
        });
    }
    // TODO: JSDoc
    __RegisterActionHandler() {
        this.__RegisterPrivateActionHandler();
        this.__RegisterPublicChatActionHandler();
    }
    // TODO: JSDoc
    __RegisterHandlers() {
        this.__RegisterActionHandler();
    }
    // TODO: JSDoc
    __RegisterMetrics() {
        this.__RegisterHandlers();
    }
}
export default BaseButtonComponent;
//# sourceMappingURL=BaseButtonComponent.js.map