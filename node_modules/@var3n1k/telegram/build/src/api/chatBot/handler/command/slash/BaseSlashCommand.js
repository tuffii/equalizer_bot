import * as ServerCore from '@var3n1k/server-core';
import * as BaseCommand from '../BaseCommand.js';
import * as TelegramAPI from '../../../__api.js';
class BaseSlashCommand extends BaseCommand.default {
    // TODO: JSDoc
    static __Settings = {
        Private: {
            Execution: {
                Error: {
                    NotReady: {
                        Message: async (..._) => {
                            const Validator = ServerCore.Engine.Module.Classes.Validator;
                            const [EventContext, Message, CommandName, CommandArguments, CommandQuery, CommandChat, CommandAuthor] = _;
                            const ErrorMessage = `*Приложение еще не запущено. Попробуйте воспользоваться слэш-командой /${CommandName} снова через несколько минут*`;
                            return ErrorMessage;
                        },
                    },
                    ChannelRestricted: {
                        Message: async (..._) => {
                            const Validator = ServerCore.Engine.Module.Classes.Validator;
                            const [EventContext, Message, CommandName, CommandArguments, CommandQuery, CommandChat, CommandAuthor] = _;
                            const ErrorMessage = `*Слэш-команда /${CommandName} отключена для приватных каналов. Попробуйте воспользоваться этой командой на публичных серверах*`;
                            return ErrorMessage;
                        },
                    },
                    UserRestricted: {
                        Message: async (..._) => {
                            const Validator = ServerCore.Engine.Module.Classes.Validator;
                            const [EventContext, Message, CommandName, CommandArguments, CommandQuery, CommandChat, CommandAuthor] = _;
                            const ErrorMessage = `*Вам недоступен вызов слэш-команды /${CommandName} в приватных каналах. Попробуйте воспользоваться этой командой на публичных серверах*`;
                            return ErrorMessage;
                        },
                    },
                },
            },
        },
        Public: {
            Chat: {
                Execution: {
                    Error: {
                        NotReady: {
                            Message: async (..._) => {
                                const Validator = ServerCore.Engine.Module.Classes.Validator;
                                const [EventContext, Message, CommandName, CommandArguments, CommandQuery, CommandChat, CommandAuthor] = _;
                                const ErrorMessage = `*Приложение еще не запущено. Попробуйте воспользоваться слэш-командой /${CommandName} снова через несколько минут*`;
                                return ErrorMessage;
                            },
                        },
                        ChannelRestricted: {
                            Message: async (..._) => {
                                const Validator = ServerCore.Engine.Module.Classes.Validator;
                                const [EventContext, Message, CommandName, CommandArguments, CommandQuery, CommandChat, CommandAuthor] = _;
                                const ErrorMessage = `*Слэш-команда /${CommandName} недоступна на этом сервере. Попробуйте воспользоваться этой командой на других публичных серверах*`;
                                return ErrorMessage;
                            },
                        },
                        UserRestricted: {
                            Message: async (..._) => {
                                const Validator = ServerCore.Engine.Module.Classes.Validator;
                                const [EventContext, Message, CommandName, CommandArguments, CommandQuery, CommandChat, CommandAuthor] = _;
                                const ErrorMessage = `*Вам недоступен вызов слэш-команды /${CommandName} на публичных серверах. Попробуйте воспользоваться этой командой в приватных каналах*`;
                                return ErrorMessage;
                            },
                        },
                    },
                },
            },
        },
    };
    // TODO: JSDoc
    static get Settings() {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const Settings = {
            Private: {
                Execution: {
                    Error: {
                        SetNotReadyMessageConstructor: (_) => {
                            Validator.Strict(_, new Validator().Default.Function().Required());
                            this.__Settings.Private.Execution.Error.NotReady.Message = _;
                        },
                        SetChannelRestrictedConstructor: (_) => {
                            Validator.Strict(_, new Validator().Default.Function().Required());
                            this.__Settings.Private.Execution.Error.ChannelRestricted.Message = _;
                        },
                        SetUserRestrictedConstructor: (_) => {
                            Validator.Strict(_, new Validator().Default.Function().Required());
                            this.__Settings.Private.Execution.Error.UserRestricted.Message = _;
                        },
                    },
                },
            },
            Public: {
                Chat: {
                    Execution: {
                        Error: {
                            SetNotReadyMessageConstructor: (_) => {
                                Validator.Strict(_, new Validator().Default.Function().Required());
                                this.__Settings.Public.Chat.Execution.Error.NotReady.Message = _;
                            },
                            SetChannelRestrictedConstructor: (_) => {
                                Validator.Strict(_, new Validator().Default.Function().Required());
                                this.__Settings.Public.Chat.Execution.Error.ChannelRestricted.Message = _;
                            },
                            SetUserRestrictedConstructor: (_) => {
                                Validator.Strict(_, new Validator().Default.Function().Required());
                                this.__Settings.Public.Chat.Execution.Error.UserRestricted.Message = _;
                            },
                        },
                    },
                },
            },
        };
        return Settings;
    }
    // TODO: JSDoc
    constructor(api, name, description, access, executable) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        Validator.Strict(api, new Validator().Default.Class.Instance().Required().Of(TelegramAPI.default));
        Validator.Strict(name, new Validator().Default.String().Required().MinLength(1));
        Validator.Strict(description, new Validator().Default.String().Required().MinLength(1));
        Validator.Strict(access, new Validator().Default.Object()
            .Required()
            .Exact({
            Private: new Validator().Default.Object().Required().Exact({
                Available: new Validator().Default.Boolean().Required(),
                PerUser: new Validator().Default.Function().Required(),
            }),
            Public: new Validator().Default.Object()
                .Required()
                .Exact({
                Chat: new Validator().Default.Object()
                    .Required()
                    .Exact({
                    Available: new Validator().Default.Object().Required().Exact({
                        PerChat: new Validator().Default.Function().Required(),
                    }),
                    PerUser: new Validator().Default.Function().Required(),
                }),
            }),
        }));
        Validator.Strict(executable, new Validator().Default.Object()
            .Required()
            .Exact({
            Private: new Validator().Default.Function().Required(),
            Public: new Validator().Default.Object().Required().Exact({
                Chat: new Validator().Default.Function().Required(),
            }),
        }));
        super(api, name, description, access, executable);
        this.__RegisterMetrics();
    }
    // TODO: JSDoc
    async __ValidatePrivateReadyCommandExecution(..._) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const [EventContext, Message, CommandName, CommandArguments, CommandQuery, CommandChat, CommandAuthor] = _;
        const ErrorMessage = await BaseSlashCommand.__Settings.Private.Execution.Error.NotReady.Message(..._);
        const IsBotReady = this._API.IsReady();
        if (!IsBotReady) {
            await EventContext.reply(`${ErrorMessage}`, { parse_mode: `Markdown` });
        }
        return IsBotReady;
    }
    // TODO: JSDoc
    async __ValidatePrivateChannelCommandExecution(..._) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const [EventContext, Message, CommandName, CommandArguments, CommandQuery, CommandChat, CommandAuthor] = _;
        const ErrorMessage = await BaseSlashCommand.__Settings.Private.Execution.Error.ChannelRestricted.Message(..._);
        const IsCommandAvailableForChannel = this.Access.Private.Available;
        if (!IsCommandAvailableForChannel) {
            await EventContext.reply(`${ErrorMessage}`, { parse_mode: `Markdown` });
        }
        return IsCommandAvailableForChannel;
    }
    // TODO: JSDoc
    async __ValidatePrivateUserCommandExecution(..._) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const [EventContext, Message, CommandName, CommandArguments, CommandQuery, CommandChat, CommandAuthor] = _;
        const ErrorMessage = await BaseSlashCommand.__Settings.Private.Execution.Error.UserRestricted.Message(..._);
        const IsCommandAvailableForUser = await this.Access.Private.PerUser(CommandAuthor);
        if (!IsCommandAvailableForUser) {
            await EventContext.reply(`${ErrorMessage}`, { parse_mode: `Markdown` });
        }
        return IsCommandAvailableForUser;
    }
    // TODO: JSDoc
    async __ValidatePublicChatReadyCommandExecution(..._) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const [EventContext, Message, CommandName, CommandArguments, CommandQuery, CommandChat, CommandAuthor] = _;
        const ErrorMessage = await BaseSlashCommand.__Settings.Public.Chat.Execution.Error.NotReady.Message(..._);
        const IsBotReady = this._API.IsReady();
        if (!IsBotReady) {
            await EventContext.reply(`${ErrorMessage}`, { parse_mode: `Markdown` });
        }
        return IsBotReady;
    }
    // TODO: JSDoc
    async __ValidatePublicChatChannelCommandExecution(..._) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const [EventContext, Message, CommandName, CommandArguments, CommandQuery, CommandChat, CommandAuthor] = _;
        const ErrorMessage = await BaseSlashCommand.__Settings.Public.Chat.Execution.Error.ChannelRestricted.Message(..._);
        const IsCommandAvailableForChat = await this.Access.Public.Chat.Available.PerChat(CommandChat);
        if (!IsCommandAvailableForChat) {
            await EventContext.reply(`${ErrorMessage}`, { parse_mode: `Markdown` });
        }
        return IsCommandAvailableForChat;
    }
    // TODO: JSDoc
    async __ValidatePublicChatUserCommandExecution(..._) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const [EventContext, Message, CommandName, CommandArguments, CommandQuery, CommandChat, CommandAuthor] = _;
        const ErrorMessage = await BaseSlashCommand.__Settings.Public.Chat.Execution.Error.UserRestricted.Message(..._);
        const IsCommandAvailableForUser = await this.Access.Public.Chat.PerUser(CommandChat, CommandAuthor);
        if (!IsCommandAvailableForUser) {
            await EventContext.reply(`${ErrorMessage}`, { parse_mode: `Markdown` });
        }
        return IsCommandAvailableForUser;
    }
    // TODO: JSDoc
    async __ValidatePrivateCommandExecution(..._) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const [EventContext, Message, CommandName, CommandArguments, CommandQuery, CommandChat, CommandAuthor] = _;
        const IsBotReady = await this.__ValidatePrivateReadyCommandExecution(..._);
        if (!IsBotReady) {
            return IsBotReady;
        }
        const IsCommandAvailableForChannel = await this.__ValidatePrivateChannelCommandExecution(..._);
        if (!IsCommandAvailableForChannel) {
            return IsCommandAvailableForChannel;
        }
        const IsCommandAvailableForUser = await this.__ValidatePrivateUserCommandExecution(..._);
        if (!IsCommandAvailableForUser) {
            return IsCommandAvailableForUser;
        }
        const IsCommandExecutionValid = IsBotReady && IsCommandAvailableForChannel && IsCommandAvailableForUser;
        return IsCommandExecutionValid;
    }
    // TODO: JSDoc
    async __BeforePrivateCommandExecution(..._) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const [EventContext, Message, CommandName, CommandArguments, CommandQuery, CommandChat, CommandAuthor] = _;
    }
    // TODO: JSDoc
    async __AlternativePrivateCommandExecutable(..._) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const [EventContext, Message, CommandName, CommandArguments, CommandQuery, CommandChat, CommandAuthor] = _;
    }
    // TODO: JSDoc
    async __AfterPrivateCommandExecution(..._) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const [EventContext, Message, CommandName, CommandArguments, CommandQuery, CommandChat, CommandAuthor] = _;
    }
    // TODO: JSDoc
    __RegisterPrivateCommandHandler() {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        this._API.Event.Emitter.On(TelegramAPI.default.Event.Name.Command.Slash.Separate.Private.Send, async (eventContext, message, commandName, commandArguments, commandQuery, commandChat, commandAuthor) => {
            const ExpectedCommandName = this.Name;
            const ReceivedCommandName = commandName;
            const ReceivedCommandNameMatch = ReceivedCommandName === ExpectedCommandName;
            if (!ReceivedCommandNameMatch)
                return;
            const PrivateCommandParameters = [
                eventContext,
                message,
                commandName,
                commandArguments,
                commandQuery,
                commandChat,
                commandAuthor,
            ];
            const IsCommandExecutionValid = await this.__ValidatePrivateCommandExecution(...PrivateCommandParameters);
            if (!IsCommandExecutionValid) {
                return;
            }
            await this.__BeforePrivateCommandExecution(...PrivateCommandParameters);
            try {
                await this._Executable.Private(...PrivateCommandParameters);
                this._API.Log.Preset.Info(`Обработана слэш-команда '/${ReceivedCommandName}' в приватном чате от пользователя ${this._API.FormUserName(commandAuthor.username, commandAuthor.first_name, commandAuthor.last_name)} [`, commandAuthor.id, `]`);
            }
            catch (APIError) {
                this._API.Log.Preset.Warn(`При обработке слэш-команды '/${ReceivedCommandName}' в приватном чате от пользователя ${this._API.FormUserName(commandAuthor.username, commandAuthor.first_name, commandAuthor.last_name)} [`, commandAuthor.id, `] произошла непредвиденная ошибка`);
                if (Validator.TypeGuard.Default.IsError(APIError)) {
                    this._API.Log.Preset.Error(APIError, false);
                }
                await this.__AlternativePrivateCommandExecutable(...PrivateCommandParameters);
            }
            await this.__AfterPrivateCommandExecution(...PrivateCommandParameters);
        });
    }
    // TODO: JSDoc
    async __ValidatePublicChatCommandExecution(..._) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const [EventContext, Message, CommandName, CommandArguments, CommandQuery, CommandChat, CommandAuthor] = _;
        const IsBotReady = await this.__ValidatePublicChatReadyCommandExecution(..._);
        if (!IsBotReady) {
            return IsBotReady;
        }
        const IsCommandAvailableForChat = await this.__ValidatePublicChatChannelCommandExecution(..._);
        if (!IsCommandAvailableForChat) {
            return IsCommandAvailableForChat;
        }
        const IsCommandAvailableForUser = await this.__ValidatePublicChatUserCommandExecution(..._);
        if (!IsCommandAvailableForUser) {
            return IsCommandAvailableForUser;
        }
        const IsCommandExecutionValid = IsBotReady && IsCommandAvailableForChat && IsCommandAvailableForUser;
        return IsCommandExecutionValid;
    }
    // TODO: JSDoc
    async __BeforePublicChatCommandExecution(..._) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const [EventContext, Message, CommandName, CommandArguments, CommandQuery, CommandChat, CommandAuthor] = _;
    }
    // TODO: JSDoc
    async __AlternativePublicChatCommandExecutable(..._) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const [EventContext, Message, CommandName, CommandArguments, CommandQuery, CommandChat, CommandAuthor] = _;
    }
    // TODO: JSDoc
    async __AfterPublicChatCommandExecution(..._) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const [EventContext, Message, CommandName, CommandArguments, CommandQuery, CommandChat, CommandAuthor] = _;
    }
    // TODO: JSDoc
    __RegisterPublicChatCommandHandler() {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        this._API.Event.Emitter.On(TelegramAPI.default.Event.Name.Command.Slash.Separate.Public.Chat.Send, async (eventContext, message, commandName, commandArguments, commandQuery, commandChat, commandAuthor) => {
            const ExpectedCommandName = this.Name;
            const ReceivedCommandName = commandName;
            const ReceivedCommandNameMatch = ReceivedCommandName === ExpectedCommandName;
            if (!ReceivedCommandNameMatch)
                return;
            const CommandChatName = commandChat.type === `group` ? commandChat.title : commandChat.type === `supergroup` ? commandChat.title : commandAuthor.username;
            const PublicChatCommandParameters = [
                eventContext,
                message,
                commandName,
                commandArguments,
                commandQuery,
                commandChat,
                commandAuthor,
            ];
            const IsCommandExecutionValid = await this.__ValidatePublicChatCommandExecution(...PublicChatCommandParameters);
            if (!IsCommandExecutionValid) {
                return;
            }
            await this.__BeforePublicChatCommandExecution(...PublicChatCommandParameters);
            try {
                await this._Executable.Public.Chat(...PublicChatCommandParameters);
                this._API.Log.Preset.Info(`Обработана слэш-команда '/${ReceivedCommandName}' в публичном чате '${CommandChatName}' [`, commandChat.id, `] от пользователя ${this._API.FormUserName(commandAuthor.username, commandAuthor.first_name, commandAuthor.last_name)} [`, commandAuthor.id, `]`);
            }
            catch (APIError) {
                this._API.Log.Preset.Warn(`При обработке слэш-команды '/${ReceivedCommandName}' в публичном чате '${CommandChatName}' [`, commandChat.id, `] от пользователя ${this._API.FormUserName(commandAuthor.username, commandAuthor.first_name, commandAuthor.last_name)} [`, commandAuthor.id, `] произошла непредвиденная ошибка`);
                if (Validator.TypeGuard.Default.IsError(APIError)) {
                    this._API.Log.Preset.Error(APIError, false);
                }
                await this.__AlternativePublicChatCommandExecutable(...PublicChatCommandParameters);
            }
            await this.__AfterPublicChatCommandExecution(...PublicChatCommandParameters);
        });
    }
    // TODO: JSDoc
    __RegisterCommandHandler() {
        this.__RegisterPrivateCommandHandler();
        this.__RegisterPublicChatCommandHandler();
    }
    // TODO: JSDoc
    __RegisterHandlers() {
        this.__RegisterCommandHandler();
    }
    // TODO: JSDoc
    __RegisterMetrics() {
        this.__RegisterHandlers();
    }
}
export default BaseSlashCommand;
//# sourceMappingURL=BaseSlashCommand.js.map