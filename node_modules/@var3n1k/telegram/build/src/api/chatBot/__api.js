import * as ServerCore from '@var3n1k/server-core';
import * as Handler from './handler/__handler.js';
import * as Dependencies from './__dependencies.js';
const EventName = {
    Init: `init`,
    Message: {
        Any: {
            Send: `messageAnySend`,
        },
        Separate: {
            Private: {
                Send: `messageSeparatePrivateSend`,
            },
            Public: {
                Chat: {
                    Send: `messageSeparatePublicChatSend`,
                },
            },
        },
    },
    Attachment: {
        Phone: {
            Any: {
                Send: `attachmentPhoneAnySend`,
            },
            Separate: {
                Private: {
                    Send: `attachmentPhoneSeparatePrivateSend`,
                },
                Public: {
                    Chat: {
                        Send: `attachmentPhoneSeparatePublicChatSend`,
                    },
                },
            },
        },
        Location: {
            Any: {
                Send: `attachmentLocationAnySend`,
            },
            Separate: {
                Private: {
                    Send: `attachmentLocationSeparatePrivateSend`,
                },
                Public: {
                    Chat: {
                        Send: `attachmentLocationSeparatePublicChatSend`,
                    },
                },
            },
        },
        Chat: {
            Any: {
                Send: `attachmentChatAnySend`,
            },
            Separate: {
                Private: {
                    Send: `attachmentChatSeparatePrivateSend`,
                },
                Public: {
                    Chat: {
                        Send: `attachmentChatSeparatePublicChatSend`,
                    },
                },
            },
        },
        User: {
            Any: {
                Send: `attachmentUserAnySend`,
            },
            Separate: {
                Private: {
                    Send: `attachmentUserSeparatePrivateSend`,
                },
                Public: {
                    Chat: {
                        Send: `attachmentUserSeparatePublicChatSend`,
                    },
                },
            },
        },
    },
    Action: {
        Component: {
            Button: {
                Any: {
                    Send: `actionComponentButtonAnySend`,
                },
                Separate: {
                    Private: {
                        Send: `actionComponentButtonSeparatePrivateSend`,
                    },
                    Public: {
                        Chat: {
                            Send: `actionComponentButtonSeparatePublicChatSend`,
                        },
                    },
                },
            },
        },
    },
    Command: {
        Slash: {
            Any: {
                Send: `commandSlashAnySend`,
            },
            Separate: {
                Private: {
                    Send: `commandSlashSeparatePrivateSend`,
                },
                Public: {
                    Chat: {
                        Send: `commandSlashSeparatePublicChatSend`,
                    },
                },
            },
        },
    },
};
export * as Handler from './handler/__handler.js';
class TelegramAPI extends ServerCore.Engine.API.Base.default {
    // TODO: JSDoc
    static Event = { Name: EventName };
    // TODO: JSDoc
    Event = { Emitter: new ServerCore.Engine.Module.Classes.EventEmitter() };
    // TODO: JSDoc
    Client;
    // TODO: JSDoc
    __Token;
    // TODO: JSDoc
    __Source;
    // TODO: JSDoc
    __FileSystem;
    // TODO: JSDoc
    get Awaited() {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const Awaited = {
            Message: {
                Private: (async (_, __, ___) => {
                    Validator.Strict(_, new Validator().Default.Numeric().Number().Required().Min(1));
                    Validator.Strict(__, new Validator().Default.Numeric().Number().Required().Min(1));
                    Validator.Strict(___, new Validator().Default.Numeric().Number().Min(1));
                    const AwaitedPrivateMessage = async () => {
                        return new Promise(async (resolve, reject) => {
                            const WaitForPrivateMessage = () => {
                                this.Event.Emitter.Once(TelegramAPI.Event.Name.Message.Separate.Private.Send, (eventContext, message, messageContent, messageChat, messageAuthor) => {
                                    const ReceivedMessageChatIDMatch = _ === messageChat.id;
                                    const ReceivedMessageAuthorIDMatch = __ === messageAuthor.id;
                                    if (ReceivedMessageChatIDMatch && ReceivedMessageAuthorIDMatch) {
                                        resolve([eventContext, message, messageContent, messageChat, messageAuthor]);
                                    }
                                    else {
                                        WaitForPrivateMessage();
                                    }
                                });
                            };
                            WaitForPrivateMessage();
                        });
                    };
                    const LogAwaitedMessage = (____) => {
                        const DoesAwaitedMessageExist = !Validator.TypeGuard.Default.IsNullOrUndefined(____);
                        if (DoesAwaitedMessageExist) {
                            const [EventContext, Message, MessageContent, MessageChat, MessageAuthor] = ____;
                            this.Log.Preset.Info(`Обработано отложенное сообщение в приватном чате от пользователя ${this.__FormUserName(MessageAuthor.username, MessageAuthor.first_name, MessageAuthor.last_name)} [`, MessageAuthor.id, `]`);
                        }
                        else {
                            this.Log.Preset.Warn(`Обработка отложенного сообщения в приватном чате от пользователя [`, __, `] прервана. Истек лимит ожидания`);
                        }
                    };
                    const DoesTimeLimitExist = !Validator.TypeGuard.Default.IsNullOrUndefined(___);
                    if (DoesTimeLimitExist) {
                        const AwaitedTimer = async () => {
                            return new Promise(async (resolve, reject) => {
                                await ServerCore.Engine.Module.Functions.Sleep(___);
                                resolve(undefined);
                            });
                        };
                        const AwaitedMessage = await Promise.any([AwaitedTimer(), AwaitedPrivateMessage()]);
                        LogAwaitedMessage(AwaitedMessage);
                        return AwaitedMessage;
                    }
                    else {
                        const AwaitedMessage = await Promise.any([AwaitedPrivateMessage()]);
                        LogAwaitedMessage(AwaitedMessage);
                        return AwaitedMessage;
                    }
                }),
                Public: {
                    Chat: (async (_, __, ___) => {
                        Validator.Strict(_, new Validator().Default.Numeric().Number().Required().Min(1));
                        Validator.Strict(__, new Validator().Default.Numeric().Number().Required().Min(1));
                        Validator.Strict(___, new Validator().Default.Numeric().Number().Min(1));
                        const AwaitedPublicChatMessage = async () => {
                            return new Promise(async (resolve, reject) => {
                                const WaitForPublicChatMessage = () => {
                                    this.Event.Emitter.Once(TelegramAPI.Event.Name.Message.Separate.Public.Chat.Send, (eventContext, message, messageContent, messageChat, messageAuthor) => {
                                        const ReceivedMessageChatIDMatch = _ === messageChat.id;
                                        const ReceivedMessageAuthorIDMatch = __ === messageAuthor.id;
                                        if (ReceivedMessageChatIDMatch && ReceivedMessageAuthorIDMatch) {
                                            resolve([eventContext, message, messageContent, messageChat, messageAuthor]);
                                        }
                                        else {
                                            WaitForPublicChatMessage();
                                        }
                                    });
                                };
                                WaitForPublicChatMessage();
                            });
                        };
                        const LogAwaitedMessage = (____) => {
                            const DoesAwaitedMessageExist = !Validator.TypeGuard.Default.IsNullOrUndefined(____);
                            if (DoesAwaitedMessageExist) {
                                const [EventContext, Message, MessageContent, MessageChat, MessageAuthor] = ____;
                                const MessageChatName = MessageChat.type === `group` ? MessageChat.title : MessageChat.type === `supergroup` ? MessageChat.title : MessageChat.username;
                                this.Log.Preset.Info(`Обработано отложенное сообщение в публичном чате '${MessageChatName}' [`, MessageChat.id, `] от пользователя ${this.__FormUserName(MessageAuthor.username, MessageAuthor.first_name, MessageAuthor.last_name)} [`, MessageAuthor.id, `]`);
                            }
                            else {
                                this.Log.Preset.Warn(`Обработка отложенного сообщения в публичном чате [`, _, `] от пользователя [`, __, `] прервана. Истек лимит ожидания`);
                            }
                        };
                        const DoesTimeLimitExist = !Validator.TypeGuard.Default.IsNullOrUndefined(___);
                        if (DoesTimeLimitExist) {
                            const AwaitedTimer = async () => {
                                return new Promise(async (resolve, reject) => {
                                    await ServerCore.Engine.Module.Functions.Sleep(___);
                                    resolve(undefined);
                                });
                            };
                            const AwaitedMessage = await Promise.any([AwaitedTimer(), AwaitedPublicChatMessage()]);
                            LogAwaitedMessage(AwaitedMessage);
                            return AwaitedMessage;
                        }
                        else {
                            const AwaitedMessage = await Promise.any([AwaitedPublicChatMessage()]);
                            LogAwaitedMessage(AwaitedMessage);
                            return AwaitedMessage;
                        }
                    }),
                },
            },
            Attachment: {
                Phone: {
                    Private: (async (_, __, ___) => {
                        Validator.Strict(_, new Validator().Default.Numeric().Number().Required().Min(1));
                        Validator.Strict(__, new Validator().Default.Numeric().Number().Required().Min(1));
                        Validator.Strict(___, new Validator().Default.Numeric().Number().Min(1));
                        const AwaitedPrivatePhoneAttachment = async () => {
                            return new Promise(async (resolve, reject) => {
                                const WaitForPrivatePhoneAttachment = () => {
                                    this.Event.Emitter.Once(TelegramAPI.Event.Name.Attachment.Phone.Separate.Private.Send, (eventContext, message, attachment, messageChat, messageAuthor) => {
                                        const ReceivedMessageChatIDMatch = _ === messageChat.id;
                                        const ReceivedMessageAuthorIDMatch = __ === messageAuthor.id;
                                        if (ReceivedMessageChatIDMatch && ReceivedMessageAuthorIDMatch) {
                                            resolve([eventContext, message, attachment, messageChat, messageAuthor]);
                                        }
                                        else {
                                            WaitForPrivatePhoneAttachment();
                                        }
                                    });
                                };
                                WaitForPrivatePhoneAttachment();
                            });
                        };
                        const LogAwaitedAttachment = (____) => {
                            const DoesAwaitedAttachmentExist = !Validator.TypeGuard.Default.IsNullOrUndefined(____);
                            if (DoesAwaitedAttachmentExist) {
                                const [EventContext, Message, Attachment, MessageChat, MessageAuthor] = ____;
                                this.Log.Preset.Info(`Обработано отложенное вложение (номер телефона) в приватном чате от пользователя ${this.__FormUserName(MessageAuthor.username, MessageAuthor.first_name, MessageAuthor.last_name)} [`, MessageAuthor.id, `]`);
                            }
                            else {
                                this.Log.Preset.Warn(`Обработка отложенного вложения (номер телефона) в приватном чате от пользователя [`, __, `] прервана. Истек лимит ожидания`);
                            }
                        };
                        const DoesTimeLimitExist = !Validator.TypeGuard.Default.IsNullOrUndefined(___);
                        if (DoesTimeLimitExist) {
                            const AwaitedTimer = async () => {
                                return new Promise(async (resolve, reject) => {
                                    await ServerCore.Engine.Module.Functions.Sleep(___);
                                    resolve(undefined);
                                });
                            };
                            const AwaitedPhoneAttachment = await Promise.any([AwaitedTimer(), AwaitedPrivatePhoneAttachment()]);
                            LogAwaitedAttachment(AwaitedPhoneAttachment);
                            return AwaitedPhoneAttachment;
                        }
                        else {
                            const AwaitedPhoneAttachment = await Promise.any([AwaitedPrivatePhoneAttachment()]);
                            LogAwaitedAttachment(AwaitedPhoneAttachment);
                            return AwaitedPhoneAttachment;
                        }
                    }),
                    Public: {
                        Chat: (async (_, __, ___) => {
                            Validator.Strict(_, new Validator().Default.Numeric().Number().Required().Min(1));
                            Validator.Strict(__, new Validator().Default.Numeric().Number().Required().Min(1));
                            Validator.Strict(___, new Validator().Default.Numeric().Number().Min(1));
                            const AwaitedPublicChatPhoneAttachment = async () => {
                                return new Promise(async (resolve, reject) => {
                                    const WaitForPublicChatPhoneAttachment = () => {
                                        this.Event.Emitter.Once(TelegramAPI.Event.Name.Attachment.Phone.Separate.Public.Chat.Send, (eventContext, message, attachment, messageChat, messageAuthor) => {
                                            const ReceivedMessageChatIDMatch = _ === messageChat.id;
                                            const ReceivedMessageAuthorIDMatch = __ === messageAuthor.id;
                                            if (ReceivedMessageChatIDMatch && ReceivedMessageAuthorIDMatch) {
                                                resolve([eventContext, message, attachment, messageChat, messageAuthor]);
                                            }
                                            else {
                                                WaitForPublicChatPhoneAttachment();
                                            }
                                        });
                                    };
                                    WaitForPublicChatPhoneAttachment();
                                });
                            };
                            const LogAwaitedAttachment = (____) => {
                                const DoesAwaitedAttachmentExist = !Validator.TypeGuard.Default.IsNullOrUndefined(____);
                                if (DoesAwaitedAttachmentExist) {
                                    const [EventContext, Message, Attachment, MessageChat, MessageAuthor] = ____;
                                    const MessageChatName = MessageChat.type === `group` ? MessageChat.title : MessageChat.type === `supergroup` ? MessageChat.title : MessageChat.username;
                                    this.Log.Preset.Info(`Обработано отложенное вложение (номер телефона) в публичном чате '${MessageChatName}' [`, MessageChat.id, `] от пользователя ${this.__FormUserName(MessageAuthor.username, MessageAuthor.first_name, MessageAuthor.last_name)} [`, MessageAuthor.id, `]`);
                                }
                                else {
                                    this.Log.Preset.Warn(`Обработка отложенного вложения (номер телефона) в публичном чате [`, _, `] от пользователя [`, __, `] прервана. Истек лимит ожидания`);
                                }
                            };
                            const DoesTimeLimitExist = !Validator.TypeGuard.Default.IsNullOrUndefined(___);
                            if (DoesTimeLimitExist) {
                                const AwaitedTimer = async () => {
                                    return new Promise(async (resolve, reject) => {
                                        await ServerCore.Engine.Module.Functions.Sleep(___);
                                        resolve(undefined);
                                    });
                                };
                                const AwaitedPhoneAttachment = await Promise.any([AwaitedTimer(), AwaitedPublicChatPhoneAttachment()]);
                                LogAwaitedAttachment(AwaitedPhoneAttachment);
                                return AwaitedPhoneAttachment;
                            }
                            else {
                                const AwaitedPhoneAttachment = await Promise.any([AwaitedPublicChatPhoneAttachment()]);
                                LogAwaitedAttachment(AwaitedPhoneAttachment);
                                return AwaitedPhoneAttachment;
                            }
                        }),
                    },
                },
                Location: {
                    Private: (async (_, __, ___) => {
                        Validator.Strict(_, new Validator().Default.Numeric().Number().Required().Min(1));
                        Validator.Strict(__, new Validator().Default.Numeric().Number().Required().Min(1));
                        Validator.Strict(___, new Validator().Default.Numeric().Number().Min(1));
                        const AwaitedPrivateLocationAttachment = async () => {
                            return new Promise(async (resolve, reject) => {
                                const WaitForPrivateLocationAttachment = () => {
                                    this.Event.Emitter.Once(TelegramAPI.Event.Name.Attachment.Location.Separate.Private.Send, (eventContext, message, attachment, messageChat, messageAuthor) => {
                                        const ReceivedMessageChatIDMatch = _ === messageChat.id;
                                        const ReceivedMessageAuthorIDMatch = __ === messageAuthor.id;
                                        if (ReceivedMessageChatIDMatch && ReceivedMessageAuthorIDMatch) {
                                            resolve([eventContext, message, attachment, messageChat, messageAuthor]);
                                        }
                                        else {
                                            WaitForPrivateLocationAttachment();
                                        }
                                    });
                                };
                                WaitForPrivateLocationAttachment();
                            });
                        };
                        const LogAwaitedAttachment = (____) => {
                            const DoesAwaitedAttachmentExist = !Validator.TypeGuard.Default.IsNullOrUndefined(____);
                            if (DoesAwaitedAttachmentExist) {
                                const [EventContext, Message, Attachment, MessageChat, MessageAuthor] = ____;
                                this.Log.Preset.Info(`Обработано отложенное вложение (геолокация) в приватном чате от пользователя ${this.__FormUserName(MessageAuthor.username, MessageAuthor.first_name, MessageAuthor.last_name)} [`, MessageAuthor.id, `]`);
                            }
                            else {
                                this.Log.Preset.Warn(`Обработка отложенного вложения (геолокация) в приватном чате от пользователя [`, __, `] прервана. Истек лимит ожидания`);
                            }
                        };
                        const DoesTimeLimitExist = !Validator.TypeGuard.Default.IsNullOrUndefined(___);
                        if (DoesTimeLimitExist) {
                            const AwaitedTimer = async () => {
                                return new Promise(async (resolve, reject) => {
                                    await ServerCore.Engine.Module.Functions.Sleep(___);
                                    resolve(undefined);
                                });
                            };
                            const AwaitedLocationAttachment = await Promise.any([AwaitedTimer(), AwaitedPrivateLocationAttachment()]);
                            LogAwaitedAttachment(AwaitedLocationAttachment);
                            return AwaitedLocationAttachment;
                        }
                        else {
                            const AwaitedLocationAttachment = await Promise.any([AwaitedPrivateLocationAttachment()]);
                            LogAwaitedAttachment(AwaitedLocationAttachment);
                            return AwaitedLocationAttachment;
                        }
                    }),
                    Public: {
                        Chat: (async (_, __, ___) => {
                            Validator.Strict(_, new Validator().Default.Numeric().Number().Required().Min(1));
                            Validator.Strict(__, new Validator().Default.Numeric().Number().Required().Min(1));
                            Validator.Strict(___, new Validator().Default.Numeric().Number().Min(1));
                            const AwaitedPublicChatLocationAttachment = async () => {
                                return new Promise(async (resolve, reject) => {
                                    const WaitForPublicChatLocationAttachment = () => {
                                        this.Event.Emitter.Once(TelegramAPI.Event.Name.Attachment.Location.Separate.Public.Chat.Send, (eventContext, message, attachment, messageChat, messageAuthor) => {
                                            const ReceivedMessageChatIDMatch = _ === messageChat.id;
                                            const ReceivedMessageAuthorIDMatch = __ === messageAuthor.id;
                                            if (ReceivedMessageChatIDMatch && ReceivedMessageAuthorIDMatch) {
                                                resolve([eventContext, message, attachment, messageChat, messageAuthor]);
                                            }
                                            else {
                                                WaitForPublicChatLocationAttachment();
                                            }
                                        });
                                    };
                                    WaitForPublicChatLocationAttachment();
                                });
                            };
                            const LogAwaitedAttachment = (____) => {
                                const DoesAwaitedAttachmentExist = !Validator.TypeGuard.Default.IsNullOrUndefined(____);
                                if (DoesAwaitedAttachmentExist) {
                                    const [EventContext, Message, Attachment, MessageChat, MessageAuthor] = ____;
                                    const MessageChatName = MessageChat.type === `group` ? MessageChat.title : MessageChat.type === `supergroup` ? MessageChat.title : MessageChat.username;
                                    this.Log.Preset.Info(`Обработано отложенное вложение (геолокация) в публичном чате '${MessageChatName}' [`, MessageChat.id, `] от пользователя ${this.__FormUserName(MessageAuthor.username, MessageAuthor.first_name, MessageAuthor.last_name)} [`, MessageAuthor.id, `]`);
                                }
                                else {
                                    this.Log.Preset.Warn(`Обработка отложенного вложения (геолокация) в публичном чате [`, _, `] от пользователя [`, __, `] прервана. Истек лимит ожидания`);
                                }
                            };
                            const DoesTimeLimitExist = !Validator.TypeGuard.Default.IsNullOrUndefined(___);
                            if (DoesTimeLimitExist) {
                                const AwaitedTimer = async () => {
                                    return new Promise(async (resolve, reject) => {
                                        await ServerCore.Engine.Module.Functions.Sleep(___);
                                        resolve(undefined);
                                    });
                                };
                                const AwaitedLocationAttachment = await Promise.any([AwaitedTimer(), AwaitedPublicChatLocationAttachment()]);
                                LogAwaitedAttachment(AwaitedLocationAttachment);
                                return AwaitedLocationAttachment;
                            }
                            else {
                                const AwaitedLocationAttachment = await Promise.any([AwaitedPublicChatLocationAttachment()]);
                                LogAwaitedAttachment(AwaitedLocationAttachment);
                                return AwaitedLocationAttachment;
                            }
                        }),
                    },
                },
                Chat: {
                    Private: (async (_, __, ___) => {
                        Validator.Strict(_, new Validator().Default.Numeric().Number().Required().Min(1));
                        Validator.Strict(__, new Validator().Default.Numeric().Number().Required().Min(1));
                        Validator.Strict(___, new Validator().Default.Numeric().Number().Min(1));
                        const AwaitedPrivateChatAttachment = async () => {
                            return new Promise(async (resolve, reject) => {
                                const WaitForPrivateChatAttachment = () => {
                                    this.Event.Emitter.Once(TelegramAPI.Event.Name.Attachment.Chat.Separate.Private.Send, (eventContext, message, attachment, messageChat, messageAuthor) => {
                                        const ReceivedMessageChatIDMatch = _ === messageChat.id;
                                        const ReceivedMessageAuthorIDMatch = __ === messageAuthor.id;
                                        if (ReceivedMessageChatIDMatch && ReceivedMessageAuthorIDMatch) {
                                            resolve([eventContext, message, attachment, messageChat, messageAuthor]);
                                        }
                                        else {
                                            WaitForPrivateChatAttachment();
                                        }
                                    });
                                };
                                WaitForPrivateChatAttachment();
                            });
                        };
                        const LogAwaitedAttachment = (____) => {
                            const DoesAwaitedAttachmentExist = !Validator.TypeGuard.Default.IsNullOrUndefined(____);
                            if (DoesAwaitedAttachmentExist) {
                                const [EventContext, Message, Attachment, MessageChat, MessageAuthor] = ____;
                                this.Log.Preset.Info(`Обработано отложенное вложение (чат) в приватном чате от пользователя ${this.__FormUserName(MessageAuthor.username, MessageAuthor.first_name, MessageAuthor.last_name)} [`, MessageAuthor.id, `]`);
                            }
                            else {
                                this.Log.Preset.Warn(`Обработка отложенного вложения (чат) в приватном чате от пользователя [`, __, `] прервана. Истек лимит ожидания`);
                            }
                        };
                        const DoesTimeLimitExist = !Validator.TypeGuard.Default.IsNullOrUndefined(___);
                        if (DoesTimeLimitExist) {
                            const AwaitedTimer = async () => {
                                return new Promise(async (resolve, reject) => {
                                    await ServerCore.Engine.Module.Functions.Sleep(___);
                                    resolve(undefined);
                                });
                            };
                            const AwaitedChatAttachment = await Promise.any([AwaitedTimer(), AwaitedPrivateChatAttachment()]);
                            LogAwaitedAttachment(AwaitedChatAttachment);
                            return AwaitedChatAttachment;
                        }
                        else {
                            const AwaitedChatAttachment = await Promise.any([AwaitedPrivateChatAttachment()]);
                            LogAwaitedAttachment(AwaitedChatAttachment);
                            return AwaitedChatAttachment;
                        }
                    }),
                    Public: {
                        Chat: (async (_, __, ___) => {
                            Validator.Strict(_, new Validator().Default.Numeric().Number().Required().Min(1));
                            Validator.Strict(__, new Validator().Default.Numeric().Number().Required().Min(1));
                            Validator.Strict(___, new Validator().Default.Numeric().Number().Min(1));
                            const AwaitedPublicChatChatAttachment = async () => {
                                return new Promise(async (resolve, reject) => {
                                    const WaitForPublicChatChatAttachment = () => {
                                        this.Event.Emitter.Once(TelegramAPI.Event.Name.Attachment.Chat.Separate.Public.Chat.Send, (eventContext, message, attachment, messageChat, messageAuthor) => {
                                            const ReceivedMessageChatIDMatch = _ === messageChat.id;
                                            const ReceivedMessageAuthorIDMatch = __ === messageAuthor.id;
                                            if (ReceivedMessageChatIDMatch && ReceivedMessageAuthorIDMatch) {
                                                resolve([eventContext, message, attachment, messageChat, messageAuthor]);
                                            }
                                            else {
                                                WaitForPublicChatChatAttachment();
                                            }
                                        });
                                    };
                                    WaitForPublicChatChatAttachment();
                                });
                            };
                            const LogAwaitedAttachment = (____) => {
                                const DoesAwaitedAttachmentExist = !Validator.TypeGuard.Default.IsNullOrUndefined(____);
                                if (DoesAwaitedAttachmentExist) {
                                    const [EventContext, Message, Attachment, MessageChat, MessageAuthor] = ____;
                                    const MessageChatName = MessageChat.type === `group` ? MessageChat.title : MessageChat.type === `supergroup` ? MessageChat.title : MessageChat.username;
                                    this.Log.Preset.Info(`Обработано отложенное вложение (чат) в публичном чате '${MessageChatName}' [`, MessageChat.id, `] от пользователя ${this.__FormUserName(MessageAuthor.username, MessageAuthor.first_name, MessageAuthor.last_name)} [`, MessageAuthor.id, `]`);
                                }
                                else {
                                    this.Log.Preset.Warn(`Обработка отложенного вложения (чат) в публичном чате [`, _, `] от пользователя [`, __, `] прервана. Истек лимит ожидания`);
                                }
                            };
                            const DoesTimeLimitExist = !Validator.TypeGuard.Default.IsNullOrUndefined(___);
                            if (DoesTimeLimitExist) {
                                const AwaitedTimer = async () => {
                                    return new Promise(async (resolve, reject) => {
                                        await ServerCore.Engine.Module.Functions.Sleep(___);
                                        resolve(undefined);
                                    });
                                };
                                const AwaitedChatAttachment = await Promise.any([AwaitedTimer(), AwaitedPublicChatChatAttachment()]);
                                LogAwaitedAttachment(AwaitedChatAttachment);
                                return AwaitedChatAttachment;
                            }
                            else {
                                const AwaitedChatAttachment = await Promise.any([AwaitedPublicChatChatAttachment()]);
                                LogAwaitedAttachment(AwaitedChatAttachment);
                                return AwaitedChatAttachment;
                            }
                        }),
                    },
                },
                User: {
                    Private: (async (_, __, ___) => {
                        Validator.Strict(_, new Validator().Default.Numeric().Number().Required().Min(1));
                        Validator.Strict(__, new Validator().Default.Numeric().Number().Required().Min(1));
                        Validator.Strict(___, new Validator().Default.Numeric().Number().Min(1));
                        const AwaitedPrivateUserAttachment = async () => {
                            return new Promise(async (resolve, reject) => {
                                const WaitForPrivateUserAttachment = () => {
                                    this.Event.Emitter.Once(TelegramAPI.Event.Name.Attachment.User.Separate.Private.Send, (eventContext, message, attachment, messageChat, messageAuthor) => {
                                        const ReceivedMessageChatIDMatch = _ === messageChat.id;
                                        const ReceivedMessageAuthorIDMatch = __ === messageAuthor.id;
                                        if (ReceivedMessageChatIDMatch && ReceivedMessageAuthorIDMatch) {
                                            resolve([eventContext, message, attachment, messageChat, messageAuthor]);
                                        }
                                        else {
                                            WaitForPrivateUserAttachment();
                                        }
                                    });
                                };
                                WaitForPrivateUserAttachment();
                            });
                        };
                        const LogAwaitedAttachment = (____) => {
                            const DoesAwaitedAttachmentExist = !Validator.TypeGuard.Default.IsNullOrUndefined(____);
                            if (DoesAwaitedAttachmentExist) {
                                const [EventContext, Message, Attachment, MessageChat, MessageAuthor] = ____;
                                this.Log.Preset.Info(`Обработано отложенное вложение (пользователь) в приватном чате от пользователя ${this.__FormUserName(MessageAuthor.username, MessageAuthor.first_name, MessageAuthor.last_name)} [`, MessageAuthor.id, `]`);
                            }
                            else {
                                this.Log.Preset.Warn(`Обработка отложенного вложения (пользователь) в приватном чате от пользователя [`, __, `] прервана. Истек лимит ожидания`);
                            }
                        };
                        const DoesTimeLimitExist = !Validator.TypeGuard.Default.IsNullOrUndefined(___);
                        if (DoesTimeLimitExist) {
                            const AwaitedTimer = async () => {
                                return new Promise(async (resolve, reject) => {
                                    await ServerCore.Engine.Module.Functions.Sleep(___);
                                    resolve(undefined);
                                });
                            };
                            const AwaitedUserAttachment = await Promise.any([AwaitedTimer(), AwaitedPrivateUserAttachment()]);
                            LogAwaitedAttachment(AwaitedUserAttachment);
                            return AwaitedUserAttachment;
                        }
                        else {
                            const AwaitedUserAttachment = await Promise.any([AwaitedPrivateUserAttachment()]);
                            LogAwaitedAttachment(AwaitedUserAttachment);
                            return AwaitedUserAttachment;
                        }
                    }),
                    Public: {
                        Chat: (async (_, __, ___) => {
                            Validator.Strict(_, new Validator().Default.Numeric().Number().Required().Min(1));
                            Validator.Strict(__, new Validator().Default.Numeric().Number().Required().Min(1));
                            Validator.Strict(___, new Validator().Default.Numeric().Number().Min(1));
                            const AwaitedPublicChatUserAttachment = async () => {
                                return new Promise(async (resolve, reject) => {
                                    const WaitForPublicChatUserAttachment = () => {
                                        this.Event.Emitter.Once(TelegramAPI.Event.Name.Attachment.User.Separate.Public.Chat.Send, (eventContext, message, attachment, messageChat, messageAuthor) => {
                                            const ReceivedMessageChatIDMatch = _ === messageChat.id;
                                            const ReceivedMessageAuthorIDMatch = __ === messageAuthor.id;
                                            if (ReceivedMessageChatIDMatch && ReceivedMessageAuthorIDMatch) {
                                                resolve([eventContext, message, attachment, messageChat, messageAuthor]);
                                            }
                                            else {
                                                WaitForPublicChatUserAttachment();
                                            }
                                        });
                                    };
                                    WaitForPublicChatUserAttachment();
                                });
                            };
                            const LogAwaitedAttachment = (____) => {
                                const DoesAwaitedAttachmentExist = !Validator.TypeGuard.Default.IsNullOrUndefined(____);
                                if (DoesAwaitedAttachmentExist) {
                                    const [EventContext, Message, Attachment, MessageChat, MessageAuthor] = ____;
                                    const MessageChatName = MessageChat.type === `group` ? MessageChat.title : MessageChat.type === `supergroup` ? MessageChat.title : MessageChat.username;
                                    this.Log.Preset.Info(`Обработано отложенное вложение (пользователь) в публичном чате '${MessageChatName}' [`, MessageChat.id, `] от пользователя ${this.__FormUserName(MessageAuthor.username, MessageAuthor.first_name, MessageAuthor.last_name)} [`, MessageAuthor.id, `]`);
                                }
                                else {
                                    this.Log.Preset.Warn(`Обработка отложенного вложения (пользователь) в публичном чате [`, _, `] от пользователя [`, __, `] прервана. Истек лимит ожидания`);
                                }
                            };
                            const DoesTimeLimitExist = !Validator.TypeGuard.Default.IsNullOrUndefined(___);
                            if (DoesTimeLimitExist) {
                                const AwaitedTimer = async () => {
                                    return new Promise(async (resolve, reject) => {
                                        await ServerCore.Engine.Module.Functions.Sleep(___);
                                        resolve(undefined);
                                    });
                                };
                                const AwaitedUserAttachment = await Promise.any([AwaitedTimer(), AwaitedPublicChatUserAttachment()]);
                                LogAwaitedAttachment(AwaitedUserAttachment);
                                return AwaitedUserAttachment;
                            }
                            else {
                                const AwaitedUserAttachment = await Promise.any([AwaitedPublicChatUserAttachment()]);
                                LogAwaitedAttachment(AwaitedUserAttachment);
                                return AwaitedUserAttachment;
                            }
                        }),
                    },
                },
            },
            Action: {
                Component: {
                    Button: {
                        Private: (async (_, __, ___) => {
                            Validator.Strict(_, new Validator().Default.RegExp().Required());
                            Validator.Strict(__, new Validator().Default.Numeric().Number().Required().Min(1));
                            Validator.Strict(___, new Validator().Default.Numeric().Number().Min(1));
                            const AwaitedPrivateButton = async () => {
                                return new Promise(async (resolve, reject) => {
                                    const WaitForPrivateButton = () => {
                                        this.Event.Emitter.Once(TelegramAPI.Event.Name.Action.Component.Button.Separate.Private.Send, (eventContext, action, actionData, actionChat, actionAuthor) => {
                                            const ReceivedActionDataMatch = _.test(actionData);
                                            const ReceivedActionAuthorIDMatch = __ === actionAuthor.id;
                                            if (ReceivedActionDataMatch && ReceivedActionAuthorIDMatch) {
                                                resolve([eventContext, action, actionData, actionChat, actionAuthor]);
                                            }
                                            else {
                                                WaitForPrivateButton();
                                            }
                                        });
                                    };
                                    WaitForPrivateButton();
                                });
                            };
                            const LogAwaitedButton = (____) => {
                                const DoesAwaitedButtonExist = !Validator.TypeGuard.Default.IsNullOrUndefined(____);
                                if (DoesAwaitedButtonExist) {
                                    const [EventContext, Action, ActionData, ActionChat, ActionAuthor] = ____;
                                    this.Log.Preset.Info(`Обработано отложенное нажатие кнопки '${ActionData}' в приватном чате от пользователя ${this.__FormUserName(ActionAuthor.username, ActionAuthor.first_name, ActionAuthor.last_name)} [`, ActionAuthor.id, `]`);
                                }
                                else {
                                    this.Log.Preset.Warn(`Обработка отложенного нажатия кнопки в приватном чате от пользователя [`, __, `] прервана. Истек лимит ожидания`);
                                }
                            };
                            const DoesTimeLimitExist = !Validator.TypeGuard.Default.IsNullOrUndefined(___);
                            if (DoesTimeLimitExist) {
                                const AwaitedTimer = async () => {
                                    return new Promise(async (resolve, reject) => {
                                        await ServerCore.Engine.Module.Functions.Sleep(___);
                                        resolve(undefined);
                                    });
                                };
                                const AwaitedButton = await Promise.any([AwaitedTimer(), AwaitedPrivateButton()]);
                                LogAwaitedButton(AwaitedButton);
                                return AwaitedButton;
                            }
                            else {
                                const AwaitedButton = await Promise.any([AwaitedPrivateButton()]);
                                LogAwaitedButton(AwaitedButton);
                                return AwaitedButton;
                            }
                        }),
                        Public: {
                            Chat: (async (_, __, ___) => {
                                Validator.Strict(_, new Validator().Default.RegExp().Required());
                                Validator.Strict(__, new Validator().Default.Numeric().Number().Required().Min(1));
                                Validator.Strict(___, new Validator().Default.Numeric().Number().Min(1));
                                const AwaitedPublicChatButton = async () => {
                                    return new Promise(async (resolve, reject) => {
                                        const WaitForPublicChatButton = () => {
                                            this.Event.Emitter.Once(TelegramAPI.Event.Name.Action.Component.Button.Separate.Public.Chat.Send, (eventContext, action, actionData, actionChat, actionAuthor) => {
                                                const ReceivedActionDataMatch = _.test(actionData);
                                                const ReceivedActionAuthorIDMatch = __ === actionAuthor.id;
                                                if (ReceivedActionDataMatch && ReceivedActionAuthorIDMatch) {
                                                    resolve([eventContext, action, actionData, actionChat, actionAuthor]);
                                                }
                                                else {
                                                    WaitForPublicChatButton();
                                                }
                                            });
                                        };
                                        WaitForPublicChatButton();
                                    });
                                };
                                const LogAwaitedButton = (____) => {
                                    const DoesAwaitedButtonExist = !Validator.TypeGuard.Default.IsNullOrUndefined(____);
                                    if (DoesAwaitedButtonExist) {
                                        const [EventContext, Action, ActionData, ActionChat, ActionAuthor] = ____;
                                        const ActionChatName = ActionChat.type === `group` ? ActionChat.title : ActionChat.type === `supergroup` ? ActionChat.title : ActionChat.username;
                                        this.Log.Preset.Info(`Обработано отложенное нажатие кнопки '${ActionData}' в публичном чате '${ActionChatName}' [`, ActionChat.id, `] от пользователя ${this.__FormUserName(ActionAuthor.username, ActionAuthor.first_name, ActionAuthor.last_name)} [`, ActionAuthor.id, `]`);
                                    }
                                    else {
                                        this.Log.Preset.Warn(`Обработка отложенного нажатия кнопки в публичном чате [`, _, `] от пользователя [`, __, `] прервана. Истек лимит ожидания`);
                                    }
                                };
                                const DoesTimeLimitExist = !Validator.TypeGuard.Default.IsNullOrUndefined(___);
                                if (DoesTimeLimitExist) {
                                    const AwaitedTimer = async () => {
                                        return new Promise(async (resolve, reject) => {
                                            await ServerCore.Engine.Module.Functions.Sleep(___);
                                            resolve(undefined);
                                        });
                                    };
                                    const AwaitedButton = await Promise.any([AwaitedTimer(), AwaitedPublicChatButton()]);
                                    LogAwaitedButton(AwaitedButton);
                                    return AwaitedButton;
                                }
                                else {
                                    const AwaitedButton = await Promise.any([AwaitedPublicChatButton()]);
                                    LogAwaitedButton(AwaitedButton);
                                    return AwaitedButton;
                                }
                            }),
                        },
                    },
                },
            },
        };
        return Awaited;
    }
    // TODO: JSDoc
    async GetBotInfo() {
        const BotInfo = await this.__GetBotInfo();
        return BotInfo;
    }
    // TODO: JSDoc
    FormUserName(login, firstName, lastName) {
        const UserName = this.__FormUserName(login, firstName, lastName);
        return UserName;
    }
    // TODO: JSDoc
    async Init() {
        await this.__Init();
    }
    // TODO: JSDoc
    constructor(token, source) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        Validator.Strict(token, new Validator().Default.String().Required().MinLength(1));
        Validator.Strict(source, new Validator().Default.Object()
            .Required()
            .Exact({
            Handler: new Validator().Default.Object()
                .Required()
                .Exact({
                Event: new Validator().Default.Object().Required().Exact({
                    Directory: new Validator().Default.String().Required(),
                }),
                Message: new Validator().Default.Object().Required().Exact({
                    Directory: new Validator().Default.String().Required(),
                }),
                Action: new Validator().Default.Object()
                    .Required()
                    .Exact({
                    Component: new Validator().Default.Object().Required().Exact({
                        Directory: new Validator().Default.String().Required(),
                    }),
                }),
                Command: new Validator().Default.Object().Required().Exact({
                    Directory: new Validator().Default.String().Required(),
                }),
            }),
        }));
        const APIFullTag = (tags) => {
            Validator.Strict(tags, new Validator().Default.Array().Required().Of(new Validator().Default.String().Required().MinLength(1)));
            const MaximumTokenHalfLength = ServerCore.Engine.Module.Functions.Parameter.Type.Manager.Default.Numeric.ToRange(Math.floor(token.length / 2), 0, 5);
            const VisibleTokenPart = ServerCore.Engine.Module.Functions.Parameter.Type.Manager.Default.String.PartlyHide(token, {
                Start: { Display: true, Length: MaximumTokenHalfLength },
                Center: { Display: false, Length: 0 },
                End: { Display: true, Length: MaximumTokenHalfLength },
            });
            const FullTagParameters = [];
            FullTagParameters.push(`TELEGRAM`);
            FullTagParameters.push(...tags);
            FullTagParameters.push(`${VisibleTokenPart}`);
            const SpaceSymbol = ServerCore.Engine.Module.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default;
            const FullTag = FullTagParameters.join(`${SpaceSymbol}|${SpaceSymbol}`);
            return FullTag;
        };
        const APITag = {
            Text: APIFullTag([]),
            Color: ServerCore.Engine.Module.Functions.Parameter.Type.Manager.Custom.Color.HEXToRGB(`#0088CC`),
        };
        super({
            Tag: {
                Text: APITag.Text,
                Color: APITag.Color,
            },
        });
        const AbsoluteRootDirectory = ServerCore.Engine.Module.Classes.FileSystem.FormatPath(ServerCore.Engine.Module.Classes.Process.Source.Directory.Path.Get());
        this.__FileSystem = new ServerCore.Engine.Module.Classes.FileSystem(AbsoluteRootDirectory);
        const AbsoluteSource = {
            Handler: {
                Event: {
                    Directory: ServerCore.Engine.Module.Classes.FileSystem.FormatPath(ServerCore.Engine.Module.Dependencies.Default.Node.path.join(this.__FileSystem.Path, source.Handler.Event.Directory)),
                },
                Message: {
                    Directory: ServerCore.Engine.Module.Classes.FileSystem.FormatPath(ServerCore.Engine.Module.Dependencies.Default.Node.path.join(this.__FileSystem.Path, source.Handler.Message.Directory)),
                },
                Action: {
                    Component: {
                        Directory: ServerCore.Engine.Module.Classes.FileSystem.FormatPath(ServerCore.Engine.Module.Dependencies.Default.Node.path.join(this.__FileSystem.Path, source.Handler.Action.Component.Directory)),
                    },
                },
                Command: {
                    Directory: ServerCore.Engine.Module.Classes.FileSystem.FormatPath(ServerCore.Engine.Module.Dependencies.Default.Node.path.join(this.__FileSystem.Path, source.Handler.Command.Directory)),
                },
            },
        };
        Validator.Strict(AbsoluteSource, new Validator().Default.Object()
            .Required()
            .Exact({
            Handler: new Validator().Default.Object()
                .Required()
                .Exact({
                Event: new Validator().Default.Object().Required().Exact({
                    Directory: new Validator().Custom.FileSystem.Entity.Directory().Required().Exist(),
                }),
                Message: new Validator().Default.Object().Required().Exact({
                    Directory: new Validator().Custom.FileSystem.Entity.Directory().Required().Exist(),
                }),
                Action: new Validator().Default.Object()
                    .Required()
                    .Exact({
                    Component: new Validator().Default.Object().Required().Exact({
                        Directory: new Validator().Custom.FileSystem.Entity.Directory().Required().Exist(),
                    }),
                }),
                Command: new Validator().Default.Object().Required().Exact({
                    Directory: new Validator().Custom.FileSystem.Entity.Directory().Required().Exist(),
                }),
            }),
        }));
        this.__Token = token;
        this.Client = new Dependencies.Telegraf.Telegraf(token, {});
        this.__Source = {
            Handler: {
                Event: source.Handler.Event,
                Message: source.Handler.Message,
                Action: {
                    Component: source.Handler.Action.Component,
                },
                Command: source.Handler.Command,
            },
        };
        this.__RegisterMetrics();
    }
    // TODO: JSDoc
    async __GetBotInfo() {
        try {
            const BotInfo = await this.Client.telegram.getMe();
            return BotInfo;
        }
        catch (APIError) {
            this.Log.Preset.Warn(`При получении данных о боте произошла непредвиденная ошибка`);
            throw APIError;
        }
    }
    // TODO: JSDoc
    __FormUserName(login, firstName, lastName) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        Validator.Strict(login, new Validator().Default.String().MinLength(1));
        Validator.Strict(firstName, new Validator().Default.String().MinLength(1));
        Validator.Strict(lastName, new Validator().Default.String().MinLength(1));
        const DoesUserLoginExist = !Validator.TypeGuard.Default.IsNullOrUndefined(login);
        const DoesUserFirstNameExist = !Validator.TypeGuard.Default.IsNullOrUndefined(firstName);
        const DoesUserLastNameExist = !Validator.TypeGuard.Default.IsNullOrUndefined(lastName);
        const UserCredentialsList = [];
        if (DoesUserFirstNameExist)
            UserCredentialsList.push(firstName);
        if (DoesUserLastNameExist)
            UserCredentialsList.push(lastName);
        const DoesUserCredentialsExist = !Validator.TypeGuard.Default.IsEmptyArray(UserCredentialsList);
        if (DoesUserLoginExist) {
            if (DoesUserCredentialsExist) {
                const UserCredentials = `(${UserCredentialsList.join(ServerCore.Engine.Module.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default)})`;
                const UserName = `"@${login}" ${UserCredentials}`;
                return UserName;
            }
            else {
                const UserName = `"@${login}"`;
                return UserName;
            }
        }
        else {
            if (DoesUserCredentialsExist) {
                const UserCredentials = `${UserCredentialsList.join(ServerCore.Engine.Module.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default)}`;
                const UserName = `"${UserCredentials}"`;
                return UserName;
            }
            else {
                const UserName = `"Неизвестный пользователь"`;
                return UserName;
            }
        }
    }
    // TODO: JSDoc
    async __ImportEventHandlers() {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const RelativeEventsPath = this.__Source.Handler.Event.Directory;
        const FolderNameRegExp = /(?=[\w\s]|[\.]|[-])(?:.*)/;
        const FileNameRegExp = /(?=[\w\s]|[\.]|[-])(?:.*)/;
        const ExecutableFilesExtensionRegExp = /(?:ts)|(?:js)/;
        const NonExecutableFilesExtensionRegExp = /(?:d\.ts)|(?:d\.ts\.map)|(?:js\.map)/;
        const EventPathsToInclude = [
            [new RegExp(`(?:${FolderNameRegExp.source})`), new RegExp(`(?:${FileNameRegExp.source})\\.(?:${ExecutableFilesExtensionRegExp.source})`)],
            [new RegExp(`(?:${FileNameRegExp.source})\\.(?:${ExecutableFilesExtensionRegExp.source})`)],
        ];
        const EventPathsToExclude = [
            [new RegExp(`(?:${FolderNameRegExp.source})`), new RegExp(`(?:${FileNameRegExp.source})\\.(?:${NonExecutableFilesExtensionRegExp.source})`)],
            [new RegExp(`(?:${FileNameRegExp.source})\\.(?:${NonExecutableFilesExtensionRegExp.source})`)],
        ];
        const EventsToImport = this.__FileSystem.GetFilesList(RelativeEventsPath, EventPathsToInclude, EventPathsToExclude);
        const SpaceSymbol = ServerCore.Engine.Module.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default;
        const ToNamed = ServerCore.Engine.Module.Functions.Parameter.Type.Manager.Default.Numeric.ToNamed;
        const EventsLengthToString = ToNamed(EventsToImport.length, SpaceSymbol, [undefined, `обработчиков событий`], [undefined, `обработчика событий`], [undefined, `обработчиков событий`]);
        this.Log.Preset.Info(`Загрузка ${EventsLengthToString}`);
        const ImportedEvents = [];
        const ImportEvent = async (eventHandle, eventFilePath) => {
            const EventDeclaration = eventHandle.default;
            try {
                const EventEntity = new EventDeclaration(this);
                const ImportedEvent = {
                    Entity: EventEntity,
                    File: {
                        Path: eventFilePath,
                    },
                };
                ImportedEvents.push(ImportedEvent);
            }
            catch (APIError) {
                const EventFileName = ServerCore.Engine.Module.Dependencies.Default.Node.path.basename(eventFilePath);
                this.Log.Preset.Warn(`При загрузке обработчика событий из файла '${EventFileName}' (${eventFilePath}) произошла непредвиденная ошибка`);
                const DoesAPIErrorExist = Validator.TypeGuard.Default.IsError(APIError);
                if (DoesAPIErrorExist) {
                    this.Log.Preset.Error(APIError, false);
                }
            }
        };
        await this.__FileSystem.Import(RelativeEventsPath, EventPathsToInclude, EventPathsToExclude, ImportEvent);
        const DoesEventToImportExist = !Validator.TypeGuard.Default.IsEmptyArray(EventsToImport);
        const ImportedEventsValue = DoesEventToImportExist ? ImportedEvents.length / EventsToImport.length : 0;
        const ImportedEventsPercentage = ServerCore.Engine.Module.Functions.Parameter.Type.Manager.Default.Numeric.ToPercent(ImportedEventsValue);
        const ImportedEventsLengthToString = ToNamed(ImportedEvents.length, SpaceSymbol, [undefined, `обработчиков событий`], [undefined, `обработчика событий`], [undefined, `обработчиков событий`]);
        const ImportedEventsMessage = DoesEventToImportExist
            ? [
                `Загрузка ${ImportedEventsLengthToString} завершена (`,
                ImportedEvents.length,
                ServerCore.Engine.Module.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default,
                `/`,
                ServerCore.Engine.Module.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default,
                EventsToImport.length,
                `) [${ImportedEventsPercentage}]`,
            ]
            : [`Не найдено ни одного обработчика событий для загрузки`];
        if (ImportedEventsValue === 1) {
            this.Log.Preset.Success(...ImportedEventsMessage);
        }
        else {
            this.Log.Preset.Warn(...ImportedEventsMessage);
        }
        return ImportedEvents;
    }
    // TODO: JSDoc
    async __ImportMessageHandlers() {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const RelativeMessagesPath = this.__Source.Handler.Message.Directory;
        const FolderNameRegExp = /(?=[\w\s]|[\.]|[-])(?:.*)/;
        const FileNameRegExp = /(?=[\w\s]|[\.]|[-])(?:.*)/;
        const ExecutableFilesExtensionRegExp = /(?:ts)|(?:js)/;
        const NonExecutableFilesExtensionRegExp = /(?:d\.ts)|(?:d\.ts\.map)|(?:js\.map)/;
        const MessagePathsToInclude = [
            [new RegExp(`(?:${FolderNameRegExp.source})`), new RegExp(`(?:${FileNameRegExp.source})\\.(?:${ExecutableFilesExtensionRegExp.source})`)],
            [new RegExp(`(?:${FileNameRegExp.source})\\.(?:${ExecutableFilesExtensionRegExp.source})`)],
        ];
        const MessagePathsToExclude = [
            [new RegExp(`(?:${FolderNameRegExp.source})`), new RegExp(`(?:${FileNameRegExp.source})\\.(?:${NonExecutableFilesExtensionRegExp.source})`)],
            [new RegExp(`(?:${FileNameRegExp.source})\\.(?:${NonExecutableFilesExtensionRegExp.source})`)],
        ];
        const MessagesToImport = this.__FileSystem.GetFilesList(RelativeMessagesPath, MessagePathsToInclude, MessagePathsToExclude);
        const SpaceSymbol = ServerCore.Engine.Module.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default;
        const ToNamed = ServerCore.Engine.Module.Functions.Parameter.Type.Manager.Default.Numeric.ToNamed;
        const MessagesLengthToString = ToNamed(MessagesToImport.length, SpaceSymbol, [undefined, `обработчиков сообщений`], [undefined, `обработчика сообщений`], [undefined, `обработчиков сообщений`]);
        this.Log.Preset.Info(`Загрузка ${MessagesLengthToString}`);
        const ImportedMessages = [];
        const ImportMessage = async (messageHandle, messageFilePath) => {
            const MessageDeclaration = messageHandle.default;
            try {
                const MessageEntity = new MessageDeclaration(this);
                const ImportedMessage = {
                    Entity: MessageEntity,
                    File: {
                        Path: messageFilePath,
                    },
                };
                ImportedMessages.push(ImportedMessage);
            }
            catch (APIError) {
                const MessageFileName = ServerCore.Engine.Module.Dependencies.Default.Node.path.basename(messageFilePath);
                this.Log.Preset.Warn(`При загрузке обработчика сообщений из файла '${MessageFileName}' (${messageFilePath}) произошла непредвиденная ошибка`);
                const DoesAPIErrorExist = Validator.TypeGuard.Default.IsError(APIError);
                if (DoesAPIErrorExist) {
                    this.Log.Preset.Error(APIError, false);
                }
            }
        };
        await this.__FileSystem.Import(RelativeMessagesPath, MessagePathsToInclude, MessagePathsToExclude, ImportMessage);
        const DoesMessageToImportExist = !Validator.TypeGuard.Default.IsEmptyArray(MessagesToImport);
        const ImportedMessagesValue = DoesMessageToImportExist ? ImportedMessages.length / MessagesToImport.length : 0;
        const ImportedMessagesPercentage = ServerCore.Engine.Module.Functions.Parameter.Type.Manager.Default.Numeric.ToPercent(ImportedMessagesValue);
        const ImportedMessagesLengthToString = ToNamed(ImportedMessages.length, SpaceSymbol, [undefined, `обработчиков сообщений`], [undefined, `обработчика сообщений`], [undefined, `обработчиков сообщений`]);
        const ImportedMessagesMessage = DoesMessageToImportExist
            ? [
                `Загрузка ${ImportedMessagesLengthToString} завершена (`,
                ImportedMessages.length,
                ServerCore.Engine.Module.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default,
                `/`,
                ServerCore.Engine.Module.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default,
                MessagesToImport.length,
                `) [${ImportedMessagesPercentage}]`,
            ]
            : [`Не найдено ни одного обработчика сообщений для загрузки`];
        if (ImportedMessagesValue === 1) {
            this.Log.Preset.Success(...ImportedMessagesMessage);
        }
        else {
            this.Log.Preset.Warn(...ImportedMessagesMessage);
        }
        return ImportedMessages;
    }
    // TODO: JSDoc
    async __ImportActionComponentHandlers() {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const RelativeActionComponentsPath = this.__Source.Handler.Action.Component.Directory;
        const FolderNameRegExp = /(?=[\w\s]|[\.]|[-])(?:.*)/;
        const FileNameRegExp = /(?=[\w\s]|[\.]|[-])(?:.*)/;
        const ExecutableFilesExtensionRegExp = /(?:ts)|(?:js)/;
        const NonExecutableFilesExtensionRegExp = /(?:d\.ts)|(?:d\.ts\.map)|(?:js\.map)/;
        const ActionComponentPathsToInclude = [
            [new RegExp(`(?:${FolderNameRegExp.source})`), new RegExp(`(?:${FileNameRegExp.source})\\.(?:${ExecutableFilesExtensionRegExp.source})`)],
            [new RegExp(`(?:${FileNameRegExp.source})\\.(?:${ExecutableFilesExtensionRegExp.source})`)],
        ];
        const ActionComponentPathsToExclude = [
            [new RegExp(`(?:${FolderNameRegExp.source})`), new RegExp(`(?:${FileNameRegExp.source})\\.(?:${NonExecutableFilesExtensionRegExp.source})`)],
            [new RegExp(`(?:${FileNameRegExp.source})\\.(?:${NonExecutableFilesExtensionRegExp.source})`)],
        ];
        const ActionComponentsToImport = this.__FileSystem.GetFilesList(RelativeActionComponentsPath, ActionComponentPathsToInclude, ActionComponentPathsToExclude);
        const SpaceSymbol = ServerCore.Engine.Module.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default;
        const ToNamed = ServerCore.Engine.Module.Functions.Parameter.Type.Manager.Default.Numeric.ToNamed;
        const ActionComponentsLengthToString = ToNamed(ActionComponentsToImport.length, SpaceSymbol, [undefined, `обработчиков компонентов`], [undefined, `обработчика компонентов`], [undefined, `обработчиков компонентов`]);
        this.Log.Preset.Info(`Загрузка ${ActionComponentsLengthToString}`);
        const ImportedActionComponents = [];
        const ImportActionComponent = async (actionComponentHandle, actionComponentFilePath) => {
            const ActionComponentDeclaration = actionComponentHandle.default;
            try {
                const ActionComponentEntity = new ActionComponentDeclaration(this);
                const ImportedActionComponent = {
                    Entity: ActionComponentEntity,
                    File: {
                        Path: actionComponentFilePath,
                    },
                };
                ImportedActionComponents.push(ImportedActionComponent);
            }
            catch (APIError) {
                const ActionComponentFileName = ServerCore.Engine.Module.Dependencies.Default.Node.path.basename(actionComponentFilePath);
                this.Log.Preset.Warn(`При загрузке обработчика компонентов из файла '${ActionComponentFileName}' (${actionComponentFilePath}) произошла непредвиденная ошибка`);
                const DoesAPIErrorExist = Validator.TypeGuard.Default.IsError(APIError);
                if (DoesAPIErrorExist) {
                    this.Log.Preset.Error(APIError, false);
                }
            }
        };
        await this.__FileSystem.Import(RelativeActionComponentsPath, ActionComponentPathsToInclude, ActionComponentPathsToExclude, ImportActionComponent);
        const DoesActionComponentToImportExist = !Validator.TypeGuard.Default.IsEmptyArray(ActionComponentsToImport);
        const ImportedActionComponentsValue = DoesActionComponentToImportExist ? ImportedActionComponents.length / ActionComponentsToImport.length : 0;
        const ImportedActionComponentsPercentage = ServerCore.Engine.Module.Functions.Parameter.Type.Manager.Default.Numeric.ToPercent(ImportedActionComponentsValue);
        const ImportedActionComponentsLengthToString = ToNamed(ImportedActionComponents.length, SpaceSymbol, [undefined, `обработчиков компонентов`], [undefined, `обработчика компонентов`], [undefined, `обработчиков компонентов`]);
        const ImportedActionComponentsMessage = DoesActionComponentToImportExist
            ? [
                `Загрузка ${ImportedActionComponentsLengthToString} завершена (`,
                ImportedActionComponents.length,
                ServerCore.Engine.Module.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default,
                `/`,
                ServerCore.Engine.Module.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default,
                ActionComponentsToImport.length,
                `) [${ImportedActionComponentsPercentage}]`,
            ]
            : [`Не найдено ни одного обработчика компонентов для загрузки`];
        if (ImportedActionComponentsValue === 1) {
            this.Log.Preset.Success(...ImportedActionComponentsMessage);
        }
        else {
            this.Log.Preset.Warn(...ImportedActionComponentsMessage);
        }
        return ImportedActionComponents;
    }
    // TODO: JSDoc
    async __ImportCommandHandlers() {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        const RelativeCommandsPath = this.__Source.Handler.Command.Directory;
        const FolderNameRegExp = /(?=[\w\s]|[\.]|[-])(?:.*)/;
        const FileNameRegExp = /(?=[\w\s]|[\.]|[-])(?:.*)/;
        const ExecutableFilesExtensionRegExp = /(?:ts)|(?:js)/;
        const NonExecutableFilesExtensionRegExp = /(?:d\.ts)|(?:d\.ts\.map)|(?:js\.map)/;
        const CommandPathsToInclude = [
            [new RegExp(`(?:${FolderNameRegExp.source})`), new RegExp(`(?:${FileNameRegExp.source})\\.(?:${ExecutableFilesExtensionRegExp.source})`)],
            [new RegExp(`(?:${FileNameRegExp.source})\\.(?:${ExecutableFilesExtensionRegExp.source})`)],
        ];
        const CommandPathsToExclude = [
            [new RegExp(`(?:${FolderNameRegExp.source})`), new RegExp(`(?:${FileNameRegExp.source})\\.(?:${NonExecutableFilesExtensionRegExp.source})`)],
            [new RegExp(`(?:${FileNameRegExp.source})\\.(?:${NonExecutableFilesExtensionRegExp.source})`)],
        ];
        const CommandsToImport = this.__FileSystem.GetFilesList(RelativeCommandsPath, CommandPathsToInclude, CommandPathsToExclude);
        const SpaceSymbol = ServerCore.Engine.Module.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default;
        const ToNamed = ServerCore.Engine.Module.Functions.Parameter.Type.Manager.Default.Numeric.ToNamed;
        const CommandsLengthToString = ToNamed(CommandsToImport.length, SpaceSymbol, [undefined, `обработчиков команд`], [undefined, `обработчика команд`], [undefined, `обработчиков команд`]);
        this.Log.Preset.Info(`Загрузка ${CommandsLengthToString}`);
        const ImportedCommands = [];
        const ImportCommand = async (commandHandle, commandFilePath) => {
            const CommandDeclaration = commandHandle.default;
            try {
                const CommandEntity = new CommandDeclaration(this);
                const ImportedCommand = {
                    Entity: CommandEntity,
                    File: {
                        Path: commandFilePath,
                    },
                };
                ImportedCommands.push(ImportedCommand);
            }
            catch (APIError) {
                const CommandFileName = ServerCore.Engine.Module.Dependencies.Default.Node.path.basename(commandFilePath);
                this.Log.Preset.Warn(`При загрузке обработчика команд из файла '${CommandFileName}' (${commandFilePath}) произошла непредвиденная ошибка`);
                const DoesAPIErrorExist = Validator.TypeGuard.Default.IsError(APIError);
                if (DoesAPIErrorExist) {
                    this.Log.Preset.Error(APIError, false);
                }
            }
        };
        await this.__FileSystem.Import(RelativeCommandsPath, CommandPathsToInclude, CommandPathsToExclude, ImportCommand);
        const DoesCommandToImportExist = !Validator.TypeGuard.Default.IsEmptyArray(CommandsToImport);
        const ImportedCommandsValue = DoesCommandToImportExist ? ImportedCommands.length / CommandsToImport.length : 0;
        const ImportedCommandsPercentage = ServerCore.Engine.Module.Functions.Parameter.Type.Manager.Default.Numeric.ToPercent(ImportedCommandsValue);
        const ImportedCommandsLengthToString = ToNamed(ImportedCommands.length, SpaceSymbol, [undefined, `обработчиков команд`], [undefined, `обработчика команд`], [undefined, `обработчиков команд`]);
        const ImportedCommandsMessage = DoesCommandToImportExist
            ? [
                `Загрузка ${ImportedCommandsLengthToString} завершена (`,
                ImportedCommands.length,
                ServerCore.Engine.Module.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default,
                `/`,
                ServerCore.Engine.Module.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default,
                CommandsToImport.length,
                `) [${ImportedCommandsPercentage}]`,
            ]
            : [`Не найдено ни одного обработчика команд для загрузки`];
        if (ImportedCommandsValue === 1) {
            this.Log.Preset.Success(...ImportedCommandsMessage);
        }
        else {
            this.Log.Preset.Warn(...ImportedCommandsMessage);
        }
        return ImportedCommands;
    }
    // TODO: JSDoc
    async __RegisterCommandsHandler(importedCommands) {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        Validator.Strict(importedCommands, new Validator().Default.Array()
            .Required()
            .Of(new Validator().Default.Object()
            .Required()
            .Exact({
            Entity: new Validator().Default.Class.Instance().Required().Of(Handler.Command.BaseCommand.default),
            File: new Validator().Default.Object().Required().Exact({
                Path: new Validator().Custom.FileSystem.Entity.File().Required().Exist().Reachable().Readable(),
            }),
        })));
        const SpaceSymbol = ServerCore.Engine.Module.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default;
        const ToNamed = ServerCore.Engine.Module.Functions.Parameter.Type.Manager.Default.Numeric.ToNamed;
        const CommandsLengthToString = ToNamed(importedCommands.length, SpaceSymbol, [undefined, `команд`], [undefined, `команды`], [undefined, `команд`]);
        this.Log.Preset.Info(`Подключение ${CommandsLengthToString}`);
        const RegisteredCommands = [];
        const RegisterCommand = async (importedCommand) => {
            const CommandEntity = importedCommand.Entity;
            const CommandName = CommandEntity.Name;
            const RegisteredCommand = {
                Import: CommandEntity,
                Entity: { command: CommandEntity.Name, description: CommandEntity.Description },
            };
            RegisteredCommands.push(RegisteredCommand);
            this.Log.Preset.Info(`Слэш-команда '/${CommandName}' подключена`);
        };
        await Promise.all(importedCommands.map((_el, _ind, _arr) => RegisterCommand(_el)));
        const SetGlobalCommands = async () => {
            const GlobalCommands = RegisteredCommands;
            const GlobalCommandsToRegister = GlobalCommands.map((_el, _ind, _arr) => _el.Entity);
            const DoesGlobalCommandsToRegisterExist = !Validator.TypeGuard.Default.IsEmptyArray(GlobalCommandsToRegister);
            if (DoesGlobalCommandsToRegisterExist) {
                await this.Client.telegram.setMyCommands(GlobalCommandsToRegister);
            }
        };
        await SetGlobalCommands();
        const DoesImportedCommandExist = !Validator.TypeGuard.Default.IsEmptyArray(importedCommands);
        const ImportedCommandsValue = DoesImportedCommandExist ? RegisteredCommands.length / importedCommands.length : 0;
        const ImportedCommandsPercentage = ServerCore.Engine.Module.Functions.Parameter.Type.Manager.Default.Numeric.ToPercent(ImportedCommandsValue);
        const ImportedCommandsLengthToString = ToNamed(RegisteredCommands.length, SpaceSymbol, [undefined, `команд`], [undefined, `команды`], [undefined, `команд`]);
        const ImportedCommandsMessage = DoesImportedCommandExist
            ? [
                `Подключение ${ImportedCommandsLengthToString} завершено (`,
                RegisteredCommands.length,
                ServerCore.Engine.Module.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default,
                `/`,
                ServerCore.Engine.Module.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default,
                importedCommands.length,
                `) [${ImportedCommandsPercentage}]`,
            ]
            : [`Не найдено ни одной загруженной команды для подключения`];
        if (ImportedCommandsValue === 1) {
            this.Log.Preset.Success(...ImportedCommandsMessage);
        }
        else {
            this.Log.Preset.Warn(...ImportedCommandsMessage);
        }
    }
    // TODO: JSDoc
    __RegisterMessageEventHandler() {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        this.Event.Emitter.On(TelegramAPI.Event.Name.Message.Any.Send, async (eventContext, message, messageContent, messageChat, messageAuthor) => {
            const IsMessagePrivate = messageChat.type === `private`;
            if (IsMessagePrivate) {
                const EventParameters = [eventContext, message, messageContent, messageChat, messageAuthor];
                this.Event.Emitter.Emit(TelegramAPI.Event.Name.Message.Separate.Private.Send, ...EventParameters);
            }
            else {
                const EventParameters = [eventContext, message, messageContent, messageChat, messageAuthor];
                this.Event.Emitter.Emit(TelegramAPI.Event.Name.Message.Separate.Public.Chat.Send, ...EventParameters);
            }
        });
        this.Event.Emitter.On(TelegramAPI.Event.Name.Command.Slash.Any.Send, async (eventContext, message, commandName, commandArguments, commandQuery, commandChat, commandAuthor) => {
            const IsCommandPrivate = commandChat.type === `private`;
            if (IsCommandPrivate) {
                const EventParameters = [eventContext, message, commandName, commandArguments, commandQuery, commandChat, commandAuthor];
                this.Event.Emitter.Emit(TelegramAPI.Event.Name.Command.Slash.Separate.Private.Send, ...EventParameters);
            }
            else {
                const EventParameters = [eventContext, message, commandName, commandArguments, commandQuery, commandChat, commandAuthor];
                this.Event.Emitter.Emit(TelegramAPI.Event.Name.Command.Slash.Separate.Public.Chat.Send, ...EventParameters);
            }
        });
        const HandledMessageEvents = new Map();
        const PreventHandledMessageEvent = (messageId, chatId) => {
            const HandledChatMessageEvents = HandledMessageEvents.get(chatId);
            const DoesHandledChatMessageEventExist = !Validator.TypeGuard.Default.IsNullOrUndefined(HandledChatMessageEvents);
            const HandledMessageEvent = DoesHandledChatMessageEventExist ? HandledChatMessageEvents.get(messageId) : undefined;
            const DoesHandledMessageEventExist = !Validator.TypeGuard.Default.IsNullOrUndefined(HandledMessageEvent);
            const IsMessageEventHandled = DoesHandledChatMessageEventExist && DoesHandledMessageEventExist && HandledMessageEvent;
            if (IsMessageEventHandled) {
                this.Log.Preset.Warn(`Зафиксирован дублированный вызов обработчика сообщений`);
                return IsMessageEventHandled;
            }
            else {
                if (!DoesHandledChatMessageEventExist) {
                    HandledMessageEvents.set(chatId, new Map([[messageId, true]]));
                }
                else {
                    if (!DoesHandledMessageEventExist) {
                        HandledChatMessageEvents.set(messageId, true);
                    }
                }
                ServerCore.Engine.Module.Dependencies.Default.Node.timers.setTimeout(() => {
                    const OldHandledChatMessageEvents = HandledMessageEvents.get(chatId);
                    const DoesOldHandledChatMessageEventExist = !Validator.TypeGuard.Default.IsNullOrUndefined(OldHandledChatMessageEvents);
                    const OldHandledMessageEvent = DoesOldHandledChatMessageEventExist ? OldHandledChatMessageEvents.get(messageId) : undefined;
                    const DoesOldHandledMessageEventExist = !Validator.TypeGuard.Default.IsNullOrUndefined(OldHandledMessageEvent);
                    if (DoesOldHandledChatMessageEventExist && DoesOldHandledMessageEventExist) {
                        OldHandledChatMessageEvents.delete(messageId);
                    }
                }, 1000 * 60 * 10);
                return IsMessageEventHandled;
            }
        };
        this.Client.on(Dependencies.TelegrafFilters.message(`text`), async (eventContext) => {
            const EventContext = eventContext;
            const DoesEventContextExist = !Validator.TypeGuard.Default.IsNullOrUndefined(EventContext);
            if (!DoesEventContextExist)
                return;
            const Message = EventContext.message;
            const DoesMessageExist = !Validator.TypeGuard.Default.IsNullOrUndefined(Message);
            if (!DoesMessageExist)
                return;
            const MessageIDToString = `${Message.message_id}`;
            const MessageChatIDToString = `${Message.chat.id}`;
            const IsMessageEventHandled = PreventHandledMessageEvent(MessageIDToString, MessageChatIDToString);
            if (IsMessageEventHandled) {
                return;
            }
            const MessageContent = Message.text;
            const DoesMessageContentExist = !Validator.TypeGuard.Default.IsNullOrUndefined(MessageContent);
            if (!DoesMessageContentExist)
                return;
            const SlicedMessageContent = MessageContent.split(/\s/);
            const CommandPrefix = `/`;
            const PotentialCommandName = SlicedMessageContent[0];
            const DoesPotentialCommandNameExist = !Validator.TypeGuard.Default.IsNullOrUndefined(PotentialCommandName);
            const IsCommand = DoesPotentialCommandNameExist && PotentialCommandName.startsWith(CommandPrefix);
            if (IsCommand) {
                const SlashCommandName = PotentialCommandName.slice(CommandPrefix.length, PotentialCommandName.length);
                const SlashCommandArguments = SlicedMessageContent.slice(1, SlicedMessageContent.length);
                const SlashCommandQuery = SlashCommandArguments.join(ServerCore.Engine.Module.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default);
                const SlashCommandChat = Message.chat;
                const DoesSlashCommandChatExist = !Validator.TypeGuard.Default.IsNullOrUndefined(SlashCommandChat);
                if (!DoesSlashCommandChatExist)
                    return;
                const SlashCommandAuthor = Message.from;
                const DoesSlashCommandAuthorExist = !Validator.TypeGuard.Default.IsNullOrUndefined(SlashCommandAuthor);
                if (!DoesSlashCommandAuthorExist)
                    return;
                const EventParameters = [
                    EventContext,
                    Message,
                    SlashCommandName,
                    SlashCommandArguments,
                    SlashCommandQuery,
                    SlashCommandChat,
                    SlashCommandAuthor,
                ];
                this.Event.Emitter.Emit(TelegramAPI.Event.Name.Command.Slash.Any.Send, ...EventParameters);
            }
            else {
                const MessageChat = Message.chat;
                const DoesMessageChatExist = !Validator.TypeGuard.Default.IsNullOrUndefined(MessageChat);
                if (!DoesMessageChatExist)
                    return;
                const MessageAuthor = Message.from;
                const DoesMessageAuthorExist = !Validator.TypeGuard.Default.IsNullOrUndefined(MessageAuthor);
                if (!DoesMessageAuthorExist)
                    return;
                const EventParameters = [EventContext, Message, MessageContent, MessageChat, MessageAuthor];
                this.Event.Emitter.Emit(TelegramAPI.Event.Name.Message.Any.Send, ...EventParameters);
            }
        });
    }
    // TODO: JSDoc
    __RegisterAttachmentEventHandler() {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        this.Event.Emitter.On(TelegramAPI.Event.Name.Attachment.Phone.Any.Send, async (eventContext, message, phoneAttachment, messageChat, messageAuthor) => {
            const IsMessagePrivate = messageChat.type === `private`;
            if (IsMessagePrivate) {
                const EventParameters = [eventContext, message, phoneAttachment, messageChat, messageAuthor];
                this.Event.Emitter.Emit(TelegramAPI.Event.Name.Attachment.Phone.Separate.Private.Send, ...EventParameters);
            }
            else {
                const EventParameters = [eventContext, message, phoneAttachment, messageChat, messageAuthor];
                this.Event.Emitter.Emit(TelegramAPI.Event.Name.Attachment.Phone.Separate.Public.Chat.Send, ...EventParameters);
            }
        });
        this.Event.Emitter.On(TelegramAPI.Event.Name.Attachment.Location.Any.Send, async (eventContext, message, locationAttachment, messageChat, messageAuthor) => {
            const IsMessagePrivate = messageChat.type === `private`;
            if (IsMessagePrivate) {
                const EventParameters = [eventContext, message, locationAttachment, messageChat, messageAuthor];
                this.Event.Emitter.Emit(TelegramAPI.Event.Name.Attachment.Location.Separate.Private.Send, ...EventParameters);
            }
            else {
                const EventParameters = [eventContext, message, locationAttachment, messageChat, messageAuthor];
                this.Event.Emitter.Emit(TelegramAPI.Event.Name.Attachment.Location.Separate.Public.Chat.Send, ...EventParameters);
            }
        });
        this.Event.Emitter.On(TelegramAPI.Event.Name.Attachment.Chat.Any.Send, async (eventContext, message, chatAttachment, messageChat, messageAuthor) => {
            const IsMessagePrivate = messageChat.type === `private`;
            if (IsMessagePrivate) {
                const EventParameters = [eventContext, message, chatAttachment, messageChat, messageAuthor];
                this.Event.Emitter.Emit(TelegramAPI.Event.Name.Attachment.Chat.Separate.Private.Send, ...EventParameters);
            }
            else {
                const EventParameters = [eventContext, message, chatAttachment, messageChat, messageAuthor];
                this.Event.Emitter.Emit(TelegramAPI.Event.Name.Attachment.Chat.Separate.Public.Chat.Send, ...EventParameters);
            }
        });
        this.Event.Emitter.On(TelegramAPI.Event.Name.Attachment.User.Any.Send, async (eventContext, message, userAttachment, messageChat, messageAuthor) => {
            const IsMessagePrivate = messageChat.type === `private`;
            if (IsMessagePrivate) {
                const EventParameters = [eventContext, message, userAttachment, messageChat, messageAuthor];
                this.Event.Emitter.Emit(TelegramAPI.Event.Name.Attachment.User.Separate.Private.Send, ...EventParameters);
            }
            else {
                const EventParameters = [eventContext, message, userAttachment, messageChat, messageAuthor];
                this.Event.Emitter.Emit(TelegramAPI.Event.Name.Attachment.User.Separate.Public.Chat.Send, ...EventParameters);
            }
        });
        const HandledAttachmentEvents = new Map();
        const PreventHandledAttachmentEvent = (attachmentMessageId, attachmentChatId) => {
            const HandledChatAttachmentMessageEvents = HandledAttachmentEvents.get(attachmentChatId);
            const DoesHandledChatAttachmentMessageEventExist = !Validator.TypeGuard.Default.IsNullOrUndefined(HandledChatAttachmentMessageEvents);
            const HandledAttachmentMessageEvent = DoesHandledChatAttachmentMessageEventExist ? HandledChatAttachmentMessageEvents.get(attachmentMessageId) : undefined;
            const DoesHandledAttachmentMessageEventExist = !Validator.TypeGuard.Default.IsNullOrUndefined(HandledAttachmentMessageEvent);
            const IsAttachmentMessageEventHandled = DoesHandledChatAttachmentMessageEventExist && DoesHandledAttachmentMessageEventExist && HandledAttachmentMessageEvent;
            if (IsAttachmentMessageEventHandled) {
                this.Log.Preset.Warn(`Зафиксирован дублированный вызов обработчика вложений`);
                return IsAttachmentMessageEventHandled;
            }
            else {
                if (!DoesHandledChatAttachmentMessageEventExist) {
                    HandledAttachmentEvents.set(attachmentChatId, new Map([[attachmentMessageId, true]]));
                }
                else {
                    if (!DoesHandledAttachmentMessageEventExist) {
                        HandledChatAttachmentMessageEvents.set(attachmentMessageId, true);
                    }
                }
                ServerCore.Engine.Module.Dependencies.Default.Node.timers.setTimeout(() => {
                    const OldHandledChatAttachmentMessageEvents = HandledAttachmentEvents.get(attachmentChatId);
                    const DoesOldHandledChatAttachmentMessageEventExist = !Validator.TypeGuard.Default.IsNullOrUndefined(OldHandledChatAttachmentMessageEvents);
                    const OldHandledAttachmentMessageEvent = DoesOldHandledChatAttachmentMessageEventExist ? OldHandledChatAttachmentMessageEvents.get(attachmentMessageId) : undefined;
                    const DoesOldHandledAttachmentMessageEventExist = !Validator.TypeGuard.Default.IsNullOrUndefined(OldHandledAttachmentMessageEvent);
                    if (DoesOldHandledChatAttachmentMessageEventExist && DoesOldHandledAttachmentMessageEventExist) {
                        HandledAttachmentEvents.delete(attachmentMessageId);
                    }
                }, 1000 * 60 * 10);
                return IsAttachmentMessageEventHandled;
            }
        };
        this.Client.on(Dependencies.TelegrafFilters.message(`contact`), async (eventContext) => {
            const EventContext = eventContext;
            const DoesEventContextExist = !Validator.TypeGuard.Default.IsNullOrUndefined(EventContext);
            if (!DoesEventContextExist)
                return;
            const Message = EventContext.message;
            const DoesMessageExist = !Validator.TypeGuard.Default.IsNullOrUndefined(Message);
            if (!DoesMessageExist)
                return;
            const AttachmentMessageIDToString = `${Message.message_id}`;
            const AttachmentMessageChatIDToString = `${Message.chat.id}`;
            const IsAttachmentEventHandled = PreventHandledAttachmentEvent(AttachmentMessageIDToString, AttachmentMessageChatIDToString);
            if (IsAttachmentEventHandled) {
                return;
            }
            const PhoneAttachment = Message.contact.phone_number;
            const DoesPhoneAttachmentExist = !Validator.TypeGuard.Default.IsNullOrUndefined(PhoneAttachment);
            if (!DoesPhoneAttachmentExist)
                return;
            const MessageChat = Message.chat;
            const DoesMessageChatExist = !Validator.TypeGuard.Default.IsNullOrUndefined(MessageChat);
            if (!DoesMessageChatExist)
                return;
            const MessageAuthor = Message.from;
            const DoesMessageAuthorExist = !Validator.TypeGuard.Default.IsNullOrUndefined(MessageAuthor);
            if (!DoesMessageAuthorExist)
                return;
            const EventParameters = [EventContext, Message, PhoneAttachment, MessageChat, MessageAuthor];
            this.Event.Emitter.Emit(TelegramAPI.Event.Name.Attachment.Phone.Any.Send, ...EventParameters);
        });
        this.Client.on(Dependencies.TelegrafFilters.message(`location`), async (eventContext) => {
            const EventContext = eventContext;
            const DoesEventContextExist = !Validator.TypeGuard.Default.IsNullOrUndefined(EventContext);
            if (!DoesEventContextExist)
                return;
            const Message = EventContext.message;
            const DoesMessageExist = !Validator.TypeGuard.Default.IsNullOrUndefined(Message);
            if (!DoesMessageExist)
                return;
            const AttachmentMessageIDToString = `${Message.message_id}`;
            const AttachmentMessageChatIDToString = `${Message.chat.id}`;
            const IsAttachmentEventHandled = PreventHandledAttachmentEvent(AttachmentMessageIDToString, AttachmentMessageChatIDToString);
            if (IsAttachmentEventHandled) {
                return;
            }
            const LocationAttachment = {
                Latitude: Message.location.latitude,
                Longitude: Message.location.longitude,
            };
            const DoesLocationAttachmentExist = !Validator.TypeGuard.Default.IsNullOrUndefined(LocationAttachment);
            if (!DoesLocationAttachmentExist)
                return;
            const DoesLocationAttachmentLatitudeExist = !Validator.TypeGuard.Default.IsNullOrUndefined(LocationAttachment.Latitude);
            if (!DoesLocationAttachmentLatitudeExist)
                return;
            const DoesLocationAttachmentLongitudeExist = !Validator.TypeGuard.Default.IsNullOrUndefined(LocationAttachment.Longitude);
            if (!DoesLocationAttachmentLongitudeExist)
                return;
            const MessageChat = Message.chat;
            const DoesMessageChatExist = !Validator.TypeGuard.Default.IsNullOrUndefined(MessageChat);
            if (!DoesMessageChatExist)
                return;
            const MessageAuthor = Message.from;
            const DoesMessageAuthorExist = !Validator.TypeGuard.Default.IsNullOrUndefined(MessageAuthor);
            if (!DoesMessageAuthorExist)
                return;
            const EventParameters = [EventContext, Message, LocationAttachment, MessageChat, MessageAuthor];
            this.Event.Emitter.Emit(TelegramAPI.Event.Name.Attachment.Location.Any.Send, ...EventParameters);
        });
        this.Client.on(Dependencies.TelegrafFilters.message(`chat_shared`), async (eventContext) => {
            const EventContext = eventContext;
            const DoesEventContextExist = !Validator.TypeGuard.Default.IsNullOrUndefined(EventContext);
            if (!DoesEventContextExist)
                return;
            const Message = EventContext.message;
            const DoesMessageExist = !Validator.TypeGuard.Default.IsNullOrUndefined(Message);
            if (!DoesMessageExist)
                return;
            const AttachmentMessageIDToString = `${Message.message_id}`;
            const AttachmentMessageChatIDToString = `${Message.chat.id}`;
            const IsAttachmentEventHandled = PreventHandledAttachmentEvent(AttachmentMessageIDToString, AttachmentMessageChatIDToString);
            if (IsAttachmentEventHandled) {
                return;
            }
            const ChatAttachment = {
                ID: Message.chat_shared.chat_id,
            };
            const DoesChatAttachmentExist = !Validator.TypeGuard.Default.IsNullOrUndefined(ChatAttachment);
            if (!DoesChatAttachmentExist)
                return;
            const DoesChatAttachmentIDExist = !Validator.TypeGuard.Default.IsNullOrUndefined(ChatAttachment.ID);
            if (!DoesChatAttachmentIDExist)
                return;
            const MessageChat = Message.chat;
            const DoesMessageChatExist = !Validator.TypeGuard.Default.IsNullOrUndefined(MessageChat);
            if (!DoesMessageChatExist)
                return;
            const MessageAuthor = Message.from;
            const DoesMessageAuthorExist = !Validator.TypeGuard.Default.IsNullOrUndefined(MessageAuthor);
            if (!DoesMessageAuthorExist)
                return;
            const EventParameters = [EventContext, Message, ChatAttachment, MessageChat, MessageAuthor];
            this.Event.Emitter.Emit(TelegramAPI.Event.Name.Attachment.Chat.Any.Send, ...EventParameters);
        });
        this.Client.on(Dependencies.TelegrafFilters.message(`user_shared`), async (eventContext) => {
            const EventContext = eventContext;
            const DoesEventContextExist = !Validator.TypeGuard.Default.IsNullOrUndefined(EventContext);
            if (!DoesEventContextExist)
                return;
            const Message = EventContext.message;
            const DoesMessageExist = !Validator.TypeGuard.Default.IsNullOrUndefined(Message);
            if (!DoesMessageExist)
                return;
            const AttachmentMessageIDToString = `${Message.message_id}`;
            const AttachmentMessageChatIDToString = `${Message.chat.id}`;
            const IsAttachmentEventHandled = PreventHandledAttachmentEvent(AttachmentMessageIDToString, AttachmentMessageChatIDToString);
            if (IsAttachmentEventHandled) {
                return;
            }
            const UserAttachment = {
                ID: Message.user_shared.user_id,
            };
            const DoesUserAttachmentExist = !Validator.TypeGuard.Default.IsNullOrUndefined(UserAttachment);
            if (!DoesUserAttachmentExist)
                return;
            const DoesUserAttachmentIDExist = !Validator.TypeGuard.Default.IsNullOrUndefined(UserAttachment.ID);
            if (!DoesUserAttachmentIDExist)
                return;
            const MessageChat = Message.chat;
            const DoesMessageChatExist = !Validator.TypeGuard.Default.IsNullOrUndefined(MessageChat);
            if (!DoesMessageChatExist)
                return;
            const MessageAuthor = Message.from;
            const DoesMessageAuthorExist = !Validator.TypeGuard.Default.IsNullOrUndefined(MessageAuthor);
            if (!DoesMessageAuthorExist)
                return;
            const EventParameters = [EventContext, Message, UserAttachment, MessageChat, MessageAuthor];
            this.Event.Emitter.Emit(TelegramAPI.Event.Name.Attachment.User.Any.Send, ...EventParameters);
        });
    }
    // TODO: JSDoc
    __RegisterActionEventHandler() {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        this.Event.Emitter.On(TelegramAPI.Event.Name.Action.Component.Button.Any.Send, async (eventContext, action, actionData, actionChat, actionAuthor) => {
            const IsActionPrivate = actionChat.type === `private`;
            if (IsActionPrivate) {
                const EventParameters = [eventContext, action, actionData, actionChat, actionAuthor];
                this.Event.Emitter.Emit(TelegramAPI.Event.Name.Action.Component.Button.Separate.Private.Send, ...EventParameters);
            }
            else {
                const EventParameters = [eventContext, action, actionData, actionChat, actionAuthor];
                this.Event.Emitter.Emit(TelegramAPI.Event.Name.Action.Component.Button.Separate.Public.Chat.Send, ...EventParameters);
            }
        });
        const HandledActionEvents = new Map();
        const PreventHandledActionEvent = (actionId, actionChatId) => {
            const HandledChatActionEvents = HandledActionEvents.get(actionChatId);
            const DoesHandledChatActionEventExist = !Validator.TypeGuard.Default.IsNullOrUndefined(HandledChatActionEvents);
            const HandledActionEvent = DoesHandledChatActionEventExist ? HandledChatActionEvents.get(actionId) : undefined;
            const DoesHandledActionEventExist = !Validator.TypeGuard.Default.IsNullOrUndefined(HandledActionEvent);
            const IsActionEventHandled = DoesHandledChatActionEventExist && DoesHandledActionEventExist && HandledActionEvent;
            if (IsActionEventHandled) {
                this.Log.Preset.Warn(`Зафиксирован дублированный вызов обработчика взаимодействий`);
                return IsActionEventHandled;
            }
            else {
                if (!DoesHandledChatActionEventExist) {
                    HandledActionEvents.set(actionChatId, new Map([[actionId, true]]));
                }
                else {
                    if (!DoesHandledActionEventExist) {
                        HandledChatActionEvents.set(actionId, true);
                    }
                }
                ServerCore.Engine.Module.Dependencies.Default.Node.timers.setTimeout(() => {
                    const OldHandledChatActionEvents = HandledActionEvents.get(actionChatId);
                    const DoesOldHandledChatActionEventExist = !Validator.TypeGuard.Default.IsNullOrUndefined(OldHandledChatActionEvents);
                    const OldHandledActionEvent = DoesOldHandledChatActionEventExist ? OldHandledChatActionEvents.get(actionId) : undefined;
                    const DoesOldHandledActionEventExist = !Validator.TypeGuard.Default.IsNullOrUndefined(OldHandledActionEvent);
                    if (DoesOldHandledChatActionEventExist && DoesOldHandledActionEventExist) {
                        HandledActionEvents.delete(actionId);
                    }
                }, 1000 * 60 * 10);
                return IsActionEventHandled;
            }
        };
        this.Client.on(Dependencies.TelegrafFilters.callbackQuery(`data`), async (eventContext) => {
            const EventContext = eventContext;
            const DoesEventContextExist = !Validator.TypeGuard.Default.IsNullOrUndefined(EventContext);
            if (!DoesEventContextExist)
                return;
            const Action = EventContext.callbackQuery;
            const ActionIDToString = `${Action.id}`;
            const ActionChatIDToString = `${Action.chat_instance}`;
            const IsAttachmentEventHandled = PreventHandledActionEvent(ActionIDToString, ActionChatIDToString);
            if (IsAttachmentEventHandled) {
                return;
            }
            const ActionData = Action.data;
            const DoesActionDataExist = !Validator.TypeGuard.Default.IsNullOrUndefined(ActionData);
            if (!DoesActionDataExist)
                return;
            const ActionChat = EventContext.chat;
            const DoesActionChatExist = !Validator.TypeGuard.Default.IsNullOrUndefined(ActionChat);
            if (!DoesActionChatExist)
                return;
            const ActionAuthor = Action.from;
            const DoesActionAuthorExist = !Validator.TypeGuard.Default.IsNullOrUndefined(ActionAuthor);
            if (!DoesActionAuthorExist)
                return;
            const EventParameters = [EventContext, Action, ActionData, ActionChat, ActionAuthor];
            this.Event.Emitter.Emit(TelegramAPI.Event.Name.Action.Component.Button.Any.Send, ...EventParameters);
        });
    }
    // TODO: JSDoc
    __RegisterInitializationHandler() {
        this.Event.Emitter.On(TelegramAPI.Event.Name.Init, async (botInfo) => {
            const BotName = this.__FormUserName(botInfo.username, botInfo.first_name, botInfo.last_name);
            const BotURL = `https://t.me/${botInfo.username}`;
            this.Log.Preset.Info(`Бот ${BotName} [${BotURL}] успешно запущен`);
        });
    }
    // TODO: JSDoc
    __RegisterEventHandlers() {
        this.__RegisterMessageEventHandler();
        this.__RegisterAttachmentEventHandler();
        this.__RegisterActionEventHandler();
    }
    // TODO: JSDoc
    __RegisterHandlers() {
        this.__RegisterEventHandlers();
        this.__RegisterInitializationHandler();
    }
    // TODO: JSDoc
    __RegisterMetrics() {
        this.__RegisterHandlers();
    }
    // TODO: JSDoc
    async __Init() {
        const Validator = ServerCore.Engine.Module.Classes.Validator;
        this.Log.Preset.Info(`Инициализация клиента Telegram`);
        const ImportedEventHandlers = await this.__ImportEventHandlers();
        const ImportedMessageHandlers = await this.__ImportMessageHandlers();
        const ImportedActionComponentHandlers = await this.__ImportActionComponentHandlers();
        const ImportedCommandHandlers = await this.__ImportCommandHandlers();
        try {
            this.Client.launch();
            await this.__RegisterCommandsHandler(ImportedCommandHandlers);
            this._SetReady(true);
            const BotInfo = await this.__GetBotInfo();
            this.Event.Emitter.Emit(TelegramAPI.Event.Name.Init, BotInfo);
        }
        catch (APIError) {
            this.Log.Preset.Warn(`При запуске бота произошла непредвиденная ошибка`);
            const DoesAPIErrorExist = Validator.TypeGuard.Default.IsError(APIError);
            if (DoesAPIErrorExist) {
                this.Log.Preset.Error(APIError, false);
            }
        }
    }
}
export default TelegramAPI;
//# sourceMappingURL=__api.js.map