import * as PostgreSQLAPI from '../../__api.js';
type TableInputExtension = Record<string, any>;
type TableOutputExtension = Record<string, any>;
interface ITableField<ValueType extends any> {
    readonly Type: string;
    readonly MetaData: {
        readonly DefaultValue: ValueType | undefined;
        readonly IsPrimary: boolean;
        readonly IsRequired: boolean;
        readonly IsUnique: boolean;
        readonly MustBeAutoIncremented: boolean;
        readonly Reference: {
            readonly Table: {
                readonly Name: string;
            };
            readonly Field: string;
        } | undefined;
    };
}
type TableFieldList<Input extends TableInputExtension, Output extends TableOutputExtension> = {
    [K in keyof Output]: ITableField<Output[K]>;
};
export declare const DataType: {
    readonly String: {
        readonly Char: "CHAR";
        readonly VarChar: "VARCHAR";
        readonly Binary: "BINARY";
        readonly VarBinary: "VARBINARY";
        readonly TinyText: "TINYBLOB";
        readonly TinyBlob: "TINYTEXT";
        readonly Text: "TEXT";
        readonly Blob: "BLOB";
        readonly MediumText: "MEDIUMTEXT";
        readonly MediumBlob: "MEDIUMBLOB";
        readonly LongText: "LONGTEXT";
        readonly LongBlob: "LONGBLOB";
    };
    readonly Numeric: {
        readonly Bit: "BIT";
        readonly TinyInt: "TINYINT";
        readonly SmallInt: "SMALLINT";
        readonly MediumInt: "MEDIUMINT";
        readonly Int: "INT";
        readonly Integer: "INTEGER";
        readonly Serial: "SERIAL";
        readonly BigInt: "BIGINT";
        readonly Float: "FLOAT";
        readonly Double: "DOUBLE";
        readonly Decimal: "DECIMAL";
        readonly Dec: "DEC";
    };
    readonly Date: {
        readonly Date: "DATE";
        readonly DateTime: "DATETIME";
        readonly TimeStamp: "TIMESTAMP";
        readonly Time: "TIME";
        readonly Year: "YEAR";
    };
    readonly Other: {
        readonly Bool: "BOOL";
        readonly Boolean: "BOOLEAN";
    };
};
interface ITableConditionGetter<Input extends TableInputExtension, Output extends TableOutputExtension> {
    readonly Single: {
        readonly Like: <OutputField extends keyof Output>(field: OutputField, value: string) => string;
        readonly MoreThan: <OutputField extends keyof Output>(field: OutputField, value: Output[OutputField]) => string;
        readonly NotMoreThan: <OutputField extends keyof Output>(field: OutputField, value: Output[OutputField]) => string;
        readonly MoreThanOrEqual: <OutputField extends keyof Output>(field: OutputField, value: Output[OutputField]) => string;
        readonly NotMoreThanOrEqual: <OutputField extends keyof Output>(field: OutputField, value: Output[OutputField]) => string;
        readonly EqualTo: <OutputField extends keyof Output>(field: OutputField, value: Output[OutputField]) => string;
        readonly NotEqualTo: <OutputField extends keyof Output>(field: OutputField, value: Output[OutputField]) => string;
        readonly LessThan: <OutputField extends keyof Output>(field: OutputField, value: Output[OutputField]) => string;
        readonly NotLessThan: <OutputField extends keyof Output>(field: OutputField, value: Output[OutputField]) => string;
        readonly LessThanOrEqual: <OutputField extends keyof Output>(field: OutputField, value: Output[OutputField]) => string;
        readonly NotLessThanOrEqual: <OutputField extends keyof Output>(field: OutputField, value: Output[OutputField]) => string;
    };
    readonly Multiple: {
        readonly Every: (...conditions: Array<string>) => string;
        readonly Some: (...conditions: Array<string>) => string;
    };
}
interface ITableValueSetterGetter<Input extends TableInputExtension, Output extends TableOutputExtension> {
    readonly Single: <OutputField extends keyof Output>(field: OutputField, value: Output[OutputField]) => string;
    readonly Multiple: (...valueSetters: Array<string>) => string;
}
export default class BaseTable<Input extends TableInputExtension, Output extends TableOutputExtension> {
    readonly Name: string;
    readonly Fields: TableFieldList<Input, Output>;
    private readonly __API;
    private readonly __DataBase;
    get Condition(): ITableConditionGetter<Input, Output>;
    get ValueSetter(): ITableValueSetterGetter<Input, Output>;
    Insert(...elements: Array<Input>): Promise<Array<Output>>;
    Update(valueSetter: string, condition: string | undefined): Promise<Array<Output>>;
    Select<OutputFields extends Array<keyof Output>>(fields: OutputFields, condition: string | undefined, unique: boolean, limit: number | undefined): Promise<Array<Pick<Output, OutputFields[number]>>>;
    Select(fields: undefined, condition: string | undefined, unique: boolean, limit: number | undefined): Promise<Array<Output>>;
    Delete(condition: string | undefined): Promise<Array<Output>>;
    DoesExist(): Promise<boolean>;
    CreateIfNotExist(): Promise<void>;
    constructor(api: PostgreSQLAPI.default, database: PostgreSQLAPI.DataBases.BaseDataBase, name: string, fields: TableFieldList<Input, Output>);
    private __Insert;
    private __Update;
    private __Select;
    private __Delete;
    private __DoesExist;
    private __CreateIfNotExist;
}
export {};
//# sourceMappingURL=BaseTable.d.ts.map