import * as GlobalModule from '../@module.js';
type QueueElementExtension = any;
interface IQueueSettings<QueueElement extends QueueElementExtension> {
    Pause: boolean;
    readonly Update: {
        Cooldown: number;
        Stack: number;
        Function: (...elements: Array<QueueElement>) => GlobalModule.Types.Promise.Promisable<void>;
    };
}
interface IReadonlyQueueSettings<QueueElement extends QueueElementExtension> {
    readonly Pause: IQueueSettings<QueueElement>['Pause'];
    readonly Update: {
        readonly Cooldown: IQueueSettings<QueueElement>['Update']['Cooldown'];
        readonly Stack: IQueueSettings<QueueElement>['Update']['Stack'];
        readonly Function: IQueueSettings<QueueElement>['Update']['Function'];
    };
}
interface IQueueSettingsGetter<QueueElement extends QueueElementExtension> {
    readonly Get: () => IReadonlyQueueSettings<QueueElement>;
    readonly Set: {
        readonly Update: {
            readonly Cooldown: (newCooldown: IQueueSettings<QueueElement>['Update']['Cooldown']) => void;
            readonly Stack: (newStack: IQueueSettings<QueueElement>['Update']['Stack']) => void;
            readonly Function: (newFunction: IQueueSettings<QueueElement>['Update']['Function']) => void;
        };
    };
}
interface IQueueElementsGetter<QueueElement extends QueueElementExtension> {
    readonly Get: () => Array<QueueElement>;
    readonly Set: {
        readonly Add: {
            readonly Start: (...newElements: Array<QueueElement>) => void;
            readonly End: (...newElements: Array<QueueElement>) => void;
        };
        readonly Remove: {
            readonly Start: (elementsLength: number) => void;
            readonly End: (elementsLength: number) => void;
        };
        readonly Shuffle: () => void;
        readonly Clear: () => void;
    };
}
declare const EventName: {
    readonly Updating: {
        readonly Start: "updatingStart";
        readonly End: "updatingEnd";
        readonly Stop: "updatingStop";
        readonly Pause: "updatingPause";
        readonly Resume: "updatingResume";
    };
    readonly Elements: {
        readonly Add: "elementsAdd";
        readonly Remove: "elementsRemove";
        readonly Next: {
            readonly Before: "elementsBeforeNext";
            readonly After: "elementsAfterNext";
        };
    };
    readonly Settings: {
        readonly Update: "settingsUpdate";
    };
};
interface IEventFunction<QueueElement extends QueueElementExtension> {
    [EventName.Updating.Start]: (elements: Array<QueueElement>) => GlobalModule.Types.Promise.Promisable<void>;
    [EventName.Updating.End]: (elements: Array<QueueElement>) => GlobalModule.Types.Promise.Promisable<void>;
    [EventName.Updating.Stop]: (elements: Array<QueueElement>) => GlobalModule.Types.Promise.Promisable<void>;
    [EventName.Updating.Pause]: (elements: Array<QueueElement>) => GlobalModule.Types.Promise.Promisable<void>;
    [EventName.Updating.Resume]: (elements: Array<QueueElement>) => GlobalModule.Types.Promise.Promisable<void>;
    [EventName.Elements.Add]: (oldElements: Array<QueueElement>, newElements: Array<QueueElement>, addedElements: Array<QueueElement>) => GlobalModule.Types.Promise.Promisable<void>;
    [EventName.Elements.Remove]: (oldElements: Array<QueueElement>, newElements: Array<QueueElement>, removedElements: Array<QueueElement>) => GlobalModule.Types.Promise.Promisable<void>;
    [EventName.Elements.Next.Before]: (...elements: Array<QueueElement>) => GlobalModule.Types.Promise.Promisable<void>;
    [EventName.Elements.Next.After]: (...elements: Array<QueueElement>) => GlobalModule.Types.Promise.Promisable<void>;
    [EventName.Settings.Update]: (oldSettings: IReadonlyQueueSettings<QueueElement>, newSettings: IReadonlyQueueSettings<QueueElement>) => GlobalModule.Types.Promise.Promisable<void>;
}
interface IStaticEventHandler {
    readonly Name: typeof EventName;
}
interface IEventHandler<QueueElement extends QueueElementExtension> {
    readonly Emitter: GlobalModule.Classes.EventEmitter<IEventFunction<QueueElement>>;
}
export default class Queue<QueueElement extends QueueElementExtension> {
    static readonly Event: IStaticEventHandler;
    readonly Event: IEventHandler<QueueElement>;
    private readonly __Elements;
    private readonly __UpdatingInterval;
    private readonly __Settings;
    get Settings(): IQueueSettingsGetter<QueueElement>;
    get Elements(): IQueueElementsGetter<QueueElement>;
    IsPaused(): IQueueSettings<QueueElement>['Pause'];
    Pause(): void;
    Resume(): void;
    Stop(): void;
    constructor(updateCooldown: IQueueSettings<QueueElement>['Update']['Cooldown'], updateStack: IQueueSettings<QueueElement>['Update']['Stack'], updateFunction: IQueueSettings<QueueElement>['Update']['Function']);
    private __GetSettingsCopy;
    private __UpdateSettings;
    private __GetElementsCopy;
    private __AddNewElements;
    private __RemoveElements;
    private __ClearElements;
    private __ShuffleElements;
    private __IsPaused;
    private __Pause;
    private __Resume;
    private __Stop;
    private __Init;
}
export {};
//# sourceMappingURL=Queue.d.ts.map