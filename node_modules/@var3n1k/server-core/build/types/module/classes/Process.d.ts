import * as GlobalModule from '../@module.js';
type NodeProcess = typeof GlobalModule.Dependencies.Default.Node.process;
interface IProcessParentGetter {
    readonly ID: number;
}
interface IProcessSourceGetter {
    readonly File: {
        readonly Path: {
            readonly Get: () => string;
        };
    };
    readonly Directory: {
        readonly Path: {
            readonly Get: () => string;
            readonly Set: (absolutePath: string) => void;
        };
    };
    readonly Executable: {
        readonly Path: {
            readonly Get: () => string;
        };
        readonly Version: string;
    };
}
interface IProcessLaunchGetter {
    readonly Parameters: {
        readonly Base: Array<string>;
        readonly Exec: Array<string>;
    };
}
interface IProcessPlatformGetter {
    readonly Architecture: NodeProcess['arch'];
    readonly Type: NodeProcess['platform'];
}
interface IProcessUsageGetter {
    readonly Uptime: {
        readonly Base: number;
        readonly HighResolution: number;
    };
}
declare const EventName: {
    readonly Stop: "stop";
    readonly Exit: {
        readonly Before: "beforeExit";
        readonly Instantiate: "exit";
    };
    readonly UnhandledException: "unhandledException";
    readonly Name: {
        readonly Update: "nameUpdate";
    };
    readonly Source: {
        readonly Directory: {
            readonly Update: "sourcedirectoryUpdate";
        };
    };
};
interface IEventFunction {
    [EventName.Stop]: () => GlobalModule.Types.Promise.Promisable<void>;
    [EventName.Exit.Before]: (exitCode: number) => GlobalModule.Types.Promise.Promisable<void>;
    [EventName.Exit.Instantiate]: (exitCode: number) => GlobalModule.Types.Promise.Promisable<void>;
    [EventName.UnhandledException]: (exception: globalThis.Error) => GlobalModule.Types.Promise.Promisable<void>;
    [EventName.Name.Update]: (oldName: string, newName: string) => GlobalModule.Types.Promise.Promisable<void>;
    [EventName.Source.Directory.Update]: (oldSourceDirectory: string, newSourceDirectory: string) => GlobalModule.Types.Promise.Promisable<void>;
}
interface IEventHandler {
    readonly Name: typeof EventName;
    readonly Emitter: GlobalModule.Classes.EventEmitter<IEventFunction>;
}
export default class Process {
    static readonly Event: IEventHandler;
    private static readonly __Entity;
    static get ID(): NodeProcess['pid'];
    static get Name(): NodeProcess['title'];
    static get Parent(): IProcessParentGetter;
    static get Source(): IProcessSourceGetter;
    static get Launch(): IProcessLaunchGetter;
    static get Platform(): IProcessPlatformGetter;
    static get Config(): NodeProcess['config'];
    static get Env(): NodeProcess['env'];
    static get Usage(): IProcessUsageGetter;
    static SetName(newName: string): void;
    static ImportEnv(relativePath: string): void;
    static Stop(exitCode: number): never;
    private static __GetRootFilePath;
    private static __GetRootDirectoryPath;
    private static __SetRootDirectoryPath;
    private static __GetExecutableFilePath;
    private static __SetName;
    private static __ImportEnv;
    private static __Stop;
}
export {};
//# sourceMappingURL=Process.d.ts.map