import * as GlobalModule from '../@module.js';
const EventName = {
    Updating: {
        Start: `updatingStart`,
        End: `updatingEnd`,
        Stop: `updatingStop`,
        Pause: `updatingPause`,
        Resume: `updatingResume`,
    },
    Elements: {
        Add: `elementsAdd`,
        Remove: `elementsRemove`,
        Next: {
            Before: `elementsBeforeNext`,
            After: `elementsAfterNext`,
        },
    },
    Settings: {
        Update: `settingsUpdate`,
    },
};
class Queue {
    // TODO: JSDoc
    static Event = { Name: EventName };
    // TODO: JSDoc
    Event = { Emitter: new GlobalModule.Classes.EventEmitter() };
    // TODO: JSDoc
    __Elements = [];
    // TODO: JSDoc
    __UpdatingInterval;
    // TODO: JSDoc
    __Settings = { Pause: false, Update: { Cooldown: 0, Stack: 1, Function: async (..._) => { } } };
    // TODO: JSDoc
    get Settings() {
        const Validator = GlobalModule.Classes.Validator;
        const Settings = {
            Get: () => this.__GetSettingsCopy(),
            Set: {
                Update: {
                    Cooldown: (_) => {
                        Validator.Strict(_, new Validator().Default.Numeric().Number().Required().Integer().Min(0));
                        this.__UpdateSettings(() => {
                            this.__Settings.Update.Cooldown = _;
                        });
                    },
                    Stack: (_) => {
                        Validator.Strict(_, new Validator().Default.Numeric().Number().Required().Integer().Min(1));
                        this.__UpdateSettings(() => {
                            this.__Settings.Update.Stack = _;
                        });
                    },
                    Function: (_) => {
                        Validator.Strict(_, new Validator().Default.Function().Required());
                        this.__UpdateSettings(() => {
                            this.__Settings.Update.Function = _;
                        });
                    },
                },
            },
        };
        return Settings;
    }
    // TODO: JSDoc
    get Elements() {
        const Validator = GlobalModule.Classes.Validator;
        const Elements = {
            Get: () => this.__GetElementsCopy(),
            Set: {
                Add: {
                    Start: (..._) => this.__AddNewElements(true, ..._),
                    End: (..._) => this.__AddNewElements(false, ..._),
                },
                Remove: {
                    Start: (_) => this.__RemoveElements(true, _),
                    End: (_) => this.__RemoveElements(false, _),
                },
                Shuffle: () => this.__ShuffleElements(),
                Clear: () => this.__ClearElements(),
            },
        };
        return Elements;
    }
    // TODO: JSDoc
    IsPaused() {
        const IsQueuePaused = this.__IsPaused();
        return IsQueuePaused;
    }
    // TODO: JSDoc
    Pause() {
        this.__Pause();
    }
    // TODO: JSDoc
    Resume() {
        this.__Resume();
    }
    // TODO: JSDoc
    Stop() {
        this.__Stop();
    }
    // TODO: JSDoc
    constructor(updateCooldown, updateStack, updateFunction) {
        this.Settings.Set.Update.Cooldown(updateCooldown);
        this.Settings.Set.Update.Stack(updateStack);
        this.Settings.Set.Update.Function(updateFunction);
        this.__UpdatingInterval = this.__Init();
    }
    // TODO: JSDoc
    __GetSettingsCopy() {
        const SettingsCopy = GlobalModule.Functions.Parameter.Type.Manager.Default.Object.Copy(this.__Settings);
        return SettingsCopy;
    }
    // TODO: JSDoc
    __UpdateSettings(updateFunction) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(updateFunction, new Validator().Default.Function().Required());
        const OldSettings = this.__GetSettingsCopy();
        updateFunction();
        const NewSettings = this.__GetSettingsCopy();
        this.Event.Emitter.Emit(Queue.Event.Name.Settings.Update, OldSettings, NewSettings);
    }
    // TODO: JSDoc
    __GetElementsCopy() {
        const ElementsCopy = GlobalModule.Functions.Parameter.Type.Manager.Default.Array.Copy(this.__Elements);
        return ElementsCopy;
    }
    // TODO: JSDoc
    __AddNewElements(fromStart, ...newElements) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(fromStart, new Validator().Default.Boolean().Required());
        const OldElements = this.__GetElementsCopy();
        const AddedElements = [];
        for (let i = 0; i < newElements.length; i++) {
            const AddedElementIndex = i;
            const AddedElement = newElements[AddedElementIndex];
            AddedElements.push(AddedElement);
            if (fromStart)
                this.__Elements.unshift(AddedElement);
            else
                this.__Elements.push(AddedElement);
        }
        const NewElements = this.__GetElementsCopy();
        this.Event.Emitter.Emit(Queue.Event.Name.Elements.Add, OldElements, NewElements, AddedElements);
    }
    // TODO: JSDoc
    __RemoveElements(fromStart, length) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(fromStart, new Validator().Default.Boolean().Required());
        const CurrentElements = this.__GetElementsCopy();
        Validator.Strict(length, new Validator().Default.Numeric().Number().Required().Integer().Min(1).Max(CurrentElements.length));
        const OldElements = this.__GetElementsCopy();
        const RemovedElements = [];
        for (let i = 0; i < length; i++) {
            const RemovedElementIndex = fromStart ? i : CurrentElements.length - i - 1;
            const RemovedElement = CurrentElements[RemovedElementIndex];
            RemovedElements.push(RemovedElement);
            if (fromStart)
                this.__Elements.shift();
            else
                this.__Elements.pop();
        }
        const NewElements = this.__GetElementsCopy();
        this.Event.Emitter.Emit(Queue.Event.Name.Elements.Remove, OldElements, NewElements, RemovedElements);
    }
    // TODO: JSDoc
    __ClearElements() {
        GlobalModule.Functions.Parameter.Type.Manager.Default.Array.Clear(this.__Elements);
    }
    // TODO: JSDoc
    __ShuffleElements() {
        const Validator = GlobalModule.Classes.Validator;
        const ElementsCopy = this.__GetElementsCopy();
        const ShuffledElementsCopy = [];
        while (!Validator.TypeGuard.Default.IsEmptyArray(ElementsCopy)) {
            const RandomElementIndex = GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.Random.InList(...ElementsCopy.map((_el, _ind, _arr) => _ind));
            const RandomElement = ElementsCopy[RandomElementIndex];
            ShuffledElementsCopy.push(RandomElement);
            const ElementsBeforeRandomElement = ElementsCopy.slice(0, RandomElementIndex);
            const ElementsAfterRandomElement = ElementsCopy.length > RandomElementIndex + 1 ? ElementsCopy.slice(RandomElementIndex + 1, ElementsCopy.length) : [];
            GlobalModule.Functions.Parameter.Type.Manager.Default.Array.Clear(ElementsCopy);
            ElementsCopy.push(...ElementsBeforeRandomElement, ...ElementsAfterRandomElement);
        }
        this.__ClearElements();
        this.__Elements.push(...ShuffledElementsCopy);
    }
    // TODO: JSDoc
    __IsPaused() {
        const IsQueuePaused = this.__Settings.Pause;
        return IsQueuePaused;
    }
    // TODO: JSDoc
    __Pause() {
        this.__Settings.Pause = true;
        const CurrentElements = this.__GetElementsCopy();
        this.Event.Emitter.Emit(Queue.Event.Name.Updating.Pause, CurrentElements);
    }
    // TODO: JSDoc
    __Resume() {
        this.__Settings.Pause = false;
        const CurrentElements = this.__GetElementsCopy();
        this.Event.Emitter.Emit(Queue.Event.Name.Updating.Resume, CurrentElements);
    }
    // TODO: JSDoc
    __Stop() {
        GlobalModule.Dependencies.Default.Node.timers.clearInterval(this.__UpdatingInterval);
        this.__ClearElements();
        const CurrentElements = this.__GetElementsCopy();
        this.Event.Emitter.Emit(Queue.Event.Name.Updating.Stop, CurrentElements);
    }
    // TODO: JSDoc
    __Init() {
        const Validator = GlobalModule.Classes.Validator;
        let IsUpdatingInProcess = false;
        let LastUpdateTimestamp = 0;
        const UpdateElements = async (...elements) => {
            this.Event.Emitter.Emit(Queue.Event.Name.Elements.Next.Before, ...elements);
            await this.__Settings.Update.Function(...elements);
            this.Event.Emitter.Emit(Queue.Event.Name.Elements.Next.After, ...elements);
        };
        const LastUpdateElements = this.__GetElementsCopy();
        const UpdateQuery = async () => {
            const TempElements = this.__GetElementsCopy();
            const IsQueueBusy = this.__Settings.Pause || IsUpdatingInProcess;
            const IsQueueEmpty = Validator.TypeGuard.Default.IsEmptyArray(TempElements);
            if (!IsQueueBusy) {
                IsUpdatingInProcess = true;
                const UpdateCooldown = this.__Settings.Update.Cooldown;
                const CurrentUpdateCooldown = new Date().getTime() - LastUpdateTimestamp;
                const IsUpdateCooldownEnded = CurrentUpdateCooldown >= UpdateCooldown;
                GlobalModule.Functions.Parameter.Type.Manager.Default.Array.Clear(LastUpdateElements);
                LastUpdateElements.push(...GlobalModule.Functions.Parameter.Type.Manager.Default.Array.Copy(TempElements));
                const IsQueueStarted = Validator.TypeGuard.Default.IsEmptyArray(LastUpdateElements) && !Validator.TypeGuard.Default.IsEmptyArray(this.__GetElementsCopy());
                if (IsQueueStarted) {
                    this.Event.Emitter.Emit(Queue.Event.Name.Updating.Start, GlobalModule.Functions.Parameter.Type.Manager.Default.Array.Copy(TempElements));
                }
                if (!IsQueueEmpty && IsUpdateCooldownEnded) {
                    const UpdateStack = GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.ToRange(this.__Settings.Update.Stack, 1, TempElements.length);
                    const CurrentElements = TempElements.slice(0, UpdateStack);
                    this.__RemoveElements(true, UpdateStack);
                    await UpdateElements(...CurrentElements);
                }
                const IsQueueEnded = !Validator.TypeGuard.Default.IsEmptyArray(LastUpdateElements) && Validator.TypeGuard.Default.IsEmptyArray(this.__GetElementsCopy());
                if (IsQueueEnded) {
                    this.Event.Emitter.Emit(Queue.Event.Name.Updating.End, GlobalModule.Functions.Parameter.Type.Manager.Default.Array.Copy(TempElements));
                }
                LastUpdateTimestamp = new Date().getTime();
                IsUpdatingInProcess = false;
            }
        };
        const Updating = GlobalModule.Dependencies.Default.Node.timers.setInterval(UpdateQuery, 0);
        return Updating;
    }
}
export default Queue;
//# sourceMappingURL=Queue.js.map