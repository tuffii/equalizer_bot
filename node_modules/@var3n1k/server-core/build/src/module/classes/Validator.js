import * as GlobalModule from '../@module.js';
const TypeGuard = GlobalModule.Functions.Parameter.Type.Guard;
const TypeError = GlobalModule.Classes.Error.TypeError;
const BaseError = (_, __) => {
    const BaseErrorSettings = {
        Tag: {
            Text: `ValidationError`,
            Color: GlobalModule.Functions.Parameter.Type.Manager.Custom.Color.HEXToRGB(GlobalModule.DataSet.Constants.Custom.Color.HEX.Default.Red.Default.Light[20]),
        },
        Code: {
            Number: -1,
            Name: {
                Text: `CUSTOM_ERROR`,
                Color: GlobalModule.Functions.Parameter.Type.Manager.Custom.Color.HEXToRGB(GlobalModule.DataSet.Constants.Custom.Color.HEX.Default.Red.Default.Light[20]),
            },
        },
    };
    const NewBaseError = new GlobalModule.Classes.Error.BaseError(BaseErrorSettings.Tag.Text, BaseErrorSettings.Tag.Color, BaseErrorSettings.Code.Number, BaseErrorSettings.Code.Name.Text, BaseErrorSettings.Code.Name.Color, undefined, [
        ...__,
        `.`,
        GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default,
        `Получен параметр типа`,
        GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default,
        `'${typeof _}' (`,
        _,
        `)`,
    ]);
    return NewBaseError;
};
class BaseValidator {
    // TODO: JSDoc
    static TypeGuard = TypeGuard;
    // TODO: JSDoc
    static TypeError = {
        Any: (__) => (_) => BaseError(_, __),
        Default: {
            Any: {
                Invalid: (_) => new TypeError(TypeError.Code.Default.Any.Invalid, _),
                Unexpected: (__) => (_) => new TypeError(TypeError.Code.Default.Any.Unexpected, _, __),
            },
            Symbol: {
                Invalid: (_) => new TypeError(TypeError.Code.Default.Symbol.Invalid, _),
                Unexpected: (__) => (_) => new TypeError(TypeError.Code.Default.Symbol.Unexpected, _, __),
            },
            String: {
                Base: {
                    Invalid: (_) => new TypeError(TypeError.Code.Default.String.Base.Invalid, _),
                    Unexpected: (__) => (_) => new TypeError(TypeError.Code.Default.String.Base.Unexpected, _, __),
                    Expected: {
                        Length: {
                            MoreThan: (__) => (_) => new TypeError(TypeError.Code.Default.String.Base.Expected.Length.MoreThan, _, __),
                            EqualTo: (__) => (_) => new TypeError(TypeError.Code.Default.String.Base.Expected.Length.EqualTo, _, __),
                            LessThan: (__) => (_) => new TypeError(TypeError.Code.Default.String.Base.Expected.Length.LessThan, _, __),
                        },
                    },
                },
            },
            Numeric: {
                Base: {
                    Invalid: (_) => new TypeError(TypeError.Code.Default.Numeric.Base.Invalid, _),
                    Unexpected: (__) => (_) => new TypeError(TypeError.Code.Default.Numeric.Base.Unexpected, _, __),
                    Expected: {
                        Positive: (_) => new TypeError(TypeError.Code.Default.Numeric.Base.Expected.Positive, _),
                        Negative: (_) => new TypeError(TypeError.Code.Default.Numeric.Base.Expected.Negative, _),
                        Value: {
                            MoreThan: (__) => (_) => new TypeError(TypeError.Code.Default.Numeric.Base.Expected.Value.MoreThan, _, __),
                            MoreThanOrEqual: (__) => (_) => new TypeError(TypeError.Code.Default.Numeric.Base.Expected.Value.MoreThanOrEqual, _, __),
                            EqualTo: (__) => (_) => new TypeError(TypeError.Code.Default.Numeric.Base.Expected.Value.EqualTo, _, __),
                            LessThan: (__) => (_) => new TypeError(TypeError.Code.Default.Numeric.Base.Expected.Value.LessThan, _, __),
                            LessThanOrEqual: (__) => (_) => new TypeError(TypeError.Code.Default.Numeric.Base.Expected.Value.LessThanOrEqual, _, __),
                        },
                    },
                },
                BigInt: {
                    Invalid: (_) => new TypeError(TypeError.Code.Default.Numeric.BigInt.Invalid, _),
                    Unexpected: (__) => (_) => new TypeError(TypeError.Code.Default.Numeric.BigInt.Unexpected, _, __),
                },
                Number: {
                    Invalid: (_) => new TypeError(TypeError.Code.Default.Numeric.Number.Invalid, _),
                    Unexpected: (__) => (_) => new TypeError(TypeError.Code.Default.Numeric.Number.Unexpected, _, __),
                },
                Integer: {
                    Invalid: (_) => new TypeError(TypeError.Code.Default.Numeric.Integer.Invalid, _),
                    Unexpected: (__) => (_) => new TypeError(TypeError.Code.Default.Numeric.Integer.Unexpected, _, __),
                },
            },
            Array: {
                Invalid: (_) => new TypeError(TypeError.Code.Default.Array.Invalid, _),
                Unexpected: (__) => (_) => new TypeError(TypeError.Code.Default.Array.Unexpected, _, __),
                Expected: {
                    Length: {
                        MoreThan: (__) => (_) => new TypeError(TypeError.Code.Default.Array.Expected.Length.MoreThan, _, __),
                        EqualTo: (__) => (_) => new TypeError(TypeError.Code.Default.Array.Expected.Length.EqualTo, _, __),
                        LessThan: (__) => (_) => new TypeError(TypeError.Code.Default.Array.Expected.Length.LessThan, _, __),
                    },
                    Depth: {
                        MoreThan: (__) => (_) => new TypeError(TypeError.Code.Default.Array.Expected.Depth.MoreThan, _, __),
                        EqualTo: (__) => (_) => new TypeError(TypeError.Code.Default.Array.Expected.Depth.EqualTo, _, __),
                        LessThan: (__) => (_) => new TypeError(TypeError.Code.Default.Array.Expected.Depth.LessThan, _, __),
                    },
                },
            },
            Object: {
                Invalid: (_) => new TypeError(TypeError.Code.Default.Object.Invalid, _),
                Unexpected: (__) => (_) => new TypeError(TypeError.Code.Default.Object.Unexpected, _, __),
                Expected: {
                    Size: {
                        MoreThan: (__) => (_) => new TypeError(TypeError.Code.Default.Object.Expected.Size.MoreThan, _, __),
                        EqualTo: (__) => (_) => new TypeError(TypeError.Code.Default.Object.Expected.Size.EqualTo, _, __),
                        LessThan: (__) => (_) => new TypeError(TypeError.Code.Default.Object.Expected.Size.LessThan, _, __),
                    },
                    Depth: {
                        MoreThan: (__) => (_) => new TypeError(TypeError.Code.Default.Object.Expected.Depth.MoreThan, _, __),
                        EqualTo: (__) => (_) => new TypeError(TypeError.Code.Default.Object.Expected.Depth.EqualTo, _, __),
                        LessThan: (__) => (_) => new TypeError(TypeError.Code.Default.Object.Expected.Depth.LessThan, _, __),
                    },
                    Keys: {
                        With: (__) => (_) => new TypeError(TypeError.Code.Default.Object.Expected.Keys.With, _, __),
                        Of: (__) => (_) => new TypeError(TypeError.Code.Default.Object.Expected.Keys.Of, _, __),
                    },
                },
            },
            RegExp: {
                Invalid: (_) => new TypeError(TypeError.Code.Default.RegExp.Invalid, _),
                Unexpected: (__) => (_) => new TypeError(TypeError.Code.Default.RegExp.Unexpected, _, __),
                Expected: {
                    Global: (_) => new TypeError(TypeError.Code.Default.RegExp.Expected.Global, _),
                    Multiline: (_) => new TypeError(TypeError.Code.Default.RegExp.Expected.Multiline, _),
                    CaseIgnored: (_) => new TypeError(TypeError.Code.Default.RegExp.Expected.CaseIgnored, _),
                },
            },
            Boolean: {
                Invalid: (_) => new TypeError(TypeError.Code.Default.Boolean.Invalid, _),
                Unexpected: (__) => (_) => new TypeError(TypeError.Code.Default.Boolean.Unexpected, _, __),
            },
            Date: {
                Invalid: (_) => new TypeError(TypeError.Code.Default.Date.Invalid, _),
                Unexpected: (__) => (_) => new TypeError(TypeError.Code.Default.Date.Unexpected, _, __),
                Expected: {
                    NewerThan: (__) => (_) => new TypeError(TypeError.Code.Default.Date.Expected.NewerThan, _, __),
                    NewerThanNow: (_) => new TypeError(TypeError.Code.Default.Date.Expected.NewerThanNow, _),
                    NewerThanOrEqual: (__) => (_) => new TypeError(TypeError.Code.Default.Date.Expected.NewerThanOrEqual, _, __),
                    NewerThanOrEqualNow: (_) => new TypeError(TypeError.Code.Default.Date.Expected.NewerThanOrEqualNow, _),
                    OlderThan: (__) => (_) => new TypeError(TypeError.Code.Default.Date.Expected.OlderThan, _, __),
                    OlderThanNow: (_) => new TypeError(TypeError.Code.Default.Date.Expected.OlderThanNow, _),
                    OlderThanOrEqual: (__) => (_) => new TypeError(TypeError.Code.Default.Date.Expected.OlderThanOrEqual, _, __),
                    OlderThanOrEqualNow: (_) => new TypeError(TypeError.Code.Default.Date.Expected.OlderThanOrEqualNow, _),
                },
            },
            Function: {
                Invalid: (_) => new TypeError(TypeError.Code.Default.Function.Invalid, _),
                Unexpected: (__) => (_) => new TypeError(TypeError.Code.Default.Function.Unexpected, _, __),
            },
            Error: {
                Invalid: (_) => new TypeError(TypeError.Code.Default.Error.Invalid, _),
                Unexpected: (__) => (_) => new TypeError(TypeError.Code.Default.Error.Unexpected, _, __),
            },
            Class: {
                Declaration: {
                    Invalid: (_) => new TypeError(TypeError.Code.Default.Class.Declaration.Invalid, _),
                    Unexpected: (__) => (_) => new TypeError(TypeError.Code.Default.Class.Declaration.Unexpected, _, __),
                },
                Instance: {
                    Invalid: (_) => new TypeError(TypeError.Code.Default.Class.Instance.Invalid, _),
                    Unexpected: (__) => (_) => new TypeError(TypeError.Code.Default.Class.Instance.Unexpected, _, __),
                    Expected: {
                        InstanceOf: (__) => (_) => new TypeError(TypeError.Code.Default.Class.Instance.Expected.InstanceOf, _, __),
                    },
                },
            },
        },
        Custom: {
            Color: {
                HEX: {
                    Invalid: (_) => new TypeError(TypeError.Code.Custom.Color.HEX.Invalid, _),
                    Unexpected: (__) => (_) => new TypeError(TypeError.Code.Custom.Color.HEX.Unexpected, _, __),
                },
                RGB: {
                    Invalid: (_) => new TypeError(TypeError.Code.Custom.Color.RGB.Invalid, _),
                    Unexpected: (__) => (_) => new TypeError(TypeError.Code.Custom.Color.RGB.Unexpected, _, __),
                },
                RGBA: {
                    Invalid: (_) => new TypeError(TypeError.Code.Custom.Color.RGBA.Invalid, _),
                    Unexpected: (__) => (_) => new TypeError(TypeError.Code.Custom.Color.RGBA.Unexpected, _, __),
                },
            },
            FileSystem: {
                Any: {
                    Path: {
                        Invalid: (_) => new TypeError(TypeError.Code.Custom.FileSystem.Any.Path.Invalid, _),
                        Unexpected: (__) => (_) => new TypeError(TypeError.Code.Custom.FileSystem.Any.Path.Unexpected, _, __),
                    },
                    URL: {
                        Invalid: (_) => new TypeError(TypeError.Code.Custom.FileSystem.Any.URL.Invalid, _),
                        Unexpected: (__) => (_) => new TypeError(TypeError.Code.Custom.FileSystem.Any.URL.Unexpected, _, __),
                    },
                },
                File: {
                    Path: {
                        Invalid: (_) => new TypeError(TypeError.Code.Custom.FileSystem.File.Path.Invalid, _),
                        Unexpected: (__) => (_) => new TypeError(TypeError.Code.Custom.FileSystem.File.Path.Unexpected, _, __),
                    },
                    URL: {
                        Invalid: (_) => new TypeError(TypeError.Code.Custom.FileSystem.File.URL.Invalid, _),
                        Unexpected: (__) => (_) => new TypeError(TypeError.Code.Custom.FileSystem.File.URL.Unexpected, _, __),
                    },
                    DoesntExist: (_) => new TypeError(TypeError.Code.Custom.FileSystem.File.DoesntExist, _),
                    Unreachable: (_) => new TypeError(TypeError.Code.Custom.FileSystem.File.Unreachable, _),
                    Unreadable: (_) => new TypeError(TypeError.Code.Custom.FileSystem.File.Unreadable, _),
                    Unwriteable: (_) => new TypeError(TypeError.Code.Custom.FileSystem.File.Unwriteable, _),
                },
                Directory: {
                    Path: {
                        Invalid: (_) => new TypeError(TypeError.Code.Custom.FileSystem.Directory.Path.Invalid, _),
                        Unexpected: (__) => (_) => new TypeError(TypeError.Code.Custom.FileSystem.Directory.Path.Unexpected, _, __),
                    },
                    URL: {
                        Invalid: (_) => new TypeError(TypeError.Code.Custom.FileSystem.Directory.URL.Invalid, _),
                        Unexpected: (__) => (_) => new TypeError(TypeError.Code.Custom.FileSystem.Directory.URL.Unexpected, _, __),
                    },
                    DoesntExist: (_) => new TypeError(TypeError.Code.Custom.FileSystem.Directory.DoesntExist, _),
                },
            },
            URL: {
                Base: {
                    Invalid: (_) => new TypeError(TypeError.Code.Custom.URL.Base.Invalid, _),
                    Unexpected: (__) => (_) => new TypeError(TypeError.Code.Custom.URL.Base.Unexpected, _, __),
                },
            },
        },
    };
    // TODO: JSDoc
    _Validation;
    // TODO: JSDoc
    static GetFunction(validator) {
        const DoesValidatorExist = Validator.TypeGuard.Default.IsInstanceOf(validator, BaseValidator);
        if (!DoesValidatorExist) {
            throw BaseValidator.TypeError.Default.Class.Instance.Expected.InstanceOf(BaseValidator)(validator);
        }
        const AllValidations = [validator._Validation.Function.Main, ...validator._Validation.Function.Alternative];
        const ValidationFunction = (_, __) => {
            const AllValidationResults = AllValidations.map((_el, _ind, _arr) => _el(_, __));
            const PositiveValidationResults = AllValidationResults.filter((_el, _ind, _arr) => _el.Status);
            const DoesPositiveValidationStatusExist = !BaseValidator.TypeGuard.Default.IsEmptyArray(PositiveValidationResults);
            const NegativeValidationResults = AllValidationResults.filter((_el, _ind, _arr) => !_el.Status);
            const DoesNegativeValidationStatusExist = !BaseValidator.TypeGuard.Default.IsEmptyArray(NegativeValidationResults);
            const ActiveValidationError = !DoesPositiveValidationStatusExist && DoesNegativeValidationStatusExist ? NegativeValidationResults[0].Error : undefined;
            const CurrentValidationResult = {
                Status: DoesPositiveValidationStatusExist,
                Error: DoesPositiveValidationStatusExist ? undefined : ActiveValidationError,
            };
            return CurrentValidationResult;
        };
        return ValidationFunction;
    }
    // TODO: JSDoc
    Required() {
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsValueDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const UndefinedValueErrorConstructor = this._Validation.Error;
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = IsValueDefined;
            const DefaultValidation = {
                Function: (___) => !BaseValidator.TypeGuard.Default.IsNullOrUndefined(___),
                Error: UndefinedValueErrorConstructor,
            };
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, DefaultValidation, UndefinedValueErrorConstructor.Type.Invalid);
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    In(valuesList) {
        Validator.Strict(valuesList, new Validator().Default.Array().Required().MinLength(1));
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsValueDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const UndefinedValueErrorConstructor = this._Validation.Error;
            const IsIncludedInValuesList = IsValueDefined && valuesList.includes(_);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsValueDefined || IsIncludedInValuesList;
            const DefaultValidation = {
                Function: (___) => !BaseValidator.TypeGuard.Default.IsNullOrUndefined(___),
                Error: UndefinedValueErrorConstructor,
            };
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, DefaultValidation, UndefinedValueErrorConstructor.Parameter.Unexpected([
                `Ожидалось указание параметра, соответствующего одному из предопределенных значений`,
                GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default,
                `(`,
                valuesList.join(` | `),
                `)`,
            ]));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    Or(validator) {
        Validator.Strict(validator, new Validator().Default.Class.Instance().Required().Of(BaseValidator));
        const NewAlternativeValidations = [validator._Validation.Function.Main, ...validator._Validation.Function.Alternative];
        this._Validation.Function.Alternative.push(...NewAlternativeValidations);
        return this;
    }
    // TODO: JSDoc
    Custom(validationFunction, validationErrorMessageConstructor) {
        Validator.Strict(validationFunction, new Validator().Default.Function().Required());
        Validator.Strict(validationErrorMessageConstructor, new Validator().Default.Function().Required());
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsValueDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const UndefinedValueErrorConstructor = this._Validation.Error;
            const IsValueValid = IsValueDefined && validationFunction(_);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsValueDefined || IsValueValid;
            const DefaultValidation = {
                Function: (___) => !BaseValidator.TypeGuard.Default.IsNullOrUndefined(___),
                Error: UndefinedValueErrorConstructor,
            };
            const CustomErrorConstructor = BaseValidator.TypeError.Any(validationErrorMessageConstructor(_));
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, DefaultValidation, CustomErrorConstructor);
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    constructor(defaultValidationError, mainValidation, alternativeValidations) {
        this._Validation = {
            Function: {
                Main: mainValidation,
                Alternative: alternativeValidations,
            },
            Error: defaultValidationError,
        };
    }
    // TODO: JSDoc
    _FormValidationResult(parameter, formError, status, previousValidation, defaultValidation, errorConstructor) {
        const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(parameter);
        const IsTypeValid = defaultValidation.Function(parameter);
        const IsStrictTypeValid = IsDefined && IsTypeValid;
        const IsCurrentValidationSuccessful = status;
        const IsPreviousValidationSuccessful = previousValidation.Status;
        const PreviousValidationError = previousValidation.Error;
        const IsTotalValidationSuccessful = IsCurrentValidationSuccessful && IsPreviousValidationSuccessful;
        const IsValidationErrorRequired = formError;
        const ValidationResult = {
            Status: IsTotalValidationSuccessful,
            Error: IsValidationErrorRequired
                ? IsTotalValidationSuccessful
                    ? undefined
                    : IsPreviousValidationSuccessful
                        ? IsStrictTypeValid
                            ? errorConstructor(parameter)
                            : defaultValidation.Error.Type.Invalid(parameter)
                        : PreviousValidationError
                : undefined,
        };
        return ValidationResult;
    }
}
class AnyValidator extends BaseValidator {
    // TODO: JSDoc
    static Default = {
        Function: (_) => true,
        Error: {
            Type: {
                Invalid: BaseValidator.TypeError.Default.Any.Invalid,
            },
            Parameter: {
                Unexpected: BaseValidator.TypeError.Default.Any.Unexpected,
            },
        },
    };
    // TODO: JSDoc
    constructor(defaultErrorConstructor, mainValidation, alternativeValidations) {
        super(defaultErrorConstructor, mainValidation, alternativeValidations);
    }
}
class SymbolValidator extends BaseValidator {
    // TODO: JSDoc
    static Default = {
        Function: BaseValidator.TypeGuard.Default.IsSymbol,
        Error: {
            Type: {
                Invalid: BaseValidator.TypeError.Default.Symbol.Invalid,
            },
            Parameter: {
                Unexpected: BaseValidator.TypeError.Default.Symbol.Unexpected,
            },
        },
    };
    // TODO: JSDoc
    constructor(defaultErrorConstructor, mainValidation, alternativeValidations) {
        super(defaultErrorConstructor, mainValidation, alternativeValidations);
    }
}
class StringValidator extends BaseValidator {
    // TODO: JSDoc
    static Default = {
        Function: BaseValidator.TypeGuard.Default.IsString,
        Error: {
            Type: {
                Invalid: BaseValidator.TypeError.Default.String.Base.Invalid,
            },
            Parameter: {
                Unexpected: BaseValidator.TypeError.Default.String.Base.Unexpected,
            },
        },
    };
    // TODO: JSDoc
    constructor(defaultErrorConstructor, mainValidation, alternativeValidations) {
        super(defaultErrorConstructor, mainValidation, alternativeValidations);
    }
    // TODO: JSDoc
    Of(symbols) {
        Validator.Strict(symbols, new Validator().Default.Array().Required().Of(new Validator().Default.String().Required().Length(1)).MinLength(1));
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = StringValidator.Default.Function(_);
            const IsMadeOfSymbols = IsDefined && IsTypeValid && _.split(/[]{0}/).every((_el, _ind, _arr) => symbols.includes(_el));
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsMadeOfSymbols;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, StringValidator.Default, BaseValidator.TypeError.Default.String.Base.Unexpected([
                `Ожидалось указание строкового параметра, состоящего из предопределенных символов`,
                GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default,
                `(`,
                symbols.join(` | `),
                `)`,
            ]));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    StartsWith(symbolCombinations) {
        Validator.Strict(symbolCombinations, new Validator().Default.Array().Required().Of(new Validator().Default.String().Required().MinLength(1)).MinLength(1));
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = StringValidator.Default.Function(_);
            const IsEmpty = IsDefined && BaseValidator.TypeGuard.Default.IsEmptyString(_);
            const IsStartedWithSymbolCombinations = IsDefined && IsTypeValid && symbolCombinations.some((_el, _ind, _arr) => _.startsWith(_el));
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsStartedWithSymbolCombinations || IsEmpty;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, StringValidator.Default, BaseValidator.TypeError.Default.String.Base.Unexpected([
                `Ожидалось указание строкового параметра, начинающегося с одной из предопределенных комбинаций символов`,
                GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default,
                `(`,
                symbolCombinations.join(` | `),
                `)`,
            ]));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    EndsWith(symbolCombinations) {
        Validator.Strict(symbolCombinations, new Validator().Default.Array().Required().Of(new Validator().Default.String().Required().MinLength(1)).MinLength(1));
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = StringValidator.Default.Function(_);
            const IsEmpty = IsDefined && BaseValidator.TypeGuard.Default.IsEmptyString(_);
            const IsEndedWithSymbolCombinations = IsDefined && IsTypeValid && symbolCombinations.some((_el, _ind, _arr) => _.endsWith(_el));
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsEndedWithSymbolCombinations || IsEmpty;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, StringValidator.Default, BaseValidator.TypeError.Default.String.Base.Unexpected([
                `Ожидалось указание строкового параметра, заканчивающегося одной из предопределенных комбинаций символов`,
                GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default,
                `(`,
                symbolCombinations.join(` | `),
                `)`,
            ]));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    Matches(patterns) {
        Validator.Strict(patterns, new Validator().Default.Array().Required().Of(new Validator().Default.RegExp().Required()).MinLength(1));
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = StringValidator.Default.Function(_);
            const IsEmpty = IsDefined && BaseValidator.TypeGuard.Default.IsEmptyString(_);
            const IsMatchedWithPattern = IsDefined && IsTypeValid && patterns.some((_el, _ind, _arr) => _el.test(_));
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsMatchedWithPattern || IsEmpty;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, StringValidator.Default, BaseValidator.TypeError.Default.String.Base.Unexpected([
                `Ожидалось указание строкового параметра, соответствующего одному из регулярных выражений`,
                GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default,
                `(`,
                patterns.join(` | `),
                `)`,
            ]));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    Length(length) {
        Validator.Strict(length, new Validator().Default.Numeric().Number().Required().Integer().Min(0));
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = StringValidator.Default.Function(_);
            const CurrentLength = IsDefined && IsTypeValid ? _.length : 0;
            const IsEqualToExpectedLength = IsDefined && IsTypeValid && CurrentLength === length;
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsEqualToExpectedLength;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, StringValidator.Default, BaseValidator.TypeError.Default.String.Base.Expected.Length.EqualTo(length));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    MinLength(length) {
        Validator.Strict(length, new Validator().Default.Numeric().Number().Required().Integer().Min(0));
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = StringValidator.Default.Function(_);
            const CurrentLength = IsDefined && IsTypeValid ? _.length : 0;
            const IsMoreThanMinimumLength = IsDefined && IsTypeValid && CurrentLength === GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.ToRange(CurrentLength, length, undefined);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsMoreThanMinimumLength;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, StringValidator.Default, BaseValidator.TypeError.Default.String.Base.Expected.Length.MoreThan(length));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    MaxLength(length) {
        Validator.Strict(length, new Validator().Default.Numeric().Number().Required().Integer().Min(0));
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = StringValidator.Default.Function(_);
            const CurrentLength = IsDefined && IsTypeValid ? _.length : 0;
            const IsLessThanMaximumLength = IsDefined && IsTypeValid && CurrentLength === GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.ToRange(CurrentLength, undefined, length);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsLessThanMaximumLength;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, StringValidator.Default, BaseValidator.TypeError.Default.String.Base.Expected.Length.LessThan(length));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    Spaces(length) {
        Validator.Strict(length, new Validator().Default.Numeric().Number().Required().Integer().Min(0));
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = StringValidator.Default.Function(_);
            const CurrentSpacesLength = IsDefined && IsTypeValid ? _.split(/[\s]/).length - 1 : 0;
            const IsEqualToExpectedSpacesLength = IsDefined && IsTypeValid && CurrentSpacesLength === length;
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsEqualToExpectedSpacesLength;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, StringValidator.Default, BaseValidator.TypeError.Default.String.Base.Unexpected([
                `Ожидалось указание строкового параметра, содержащего в себе`,
                GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default,
                GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.ToNamed(length, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default, [undefined, `пробельных знаков`], [undefined, `пробельный знак`], [undefined, `пробельных знака`]),
            ]));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    MinSpaces(length) {
        Validator.Strict(length, new Validator().Default.Numeric().Number().Required().Integer().Min(0));
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = StringValidator.Default.Function(_);
            const CurrentSpacesLength = IsDefined && IsTypeValid ? _.split(/[\s]/).length - 1 : 0;
            const IsMoreThanMinimumSpacesLength = IsDefined && IsTypeValid && CurrentSpacesLength === GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.ToRange(CurrentSpacesLength, length, undefined);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsMoreThanMinimumSpacesLength;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, StringValidator.Default, BaseValidator.TypeError.Default.String.Base.Unexpected([
                `Ожидалось указание строкового параметра, содержащего в себе минимум`,
                GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default,
                GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.ToNamed(length, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default, [undefined, `пробельных знаков`], [undefined, `пробельный знак`], [undefined, `пробельных знака`]),
            ]));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    MaxSpaces(length) {
        Validator.Strict(length, new Validator().Default.Numeric().Number().Required().Integer().Min(0));
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = StringValidator.Default.Function(_);
            const CurrentSpacesLength = IsDefined && IsTypeValid ? _.split(/[\s]/).length - 1 : 0;
            const IsLessThanMaximumSpacesLength = IsDefined && IsTypeValid && CurrentSpacesLength === GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.ToRange(CurrentSpacesLength, undefined, length);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsLessThanMaximumSpacesLength;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, StringValidator.Default, BaseValidator.TypeError.Default.String.Base.Unexpected([
                `Ожидалось указание строкового параметра, содержащего в себе максимум`,
                GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default,
                GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.ToNamed(length, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default, [undefined, `пробельных знаков`], [undefined, `пробельный знак`], [undefined, `пробельных знака`]),
            ]));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    Rows(length) {
        Validator.Strict(length, new Validator().Default.Numeric().Number().Required().Integer().Min(1));
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = StringValidator.Default.Function(_);
            const CurrentRowsLength = IsDefined && IsTypeValid ? _.split(/[\n]/).length : 0;
            const IsEqualToExpectedRowsLength = IsDefined && IsTypeValid && CurrentRowsLength === length;
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsEqualToExpectedRowsLength;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, StringValidator.Default, BaseValidator.TypeError.Default.String.Base.Unexpected([
                `Ожидалось указание строкового параметра, содержащего в себе`,
                GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default,
                GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.ToNamed(length - 1, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default, [undefined, `переносов строки`], [undefined, `перенос строки`], [undefined, `переноса строки`]),
                GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default,
                `(\\n)`,
            ]));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    MinRows(length) {
        Validator.Strict(length, new Validator().Default.Numeric().Number().Required().Integer().Min(1));
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = StringValidator.Default.Function(_);
            const CurrentRowsLength = IsDefined && IsTypeValid ? _.split(/[\n]/).length : 0;
            const IsMoreThanMinimumRowsLength = IsDefined && IsTypeValid && CurrentRowsLength === GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.ToRange(CurrentRowsLength, length, undefined);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsMoreThanMinimumRowsLength;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, StringValidator.Default, BaseValidator.TypeError.Default.String.Base.Unexpected([
                `Ожидалось указание строкового параметра, содержащего в себе минимум`,
                GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default,
                GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.ToNamed(length - 1, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default, [undefined, `переносов строки`], [undefined, `перенос строки`], [undefined, `переноса строки`]),
                GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default,
                `(\\n)`,
            ]));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    MaxRows(length) {
        Validator.Strict(length, new Validator().Default.Numeric().Number().Required().Integer().Min(1));
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = StringValidator.Default.Function(_);
            const CurrentRowsLength = IsDefined && IsTypeValid ? _.split(/[\n]/).length : 0;
            const IsLessThanMaximumRowsLength = IsDefined && IsTypeValid && CurrentRowsLength === GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.ToRange(CurrentRowsLength, undefined, length);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsLessThanMaximumRowsLength;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, StringValidator.Default, BaseValidator.TypeError.Default.String.Base.Unexpected([
                `Ожидалось указание строкового параметра, содержащего в себе максимум`,
                GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default,
                GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.ToNamed(length - 1, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default, [undefined, `переносов строки`], [undefined, `перенос строки`], [undefined, `переноса строки`]),
                GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default,
                `(\\n)`,
            ]));
            return ValidationResult;
        };
        return this;
    }
}
class NumericValidator extends BaseValidator {
    // TODO: JSDoc
    static Default = {
        Function: BaseValidator.TypeGuard.Default.IsNumeric,
        Error: {
            Type: {
                Invalid: BaseValidator.TypeError.Default.Numeric.Base.Invalid,
            },
            Parameter: {
                Unexpected: BaseValidator.TypeError.Default.Numeric.Base.Unexpected,
            },
        },
    };
    // TODO: JSDoc
    constructor(defaultErrorConstructor, mainValidation, alternativeValidations) {
        super(defaultErrorConstructor, mainValidation, alternativeValidations);
    }
    // TODO: JSDoc
    BigInt() {
        const PreviousValidationFunction = this._Validation.Function.Main;
        const NewValidationFunction = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = BigIntValidator.Default.Function(_);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsTypeValid;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, BigIntValidator.Default, BigIntValidator.Default.Error.Type.Invalid);
            return ValidationResult;
        };
        const NewValidator = new BigIntValidator(BigIntValidator.Default.Error, NewValidationFunction, this._Validation.Function.Alternative);
        return NewValidator;
    }
    // TODO: JSDoc
    Number() {
        const PreviousValidationFunction = this._Validation.Function.Main;
        const NewValidationFunction = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = NumberValidator.Default.Function(_);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsTypeValid;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, NumberValidator.Default, NumberValidator.Default.Error.Type.Invalid);
            return ValidationResult;
        };
        const NewValidator = new NumberValidator(NumberValidator.Default.Error, NewValidationFunction, this._Validation.Function.Alternative);
        return NewValidator;
    }
}
class BigIntValidator extends BaseValidator {
    // TODO: JSDoc
    static Default = {
        Function: BaseValidator.TypeGuard.Default.IsBigInt,
        Error: {
            Type: {
                Invalid: BaseValidator.TypeError.Default.Numeric.BigInt.Invalid,
            },
            Parameter: {
                Unexpected: BaseValidator.TypeError.Default.Numeric.BigInt.Unexpected,
            },
        },
    };
    // TODO: JSDoc
    constructor(defaultErrorConstructor, mainValidation, alternativeValidations) {
        super(defaultErrorConstructor, mainValidation, alternativeValidations);
    }
    // TODO: JSDoc
    Positive() {
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = BigIntValidator.Default.Function(_);
            const IsPositive = IsDefined && IsTypeValid && _ > BigInt(0);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsPositive;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, BigIntValidator.Default, BaseValidator.TypeError.Default.Numeric.Base.Expected.Positive);
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    Negative() {
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = BigIntValidator.Default.Function(_);
            const IsNegative = IsDefined && IsTypeValid && _ < BigInt(0);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsNegative;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, BigIntValidator.Default, BaseValidator.TypeError.Default.Numeric.Base.Expected.Negative);
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    EqualTo(number) {
        Validator.Strict(number, new Validator().Default.Numeric().BigInt().Required());
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = BigIntValidator.Default.Function(_);
            const IsEqualTo = IsDefined && IsTypeValid && _ === number;
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsEqualTo;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, BigIntValidator.Default, BaseValidator.TypeError.Default.Numeric.Base.Expected.Value.EqualTo(number));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    Min(number) {
        Validator.Strict(number, new Validator().Default.Numeric().BigInt().Required());
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = BigIntValidator.Default.Function(_);
            const IsMoreThanOrEqualMin = IsDefined && IsTypeValid && _ === GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.ToRange(_, number, undefined);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsMoreThanOrEqualMin;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, BigIntValidator.Default, BaseValidator.TypeError.Default.Numeric.Base.Expected.Value.MoreThanOrEqual(number));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    MoreThan(number) {
        Validator.Strict(number, new Validator().Default.Numeric().BigInt().Required());
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = BigIntValidator.Default.Function(_);
            const IsMoreThanMin = IsDefined && IsTypeValid && _ > number;
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsMoreThanMin;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, BigIntValidator.Default, BaseValidator.TypeError.Default.Numeric.Base.Expected.Value.MoreThan(number));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    Max(number) {
        Validator.Strict(number, new Validator().Default.Numeric().BigInt().Required());
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = BigIntValidator.Default.Function(_);
            const IsLessThanOrEqualMax = IsDefined && IsTypeValid && _ === GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.ToRange(_, undefined, number);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsLessThanOrEqualMax;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, BigIntValidator.Default, BaseValidator.TypeError.Default.Numeric.Base.Expected.Value.LessThanOrEqual(number));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    LessThan(number) {
        Validator.Strict(number, new Validator().Default.Numeric().BigInt().Required());
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = BigIntValidator.Default.Function(_);
            const IsLessThanMax = IsDefined && IsTypeValid && _ < number;
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsLessThanMax;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, BigIntValidator.Default, BaseValidator.TypeError.Default.Numeric.Base.Expected.Value.LessThan(number));
            return ValidationResult;
        };
        return this;
    }
}
class NumberValidator extends BaseValidator {
    // TODO: JSDoc
    static Default = {
        Function: BaseValidator.TypeGuard.Default.IsNumber,
        Error: {
            Type: {
                Invalid: BaseValidator.TypeError.Default.Numeric.Number.Invalid,
            },
            Parameter: {
                Unexpected: BaseValidator.TypeError.Default.Numeric.Number.Unexpected,
            },
        },
    };
    // TODO: JSDoc
    constructor(defaultErrorConstructor, mainValidation, alternativeValidations) {
        super(defaultErrorConstructor, mainValidation, alternativeValidations);
    }
    // TODO: JSDoc
    Integer() {
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = NumberValidator.Default.Function(_);
            const IsInteger = IsDefined && IsTypeValid && BaseValidator.TypeGuard.Default.IsInteger(_);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsInteger;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, NumberValidator.Default, BaseValidator.TypeError.Default.Numeric.Integer.Invalid);
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    Positive() {
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = NumberValidator.Default.Function(_);
            const IsPositive = IsDefined && IsTypeValid && _ > 0;
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsPositive;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, NumberValidator.Default, BaseValidator.TypeError.Default.Numeric.Base.Expected.Positive);
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    Negative() {
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = NumberValidator.Default.Function(_);
            const IsNegative = IsDefined && IsTypeValid && _ < 0;
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsNegative;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, NumberValidator.Default, BaseValidator.TypeError.Default.Numeric.Base.Expected.Negative);
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    EqualTo(number) {
        Validator.Strict(number, new Validator().Default.Numeric().Number().Required());
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = NumberValidator.Default.Function(_);
            const IsEqualTo = IsDefined && IsTypeValid && _ === number;
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsEqualTo;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, NumberValidator.Default, BaseValidator.TypeError.Default.Numeric.Base.Expected.Value.EqualTo(number));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    Min(number) {
        Validator.Strict(number, new Validator().Default.Numeric().Number().Required());
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = NumberValidator.Default.Function(_);
            const IsMoreThanOrEqualMin = IsDefined && IsTypeValid && _ === GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.ToRange(_, number, undefined);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsMoreThanOrEqualMin;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, NumberValidator.Default, BaseValidator.TypeError.Default.Numeric.Base.Expected.Value.MoreThanOrEqual(number));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    MoreThan(number) {
        Validator.Strict(number, new Validator().Default.Numeric().Number().Required());
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = NumberValidator.Default.Function(_);
            const IsMoreThanMin = IsDefined && IsTypeValid && _ > number;
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsMoreThanMin;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, NumberValidator.Default, BaseValidator.TypeError.Default.Numeric.Base.Expected.Value.MoreThan(number));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    Max(number) {
        Validator.Strict(number, new Validator().Default.Numeric().Number().Required());
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = NumberValidator.Default.Function(_);
            const IsLessThanOrEqualMax = IsDefined && IsTypeValid && _ === GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.ToRange(_, undefined, number);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsLessThanOrEqualMax;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, NumberValidator.Default, BaseValidator.TypeError.Default.Numeric.Base.Expected.Value.LessThanOrEqual(number));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    LessThan(number) {
        Validator.Strict(number, new Validator().Default.Numeric().Number().Required());
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = NumberValidator.Default.Function(_);
            const IsLessThanMax = IsDefined && IsTypeValid && _ < number;
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsLessThanMax;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, NumberValidator.Default, BaseValidator.TypeError.Default.Numeric.Base.Expected.Value.LessThan(number));
            return ValidationResult;
        };
        return this;
    }
}
class ArrayValidator extends BaseValidator {
    // TODO: JSDoc
    static Default = {
        Function: BaseValidator.TypeGuard.Default.IsArray,
        Error: {
            Type: {
                Invalid: BaseValidator.TypeError.Default.Array.Invalid,
            },
            Parameter: {
                Unexpected: BaseValidator.TypeError.Default.Array.Unexpected,
            },
        },
    };
    // TODO: JSDoc
    constructor(defaultErrorConstructor, mainValidation, alternativeValidations) {
        super(defaultErrorConstructor, mainValidation, alternativeValidations);
    }
    // TODO: JSDoc
    Length(length) {
        Validator.Strict(length, new Validator().Default.Numeric().Number().Required().Integer().Min(0));
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = ArrayValidator.Default.Function(_);
            const CurrentLength = IsDefined && IsTypeValid ? _.length : 0;
            const IsEqualToExpectedLength = IsDefined && IsTypeValid && CurrentLength === length;
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsEqualToExpectedLength;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, ArrayValidator.Default, BaseValidator.TypeError.Default.Array.Expected.Length.EqualTo(length));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    MinLength(length) {
        Validator.Strict(length, new Validator().Default.Numeric().Number().Required().Integer().Min(0));
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = ArrayValidator.Default.Function(_);
            const CurrentLength = IsDefined && IsTypeValid ? _.length : 0;
            const IsMoreThanMinimumLength = IsDefined && IsTypeValid && CurrentLength === GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.ToRange(CurrentLength, length, undefined);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsMoreThanMinimumLength;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, ArrayValidator.Default, BaseValidator.TypeError.Default.Array.Expected.Length.MoreThan(length - 1));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    MaxLength(length) {
        Validator.Strict(length, new Validator().Default.Numeric().Number().Required().Integer().Min(0));
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = ArrayValidator.Default.Function(_);
            const CurrentLength = IsDefined && IsTypeValid ? _.length : 0;
            const IsLessThanMaximumLength = IsDefined && IsTypeValid && CurrentLength === GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.ToRange(CurrentLength, undefined, length);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsLessThanMaximumLength;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, ArrayValidator.Default, BaseValidator.TypeError.Default.Array.Expected.Length.LessThan(length + 1));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    Depth(depth) {
        Validator.Strict(depth, new Validator().Default.Numeric().Number().Required().Integer().Min(1));
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = ArrayValidator.Default.Function(_);
            const CurrentDepth = IsDefined && IsTypeValid ? GlobalModule.Functions.Parameter.Type.Manager.Default.Array.GetDepth(_) : 0;
            const IsEqualToExpectedDepth = IsDefined && IsTypeValid && CurrentDepth === depth;
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsEqualToExpectedDepth;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, ArrayValidator.Default, BaseValidator.TypeError.Default.Array.Expected.Depth.EqualTo(depth));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    MinDepth(depth) {
        Validator.Strict(depth, new Validator().Default.Numeric().Number().Required().Integer().Min(1));
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = ArrayValidator.Default.Function(_);
            const CurrentDepth = IsDefined && IsTypeValid ? GlobalModule.Functions.Parameter.Type.Manager.Default.Array.GetDepth(_) : 0;
            const IsMoreThanMinimumDepth = IsDefined && IsTypeValid && CurrentDepth === GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.ToRange(CurrentDepth, depth, undefined);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsMoreThanMinimumDepth;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, ArrayValidator.Default, BaseValidator.TypeError.Default.Array.Expected.Depth.MoreThan(depth));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    MaxDepth(depth) {
        Validator.Strict(depth, new Validator().Default.Numeric().Number().Required().Integer().Min(1));
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = ArrayValidator.Default.Function(_);
            const CurrentDepth = IsDefined && IsTypeValid ? GlobalModule.Functions.Parameter.Type.Manager.Default.Array.GetDepth(_) : 0;
            const IsLessThanMaximumDepth = IsDefined && IsTypeValid && CurrentDepth === GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.ToRange(CurrentDepth, undefined, depth);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsLessThanMaximumDepth;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, ArrayValidator.Default, BaseValidator.TypeError.Default.Array.Expected.Depth.LessThan(depth - 1));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    With(element) {
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = ArrayValidator.Default.Function(_);
            const IsElementIncluded = IsDefined && IsTypeValid && _.includes(element);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsElementIncluded;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, ArrayValidator.Default, BaseValidator.TypeError.Default.Array.Unexpected([
                `Ожидалось указание массива, содержащего как минимум один предопределенный элемент`,
                GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default,
                `(`,
                _,
                `)`,
            ]));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    Of(validator) {
        Validator.Strict(validator, new Validator().Default.Class.Instance().Required().Of(BaseValidator));
        const SingleElementValidation = BaseValidator.GetFunction(validator);
        const AllElementsValidation = (initialElements) => {
            const NativeElements = initialElements.map((_el, _ind, _arr) => {
                const MappedElement = {
                    Index: _ind,
                    Value: _el,
                };
                return MappedElement;
            });
            const InvalidElements = [...NativeElements]
                .map((_el, _ind, _arr) => {
                const ElementValue = _el.Value;
                const ElementValidationResult = SingleElementValidation(ElementValue, false);
                const ExtendedMappedElement = {
                    Index: _el.Index,
                    Value: _el.Value,
                    Result: ElementValidationResult,
                };
                return ExtendedMappedElement;
            })
                .filter((_el, _ind, _arr) => {
                const IsElementValidationSuccesful = _el.Result.Status;
                return !IsElementValidationSuccesful;
            });
            return InvalidElements;
        };
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = ArrayValidator.Default.Function(_);
            const InitialElements = (IsDefined && IsTypeValid ? _ : []);
            const InvalidElements = AllElementsValidation(InitialElements);
            const IsEveryElementValid = IsDefined && IsTypeValid && BaseValidator.TypeGuard.Default.IsEmptyArray(InvalidElements);
            const DoesInvalidElementExist = IsDefined && IsTypeValid && !IsEveryElementValid;
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsEveryElementValid;
            const VariativeValidationError = (___) => {
                if (DoesInvalidElementExist) {
                    const InvalidElement = InvalidElements[0];
                    const InvalidElementValue = InvalidElement.Value;
                    const InvalidElementValidationResult = SingleElementValidation(InvalidElementValue, true);
                    const InvalidElementError = InvalidElementValidationResult.Error;
                    const DoesInvalidElementErrorExist = ErrorValidator.Default.Function(InvalidElementError);
                    if (DoesInvalidElementErrorExist) {
                        const IsInvalidElementErrorCustom = BaseValidator.TypeGuard.Default.IsInstanceOf(InvalidElementError, GlobalModule.Classes.Error.BaseError);
                        const InvalidElementErrorMessage = IsInvalidElementErrorCustom ? InvalidElementError.Message : [InvalidElementError.message];
                        const NewValidationError = BaseValidator.TypeError.Default.Array.Unexpected([
                            `Элемент [`,
                            InvalidElement.Index,
                            `] указанного массива является некорректным.`,
                            GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default,
                            ...InvalidElementErrorMessage,
                        ])(___);
                        return NewValidationError;
                    }
                    else {
                        const NewValidationError = ArrayValidator.Default.Error.Type.Invalid(___);
                        return NewValidationError;
                    }
                }
                else {
                    const NewValidationError = ArrayValidator.Default.Error.Type.Invalid(___);
                    return NewValidationError;
                }
            };
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, ArrayValidator.Default, VariativeValidationError);
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    Exact(...validators) {
        Validator.Strict(validators, new Validator().Default.Array().Required().Of(new Validator().Default.Class.Instance().Required().Of(BaseValidator)));
        const SingleElementValidation = (initialArray, validationArray, value, validator, formError) => {
            const IsValidationDefined = BaseValidator.TypeGuard.Default.IsInstanceOf(validator, BaseValidator);
            if (IsValidationDefined) {
                const ValidationResult = BaseValidator.GetFunction(validator)(value, formError);
                return ValidationResult;
            }
            else {
                const ValidationResult = {
                    Status: IsValidationDefined,
                    Error: BaseValidator.TypeError.Default.Array.Expected.Length.EqualTo(validationArray.length)(initialArray),
                };
                return ValidationResult;
            }
        };
        const AllElementsValidation = (initialArray, validationArray) => {
            const NativeElements = initialArray.map((_el, _ind, _arr) => {
                const MappedElement = {
                    Index: _ind,
                    Value: _el,
                };
                return MappedElement;
            });
            const OtherExpectedElements = validationArray
                .map((_el, _ind, _arr) => {
                const MappedElement = {
                    Index: _ind,
                    Value: initialArray[_ind],
                };
                return MappedElement;
            })
                .filter((_el, _ind, _arr) => !NativeElements.map((__el, __ind, __arr) => __el.Index).includes(_el.Index));
            const InvalidElements = [...NativeElements, ...OtherExpectedElements]
                .map((_el, _ind, _arr) => {
                const ElementValue = _el.Value;
                const ElementValidator = validationArray[_el.Index];
                const ElementValidationResult = SingleElementValidation(initialArray, validationArray, ElementValue, ElementValidator, false);
                const ExtendedMappedElement = {
                    Index: _el.Index,
                    Value: _el.Value,
                    Result: ElementValidationResult,
                };
                return ExtendedMappedElement;
            })
                .filter((_el, _ind, _arr) => {
                const IsElementValidationSuccesful = _el.Result.Status;
                return !IsElementValidationSuccesful;
            });
            return InvalidElements;
        };
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = ArrayValidator.Default.Function(_);
            const InitialElements = (IsDefined && IsTypeValid ? _ : []);
            const InvalidElements = AllElementsValidation(InitialElements, validators);
            const IsEveryElementValid = IsDefined && IsTypeValid && BaseValidator.TypeGuard.Default.IsEmptyArray(InvalidElements);
            const DoesInvalidElementExist = IsDefined && IsTypeValid && !IsEveryElementValid;
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsEveryElementValid;
            const VariativeValidationError = (___) => {
                if (DoesInvalidElementExist) {
                    const InvalidElement = InvalidElements[0];
                    const InvalidElementValue = InvalidElement.Value;
                    const InvalidElementValidator = validators[InvalidElement.Index];
                    const InvalidElementValidationResult = SingleElementValidation(InitialElements, validators, InvalidElementValue, InvalidElementValidator, true);
                    const InvalidElementError = InvalidElementValidationResult.Error;
                    const DoesInvalidElementErrorExist = ErrorValidator.Default.Function(InvalidElementError);
                    if (DoesInvalidElementErrorExist) {
                        const IsInvalidElementErrorCustom = BaseValidator.TypeGuard.Default.IsInstanceOf(InvalidElementError, GlobalModule.Classes.Error.BaseError);
                        const InvalidElementErrorMessage = IsInvalidElementErrorCustom ? InvalidElementError.Message : [InvalidElementError.message];
                        const NewValidationError = BaseValidator.TypeError.Default.Array.Unexpected([
                            `Элемент [`,
                            InvalidElement.Index,
                            `] указанного массива является некорректным.`,
                            GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default,
                            ...InvalidElementErrorMessage,
                        ])(___);
                        return NewValidationError;
                    }
                    else {
                        const NewValidationError = ArrayValidator.Default.Error.Type.Invalid(___);
                        return NewValidationError;
                    }
                }
                else {
                    const NewValidationError = ArrayValidator.Default.Error.Type.Invalid(___);
                    return NewValidationError;
                }
            };
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, ArrayValidator.Default, VariativeValidationError);
            return ValidationResult;
        };
        return this;
    }
}
class ObjectValidator extends BaseValidator {
    // TODO: JSDoc
    static Default = {
        Function: BaseValidator.TypeGuard.Default.IsObject,
        Error: {
            Type: {
                Invalid: BaseValidator.TypeError.Default.Object.Invalid,
            },
            Parameter: {
                Unexpected: BaseValidator.TypeError.Default.Object.Unexpected,
            },
        },
    };
    // TODO: JSDoc
    constructor(defaultErrorConstructor, mainValidation, alternativeValidations) {
        super(defaultErrorConstructor, mainValidation, alternativeValidations);
    }
    // TODO: JSDoc
    Size(size) {
        Validator.Strict(size, new Validator().Default.Numeric().Number().Required().Integer().Min(0));
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = ObjectValidator.Default.Function(_);
            const CurrentSize = IsDefined && IsTypeValid ? GlobalModule.Functions.Parameter.Type.Manager.Default.Object.GetProperties(_).length : 0;
            const IsEqualToExpectedSize = IsDefined && IsTypeValid && CurrentSize === size;
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsEqualToExpectedSize;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, ObjectValidator.Default, BaseValidator.TypeError.Default.Object.Expected.Size.EqualTo(size));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    MinSize(size) {
        Validator.Strict(size, new Validator().Default.Numeric().Number().Required().Integer().Min(0));
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = ObjectValidator.Default.Function(_);
            const CurrentSize = IsDefined && IsTypeValid ? GlobalModule.Functions.Parameter.Type.Manager.Default.Object.GetProperties(_).length : 0;
            const IsMoreThanMinimumSize = IsDefined && IsTypeValid && CurrentSize === GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.ToRange(CurrentSize, size, undefined);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsMoreThanMinimumSize;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, ObjectValidator.Default, BaseValidator.TypeError.Default.Object.Expected.Size.MoreThan(size - 1));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    MaxSize(size) {
        Validator.Strict(size, new Validator().Default.Numeric().Number().Required().Integer().Min(0));
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = ObjectValidator.Default.Function(_);
            const CurrentSize = IsDefined && IsTypeValid ? GlobalModule.Functions.Parameter.Type.Manager.Default.Object.GetProperties(_).length : 0;
            const IsLessThanMaximumSize = IsDefined && IsTypeValid && CurrentSize === GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.ToRange(CurrentSize, undefined, size);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsLessThanMaximumSize;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, ObjectValidator.Default, BaseValidator.TypeError.Default.Object.Expected.Size.LessThan(size + 1));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    Depth(depth) {
        Validator.Strict(depth, new Validator().Default.Numeric().Number().Required().Integer().Min(1));
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = ObjectValidator.Default.Function(_);
            const CurrentDepth = IsDefined && IsTypeValid ? GlobalModule.Functions.Parameter.Type.Manager.Default.Object.GetDepth(_) : 0;
            const IsEqualToExpectedDepth = IsDefined && IsTypeValid && CurrentDepth === depth;
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsEqualToExpectedDepth;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, ObjectValidator.Default, BaseValidator.TypeError.Default.Object.Expected.Depth.EqualTo(depth));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    MinDepth(depth) {
        Validator.Strict(depth, new Validator().Default.Numeric().Number().Required().Integer().Min(1));
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = ObjectValidator.Default.Function(_);
            const CurrentDepth = IsDefined && IsTypeValid ? GlobalModule.Functions.Parameter.Type.Manager.Default.Object.GetDepth(_) : 0;
            const IsMoreThanMinimumDepth = IsDefined && IsTypeValid && CurrentDepth === GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.ToRange(CurrentDepth, depth, undefined);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsMoreThanMinimumDepth;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, ObjectValidator.Default, BaseValidator.TypeError.Default.Object.Expected.Depth.MoreThan(depth));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    MaxDepth(depth) {
        Validator.Strict(depth, new Validator().Default.Numeric().Number().Required().Integer().Min(1));
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = ObjectValidator.Default.Function(_);
            const CurrentDepth = IsDefined && IsTypeValid ? GlobalModule.Functions.Parameter.Type.Manager.Default.Object.GetDepth(_) : 0;
            const IsLessThanMaximumDepth = IsDefined && IsTypeValid && CurrentDepth === GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.ToRange(CurrentDepth, undefined, depth);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsLessThanMaximumDepth;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, ObjectValidator.Default, BaseValidator.TypeError.Default.Object.Expected.Depth.LessThan(depth));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    WithKeys(keys) {
        Validator.Strict(keys, new Validator().Default.Array()
            .Required()
            .Of(new Validator().Default.Symbol().Required().Or(new Validator().Default.String().Required()).Or(new Validator().Default.Numeric().Number().Required())));
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = ObjectValidator.Default.Function(_);
            const IsMadeWithKeys = IsDefined && IsTypeValid && BaseValidator.TypeGuard.Default.IsObjectWithProperties(_, keys);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsMadeWithKeys;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, ObjectValidator.Default, BaseValidator.TypeError.Default.Object.Expected.Keys.With(keys));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    OfKeys(keys) {
        Validator.Strict(keys, new Validator().Default.Array()
            .Required()
            .Of(new Validator().Default.Symbol().Required().Or(new Validator().Default.String().Required()).Or(new Validator().Default.Numeric().Number().Required())));
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = ObjectValidator.Default.Function(_);
            const IsMadeOfKeys = IsDefined && IsTypeValid && BaseValidator.TypeGuard.Default.IsObjectOfProperties(_, keys);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsMadeOfKeys;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, ObjectValidator.Default, BaseValidator.TypeError.Default.Object.Expected.Keys.Of(keys));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    Of(validator) {
        Validator.Strict(validator, new Validator().Default.Class.Instance().Required().Of(BaseValidator));
        const SingleElementValidation = (value, formError) => {
            const ValidationResult = BaseValidator.GetFunction(validator)(value, formError);
            return ValidationResult;
        };
        const AllElementsValidation = (initialObject) => {
            const NativeKeys = GlobalModule.Functions.Parameter.Type.Manager.Default.Object.GetProperties(initialObject);
            const NativeElements = NativeKeys.map((_el, _ind, _arr) => {
                const MappedElement = {
                    Name: _el,
                    Value: initialObject[_el],
                };
                return MappedElement;
            });
            const InvalidElements = [...NativeElements]
                .map((_el, _ind, _arr) => {
                const ElementValue = _el.Value;
                const ElementValidationResult = SingleElementValidation(ElementValue, false);
                const ExtendedMappedElement = {
                    Name: _el.Name,
                    Value: _el.Value,
                    Result: ElementValidationResult,
                };
                return ExtendedMappedElement;
            })
                .filter((_el, _ind, _arr) => {
                const IsElementValidationSuccesful = _el.Result.Status;
                return !IsElementValidationSuccesful;
            });
            return InvalidElements;
        };
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = ObjectValidator.Default.Function(_);
            const InitialElement = IsDefined && IsTypeValid ? _ : {};
            const InvalidElements = AllElementsValidation(InitialElement);
            const IsEveryElementValid = IsDefined && IsTypeValid && BaseValidator.TypeGuard.Default.IsEmptyArray(InvalidElements);
            const DoesInvalidElementExist = IsDefined && IsTypeValid && !IsEveryElementValid;
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsEveryElementValid;
            const VariativeValidationError = (___) => {
                if (DoesInvalidElementExist) {
                    const InvalidElement = InvalidElements[0];
                    const InvalidElementValue = InvalidElement.Value;
                    const InvalidElementValidationResult = SingleElementValidation(InvalidElementValue, true);
                    const InvalidElementError = InvalidElementValidationResult.Error;
                    const DoesInvalidElementErrorExist = ErrorValidator.Default.Function(InvalidElementError);
                    if (DoesInvalidElementErrorExist) {
                        const IsInvalidElementErrorCustom = BaseValidator.TypeGuard.Default.IsInstanceOf(InvalidElementError, GlobalModule.Classes.Error.BaseError);
                        const InvalidElementErrorMessage = IsInvalidElementErrorCustom ? InvalidElementError.Message : [InvalidElementError.message];
                        const NewValidationError = BaseValidator.TypeError.Default.Object.Unexpected([
                            `Поле "`,
                            InvalidElement.Name,
                            `" указанного объекта является некорректным.`,
                            GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default,
                            ...InvalidElementErrorMessage,
                        ])(___);
                        return NewValidationError;
                    }
                    else {
                        const NewValidationError = ObjectValidator.Default.Error.Type.Invalid(___);
                        return NewValidationError;
                    }
                }
                else {
                    const NewValidationError = ObjectValidator.Default.Error.Type.Invalid(___);
                    return NewValidationError;
                }
            };
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, ObjectValidator.Default, VariativeValidationError);
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    With(object) {
        Validator.Strict(object, new Validator().Default.Object().Required().Of(new Validator().Default.Class.Instance().Required().Of(BaseValidator)));
        const SingleElementValidation = (value, validator, formError) => {
            const IsValidationDefined = BaseValidator.TypeGuard.Default.IsInstanceOf(validator, BaseValidator);
            if (IsValidationDefined) {
                const ValidationResult = BaseValidator.GetFunction(validator)(value, formError);
                return ValidationResult;
            }
            else {
                const ValidationResult = {
                    Status: true,
                    Error: undefined,
                };
                return ValidationResult;
            }
        };
        const AllElementsValidation = (initialObject, validationObject) => {
            const NativeKeys = GlobalModule.Functions.Parameter.Type.Manager.Default.Object.GetProperties(initialObject);
            const ExpectedKeys = GlobalModule.Functions.Parameter.Type.Manager.Default.Object.GetProperties(validationObject);
            const NativeElements = NativeKeys.map((_el, _ind, _arr) => {
                const MappedElement = {
                    Name: _el,
                    Value: initialObject[_el],
                };
                return MappedElement;
            });
            const OtherExpectedElements = ExpectedKeys.map((_el, _ind, _arr) => {
                const MappedElement = {
                    Name: _el,
                    Value: initialObject[_el],
                };
                return MappedElement;
            }).filter((_el, _ind, _arr) => !NativeElements.map((__el, __ind, __arr) => __el.Name).includes(_el.Name));
            const InvalidElements = [...NativeElements, ...OtherExpectedElements]
                .map((_el, _ind, _arr) => {
                const ElementValue = _el.Value;
                const ElementValidation = validationObject[_el.Name];
                const ElementValidationResult = SingleElementValidation(ElementValue, ElementValidation, false);
                const ExtendedMappedElement = {
                    Name: _el.Name,
                    Value: _el.Value,
                    Result: ElementValidationResult,
                };
                return ExtendedMappedElement;
            })
                .filter((_el, _ind, _arr) => {
                const IsElementValidationSuccesful = _el.Result.Status;
                return !IsElementValidationSuccesful;
            });
            return InvalidElements;
        };
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = ObjectValidator.Default.Function(_);
            const InitialElement = IsDefined && IsTypeValid ? _ : {};
            const NativeKeys = GlobalModule.Functions.Parameter.Type.Manager.Default.Object.GetProperties(InitialElement);
            const ExpectedKeys = GlobalModule.Functions.Parameter.Type.Manager.Default.Object.GetProperties(object);
            const InvalidElements = AllElementsValidation(InitialElement, object);
            const IsEveryElementValid = IsDefined && IsTypeValid && BaseValidator.TypeGuard.Default.IsEmptyArray(InvalidElements);
            const DoesInvalidElementExist = IsDefined && IsTypeValid && !IsEveryElementValid;
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsEveryElementValid;
            const VariativeValidationError = (___) => {
                if (DoesInvalidElementExist) {
                    const InvalidElement = InvalidElements[0];
                    const InvalidElementValue = InvalidElement.Value;
                    const InvalidElementValidation = object[InvalidElement.Name];
                    const InvalidElementValidationResult = SingleElementValidation(InvalidElementValue, InvalidElementValidation, true);
                    const InvalidElementError = InvalidElementValidationResult.Error;
                    const DoesInvalidElementErrorExist = ErrorValidator.Default.Function(InvalidElementError);
                    if (!NativeKeys.includes(InvalidElement.Name)) {
                        const NewValidationError = BaseValidator.TypeError.Default.Object.Expected.Keys.With(ExpectedKeys)(___);
                        return NewValidationError;
                    }
                    else {
                        if (DoesInvalidElementErrorExist) {
                            const IsInvalidElementErrorCustom = BaseValidator.TypeGuard.Default.IsInstanceOf(InvalidElementError, GlobalModule.Classes.Error.BaseError);
                            const InvalidElementErrorMessage = IsInvalidElementErrorCustom ? InvalidElementError.Message : [InvalidElementError.message];
                            const NewValidationError = BaseValidator.TypeError.Default.Object.Unexpected([
                                `Поле "`,
                                InvalidElement.Name,
                                `" указанного объекта является некорректным.`,
                                GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default,
                                ...InvalidElementErrorMessage,
                            ])(___);
                            return NewValidationError;
                        }
                        else {
                            const NewValidationError = ObjectValidator.Default.Error.Type.Invalid(___);
                            return NewValidationError;
                        }
                    }
                }
                else {
                    const NewValidationError = ObjectValidator.Default.Error.Type.Invalid(___);
                    return NewValidationError;
                }
            };
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, ObjectValidator.Default, VariativeValidationError);
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    Exact(object) {
        Validator.Strict(object, new Validator().Default.Object().Required().Of(new Validator().Default.Class.Instance().Required().Of(BaseValidator)));
        const SingleElementValidation = (initialObject, expectedKeys, value, validator, formError) => {
            const IsValidationDefined = BaseValidator.TypeGuard.Default.IsInstanceOf(validator, BaseValidator);
            if (IsValidationDefined) {
                const ValidationResult = BaseValidator.GetFunction(validator)(value, formError);
                return ValidationResult;
            }
            else {
                const ValidationResult = {
                    Status: IsValidationDefined,
                    Error: BaseValidator.TypeError.Default.Object.Expected.Keys.Of(expectedKeys)(initialObject),
                };
                return ValidationResult;
            }
        };
        const AllElementsValidation = (initialObject, validationObject) => {
            const NativeKeys = GlobalModule.Functions.Parameter.Type.Manager.Default.Object.GetProperties(initialObject);
            const ExpectedKeys = GlobalModule.Functions.Parameter.Type.Manager.Default.Object.GetProperties(validationObject);
            const NativeElements = NativeKeys.map((_el, _ind, _arr) => {
                const MappedElement = {
                    Name: _el,
                    Value: initialObject[_el],
                };
                return MappedElement;
            });
            const OtherExpectedElements = ExpectedKeys.map((_el, _ind, _arr) => {
                const MappedElement = {
                    Name: _el,
                    Value: initialObject[_el],
                };
                return MappedElement;
            }).filter((_el, _ind, _arr) => !NativeElements.map((__el, __ind, __arr) => __el.Name).includes(_el.Name));
            const InvalidElements = [...NativeElements, ...OtherExpectedElements]
                .map((_el, _ind, _arr) => {
                const ElementValue = _el.Value;
                const ElementValidation = validationObject[_el.Name];
                const ElementValidationResult = SingleElementValidation(initialObject, ExpectedKeys, ElementValue, ElementValidation, false);
                const ExtendedMappedElement = {
                    Name: _el.Name,
                    Value: _el.Value,
                    Result: ElementValidationResult,
                };
                return ExtendedMappedElement;
            })
                .filter((_el, _ind, _arr) => {
                const IsElementValidationSuccesful = _el.Result.Status;
                return !IsElementValidationSuccesful;
            });
            return InvalidElements;
        };
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = ObjectValidator.Default.Function(_);
            const InitialElement = IsDefined && IsTypeValid ? _ : {};
            const NativeKeys = GlobalModule.Functions.Parameter.Type.Manager.Default.Object.GetProperties(InitialElement);
            const ExpectedKeys = GlobalModule.Functions.Parameter.Type.Manager.Default.Object.GetProperties(object);
            const InvalidElements = AllElementsValidation(InitialElement, object);
            const IsEveryElementValid = IsDefined && IsTypeValid && BaseValidator.TypeGuard.Default.IsEmptyArray(InvalidElements);
            const DoesInvalidElementExist = IsDefined && IsTypeValid && !IsEveryElementValid;
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsEveryElementValid;
            const VariativeValidationError = (___) => {
                if (DoesInvalidElementExist) {
                    const InvalidElement = InvalidElements[0];
                    const InvalidElementValue = InvalidElement.Value;
                    const InvalidElementValidation = object[InvalidElement.Name];
                    const InvalidElementValidationResult = SingleElementValidation(InitialElement, ExpectedKeys, InvalidElementValue, InvalidElementValidation, true);
                    const InvalidElementError = InvalidElementValidationResult.Error;
                    const DoesInvalidElementErrorExist = ErrorValidator.Default.Function(InvalidElementError);
                    if (!NativeKeys.includes(InvalidElement.Name)) {
                        const NewValidationError = BaseValidator.TypeError.Default.Object.Expected.Keys.Of(ExpectedKeys)(___);
                        return NewValidationError;
                    }
                    else if (!ExpectedKeys.includes(InvalidElement.Name)) {
                        const NewValidationError = BaseValidator.TypeError.Default.Object.Expected.Keys.Of(ExpectedKeys)(___);
                        return NewValidationError;
                    }
                    else {
                        if (DoesInvalidElementErrorExist) {
                            const IsInvalidElementErrorCustom = BaseValidator.TypeGuard.Default.IsInstanceOf(InvalidElementError, GlobalModule.Classes.Error.BaseError);
                            const InvalidElementErrorMessage = IsInvalidElementErrorCustom ? InvalidElementError.Message : [InvalidElementError.message];
                            const NewValidationError = BaseValidator.TypeError.Default.Object.Unexpected([
                                `Поле "`,
                                InvalidElement.Name,
                                `" указанного объекта является некорректным.`,
                                GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default,
                                ...InvalidElementErrorMessage,
                            ])(___);
                            return NewValidationError;
                        }
                        else {
                            const NewValidationError = ObjectValidator.Default.Error.Type.Invalid(___);
                            return NewValidationError;
                        }
                    }
                }
                else {
                    const NewValidationError = ObjectValidator.Default.Error.Type.Invalid(___);
                    return NewValidationError;
                }
            };
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, ObjectValidator.Default, VariativeValidationError);
            return ValidationResult;
        };
        return this;
    }
}
class RegExpValidator extends BaseValidator {
    // TODO: JSDoc
    static Default = {
        Function: BaseValidator.TypeGuard.Default.IsRegExp,
        Error: {
            Type: {
                Invalid: BaseValidator.TypeError.Default.RegExp.Invalid,
            },
            Parameter: {
                Unexpected: BaseValidator.TypeError.Default.RegExp.Unexpected,
            },
        },
    };
    // TODO: JSDoc
    constructor(defaultErrorConstructor, mainValidation, alternativeValidations) {
        super(defaultErrorConstructor, mainValidation, alternativeValidations);
    }
    // TODO: JSDoc
    Global() {
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = RegExpValidator.Default.Function(_);
            const IsGlobal = IsDefined && IsTypeValid && _.global;
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsGlobal;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, RegExpValidator.Default, BaseValidator.TypeError.Default.RegExp.Expected.Global);
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    Multiline() {
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = RegExpValidator.Default.Function(_);
            const IsMultiline = IsDefined && IsTypeValid && _.multiline;
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsMultiline;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, RegExpValidator.Default, BaseValidator.TypeError.Default.RegExp.Expected.Multiline);
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    CaseIgnored() {
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = RegExpValidator.Default.Function(_);
            const IsCaseIgnored = IsDefined && IsTypeValid && _.ignoreCase;
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsCaseIgnored;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, RegExpValidator.Default, BaseValidator.TypeError.Default.RegExp.Expected.CaseIgnored);
            return ValidationResult;
        };
        return this;
    }
}
class BooleanValidator extends BaseValidator {
    // TODO: JSDoc
    static Default = {
        Function: BaseValidator.TypeGuard.Default.IsBoolean,
        Error: {
            Type: {
                Invalid: BaseValidator.TypeError.Default.Boolean.Invalid,
            },
            Parameter: {
                Unexpected: BaseValidator.TypeError.Default.Boolean.Unexpected,
            },
        },
    };
    // TODO: JSDoc
    constructor(defaultErrorConstructor, mainValidation, alternativeValidations) {
        super(defaultErrorConstructor, mainValidation, alternativeValidations);
    }
}
class DateValidator extends BaseValidator {
    // TODO: JSDoc
    static Default = {
        Function: BaseValidator.TypeGuard.Default.IsDate,
        Error: {
            Type: {
                Invalid: BaseValidator.TypeError.Default.Date.Invalid,
            },
            Parameter: {
                Unexpected: BaseValidator.TypeError.Default.Date.Unexpected,
            },
        },
    };
    // TODO: JSDoc
    constructor(defaultErrorConstructor, mainValidation, alternativeValidations) {
        super(defaultErrorConstructor, mainValidation, alternativeValidations);
    }
    // TODO: JSDoc
    NewerThan(date) {
        Validator.Strict(date, new Validator().Default.Date().Required());
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = DateValidator.Default.Function(_);
            const IsNewerThan = IsDefined && IsTypeValid && _.getTime() > date.getTime();
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsNewerThan;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, DateValidator.Default, BaseValidator.TypeError.Default.Date.Expected.NewerThan(date));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    NewerThanOrEqual(date) {
        Validator.Strict(date, new Validator().Default.Date().Required());
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = DateValidator.Default.Function(_);
            const IsNewerThanOrEqual = IsDefined && IsTypeValid && _.getTime() >= date.getTime();
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsNewerThanOrEqual;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, DateValidator.Default, BaseValidator.TypeError.Default.Date.Expected.NewerThanOrEqual(date));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    OlderThan(date) {
        Validator.Strict(date, new Validator().Default.Date().Required());
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = DateValidator.Default.Function(_);
            const IsOlderThan = IsDefined && IsTypeValid && _.getTime() < date.getTime();
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsOlderThan;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, DateValidator.Default, BaseValidator.TypeError.Default.Date.Expected.OlderThan(date));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    OlderThanOrEqual(date) {
        Validator.Strict(date, new Validator().Default.Date().Required());
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = DateValidator.Default.Function(_);
            const IsOlderThanOrEqual = IsDefined && IsTypeValid && _.getTime() <= date.getTime();
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsOlderThanOrEqual;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, DateValidator.Default, BaseValidator.TypeError.Default.Date.Expected.OlderThanOrEqual(date));
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    NewerThanNow() {
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = DateValidator.Default.Function(_);
            const IsNewerThanNow = IsDefined && IsTypeValid && _.getTime() > new Date().getTime();
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsNewerThanNow;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, DateValidator.Default, BaseValidator.TypeError.Default.Date.Expected.NewerThanNow);
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    NewerThanOrEqualNow() {
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = DateValidator.Default.Function(_);
            const IsNewerThanOrEqualNow = IsDefined && IsTypeValid && _.getTime() >= new Date().getTime();
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsNewerThanOrEqualNow;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, DateValidator.Default, BaseValidator.TypeError.Default.Date.Expected.NewerThanOrEqualNow);
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    OlderThanNow() {
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = DateValidator.Default.Function(_);
            const IsOlderThanNow = IsDefined && IsTypeValid && _.getTime() < new Date().getTime();
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsOlderThanNow;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, DateValidator.Default, BaseValidator.TypeError.Default.Date.Expected.OlderThanNow);
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    OlderThanOrEqualNow() {
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = DateValidator.Default.Function(_);
            const IsOlderThanOrEqualNow = IsDefined && IsTypeValid && _.getTime() <= new Date().getTime();
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsOlderThanOrEqualNow;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, DateValidator.Default, BaseValidator.TypeError.Default.Date.Expected.OlderThanOrEqualNow);
            return ValidationResult;
        };
        return this;
    }
}
class FunctionValidator extends BaseValidator {
    // TODO: JSDoc
    static Default = {
        Function: BaseValidator.TypeGuard.Default.IsFunction,
        Error: {
            Type: {
                Invalid: BaseValidator.TypeError.Default.Function.Invalid,
            },
            Parameter: {
                Unexpected: BaseValidator.TypeError.Default.Function.Unexpected,
            },
        },
    };
    // TODO: JSDoc
    constructor(defaultErrorConstructor, mainValidation, alternativeValidations) {
        super(defaultErrorConstructor, mainValidation, alternativeValidations);
    }
}
class ErrorValidator extends BaseValidator {
    // TODO: JSDoc
    static Default = {
        Function: BaseValidator.TypeGuard.Default.IsError,
        Error: {
            Type: {
                Invalid: BaseValidator.TypeError.Default.Error.Invalid,
            },
            Parameter: {
                Unexpected: BaseValidator.TypeError.Default.Error.Unexpected,
            },
        },
    };
    // TODO: JSDoc
    constructor(defaultErrorConstructor, mainValidation, alternativeValidations) {
        super(defaultErrorConstructor, mainValidation, alternativeValidations);
    }
}
class ClassDeclarationValidator extends BaseValidator {
    // TODO: JSDoc
    static Default = {
        Function: BaseValidator.TypeGuard.Default.Class.IsDeclaration,
        Error: {
            Type: {
                Invalid: BaseValidator.TypeError.Default.Class.Declaration.Invalid,
            },
            Parameter: {
                Unexpected: BaseValidator.TypeError.Default.Class.Declaration.Unexpected,
            },
        },
    };
    // TODO: JSDoc
    constructor(defaultErrorConstructor, mainValidation, alternativeValidations) {
        super(defaultErrorConstructor, mainValidation, alternativeValidations);
    }
}
class ClassInstanceValidator extends BaseValidator {
    // TODO: JSDoc
    static Default = {
        Function: BaseValidator.TypeGuard.Default.Class.IsInstance,
        Error: {
            Type: {
                Invalid: BaseValidator.TypeError.Default.Class.Instance.Invalid,
            },
            Parameter: {
                Unexpected: BaseValidator.TypeError.Default.Class.Instance.Unexpected,
            },
        },
    };
    // TODO: JSDoc
    constructor(defaultErrorConstructor, mainValidation, alternativeValidations) {
        super(defaultErrorConstructor, mainValidation, alternativeValidations);
    }
    // TODO: JSDoc
    Of(declaration) {
        Validator.Strict(declaration, new Validator().Default.Class.Declaration().Required());
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = ClassInstanceValidator.Default.Function(_);
            const IsInstanceOf = IsDefined && IsTypeValid && BaseValidator.TypeGuard.Default.IsInstanceOf(_, declaration);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsInstanceOf;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, ClassInstanceValidator.Default, BaseValidator.TypeError.Default.Class.Instance.Expected.InstanceOf(declaration));
            return ValidationResult;
        };
        return this;
    }
}
class HEXColorValidator extends BaseValidator {
    // TODO: JSDoc
    static Default = {
        Function: BaseValidator.TypeGuard.Custom.Color.IsHEX,
        Error: {
            Type: {
                Invalid: BaseValidator.TypeError.Custom.Color.HEX.Invalid,
            },
            Parameter: {
                Unexpected: BaseValidator.TypeError.Custom.Color.HEX.Unexpected,
            },
        },
    };
    // TODO: JSDoc
    constructor(defaultErrorConstructor, mainValidation, alternativeValidations) {
        super(defaultErrorConstructor, mainValidation, alternativeValidations);
    }
}
class RGBColorValidator extends BaseValidator {
    // TODO: JSDoc
    static Default = {
        Function: BaseValidator.TypeGuard.Custom.Color.IsRGB,
        Error: {
            Type: {
                Invalid: BaseValidator.TypeError.Custom.Color.RGB.Invalid,
            },
            Parameter: {
                Unexpected: BaseValidator.TypeError.Custom.Color.RGB.Unexpected,
            },
        },
    };
    // TODO: JSDoc
    constructor(defaultErrorConstructor, mainValidation, alternativeValidations) {
        super(defaultErrorConstructor, mainValidation, alternativeValidations);
    }
}
class RGBAColorValidator extends BaseValidator {
    // TODO: JSDoc
    static Default = {
        Function: BaseValidator.TypeGuard.Custom.Color.IsRGBA,
        Error: {
            Type: {
                Invalid: BaseValidator.TypeError.Custom.Color.RGBA.Invalid,
            },
            Parameter: {
                Unexpected: BaseValidator.TypeError.Custom.Color.RGBA.Unexpected,
            },
        },
    };
    // TODO: JSDoc
    constructor(defaultErrorConstructor, mainValidation, alternativeValidations) {
        super(defaultErrorConstructor, mainValidation, alternativeValidations);
    }
}
class FileSystemPathValidator extends BaseValidator {
    // TODO: JSDoc
    static Default = {
        Function: BaseValidator.TypeGuard.Custom.FileSystem.IsPath,
        Error: {
            Type: {
                Invalid: BaseValidator.TypeError.Custom.FileSystem.Any.Path.Invalid,
            },
            Parameter: {
                Unexpected: BaseValidator.TypeError.Custom.FileSystem.Any.Path.Unexpected,
            },
        },
    };
    // TODO: JSDoc
    constructor(defaultErrorConstructor, mainValidation, alternativeValidations) {
        super(defaultErrorConstructor, mainValidation, alternativeValidations);
    }
    // TODO: JSDoc
    File() {
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = StringValidator.Default.Function(_) && FileSystemPathValidator.Default.Function(_);
            const IsFilePath = IsDefined && IsTypeValid && BaseValidator.TypeGuard.Custom.FileSystem.IsFilePath(_);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsFilePath;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, FileSystemPathValidator.Default, BaseValidator.TypeError.Custom.FileSystem.File.Path.Invalid);
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    Directory() {
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = StringValidator.Default.Function(_) && FileSystemPathValidator.Default.Function(_);
            const IsDirectoryPath = IsDefined && IsTypeValid && BaseValidator.TypeGuard.Custom.FileSystem.IsDirectoryPath(_);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsDirectoryPath;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, FileSystemPathValidator.Default, BaseValidator.TypeError.Custom.FileSystem.Directory.Path.Invalid);
            return ValidationResult;
        };
        return this;
    }
}
class FileSystemURLValidator extends BaseValidator {
    // TODO: JSDoc
    static Default = {
        Function: BaseValidator.TypeGuard.Custom.FileSystem.IsPathURL,
        Error: {
            Type: {
                Invalid: BaseValidator.TypeError.Custom.FileSystem.Any.URL.Invalid,
            },
            Parameter: {
                Unexpected: BaseValidator.TypeError.Custom.FileSystem.Any.URL.Unexpected,
            },
        },
    };
    // TODO: JSDoc
    constructor(defaultErrorConstructor, mainValidation, alternativeValidations) {
        super(defaultErrorConstructor, mainValidation, alternativeValidations);
    }
    // TODO: JSDoc
    File() {
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = StringValidator.Default.Function(_) && FileSystemURLValidator.Default.Function(_);
            const IsFileURL = IsDefined && IsTypeValid && BaseValidator.TypeGuard.Custom.FileSystem.IsFileURL(_);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsFileURL;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, FileSystemURLValidator.Default, BaseValidator.TypeError.Custom.FileSystem.File.URL.Invalid);
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    Directory() {
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = StringValidator.Default.Function(_) && FileSystemURLValidator.Default.Function(_);
            const IsDirectoryURL = IsDefined && IsTypeValid && BaseValidator.TypeGuard.Custom.FileSystem.IsDirectoryURL(_);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsDirectoryURL;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, FileSystemURLValidator.Default, BaseValidator.TypeError.Custom.FileSystem.Directory.URL.Invalid);
            return ValidationResult;
        };
        return this;
    }
}
class FileSystemDirectoryValidator extends BaseValidator {
    // TODO: JSDoc
    static Default = {
        Function: BaseValidator.TypeGuard.Custom.FileSystem.IsDirectoryPath,
        Error: {
            Type: {
                Invalid: BaseValidator.TypeError.Custom.FileSystem.Directory.Path.Invalid,
            },
            Parameter: {
                Unexpected: BaseValidator.TypeError.Custom.FileSystem.Directory.Path.Unexpected,
            },
        },
    };
    // TODO: JSDoc
    constructor(defaultErrorConstructor, mainValidation, alternativeValidations) {
        super(defaultErrorConstructor, mainValidation, alternativeValidations);
    }
    // TODO: JSDoc
    Exist() {
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = StringValidator.Default.Function(_) && FileSystemDirectoryValidator.Default.Function(_);
            const DoesDirectoryExist = IsDefined && IsTypeValid && GlobalModule.Classes.FileSystem.DoesDirectoryExist(_);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || DoesDirectoryExist;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, FileSystemDirectoryValidator.Default, BaseValidator.TypeError.Custom.FileSystem.Directory.DoesntExist);
            return ValidationResult;
        };
        return this;
    }
}
class FileSystemFileValidator extends BaseValidator {
    // TODO: JSDoc
    static Default = {
        Function: BaseValidator.TypeGuard.Custom.FileSystem.IsFilePath,
        Error: {
            Type: {
                Invalid: BaseValidator.TypeError.Custom.FileSystem.File.Path.Invalid,
            },
            Parameter: {
                Unexpected: BaseValidator.TypeError.Custom.FileSystem.File.Path.Unexpected,
            },
        },
    };
    // TODO: JSDoc
    constructor(defaultErrorConstructor, mainValidation, alternativeValidations) {
        super(defaultErrorConstructor, mainValidation, alternativeValidations);
    }
    // TODO: JSDoc
    Exist() {
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = StringValidator.Default.Function(_) && FileSystemFileValidator.Default.Function(_);
            const DoesFileExist = IsDefined && IsTypeValid && GlobalModule.Classes.FileSystem.DoesFileExist(_);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || DoesFileExist;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, FileSystemFileValidator.Default, BaseValidator.TypeError.Custom.FileSystem.File.DoesntExist);
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    Reachable() {
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = StringValidator.Default.Function(_) && FileSystemFileValidator.Default.Function(_);
            const DoesFileExist = IsDefined && IsTypeValid && GlobalModule.Classes.FileSystem.DoesFileExist(_);
            const IsFileReachable = IsDefined && IsTypeValid && DoesFileExist && GlobalModule.Classes.FileSystem.IsFileReachable(_);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsFileReachable;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, FileSystemFileValidator.Default, BaseValidator.TypeError.Custom.FileSystem.File.Unreachable);
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    Readable() {
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = StringValidator.Default.Function(_) && FileSystemFileValidator.Default.Function(_);
            const DoesFileExist = IsDefined && IsTypeValid && GlobalModule.Classes.FileSystem.DoesFileExist(_);
            const IsFileReachable = IsDefined && IsTypeValid && DoesFileExist && GlobalModule.Classes.FileSystem.IsFileReachable(_);
            const IsFileReadable = IsDefined && IsTypeValid && IsFileReachable && GlobalModule.Classes.FileSystem.IsFileReadable(_);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsFileReadable;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, FileSystemFileValidator.Default, BaseValidator.TypeError.Custom.FileSystem.File.Unreadable);
            return ValidationResult;
        };
        return this;
    }
    // TODO: JSDoc
    Writeable() {
        const PreviousValidationFunction = this._Validation.Function.Main;
        this._Validation.Function.Main = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = StringValidator.Default.Function(_) && FileSystemFileValidator.Default.Function(_);
            const DoesFileExist = IsDefined && IsTypeValid && GlobalModule.Classes.FileSystem.DoesFileExist(_);
            const IsFileReachable = IsDefined && IsTypeValid && DoesFileExist && GlobalModule.Classes.FileSystem.IsFileReachable(_);
            const IsFileWriteable = IsDefined && IsTypeValid && IsFileReachable && GlobalModule.Classes.FileSystem.IsFileWriteable(_);
            const PreviousValidation = PreviousValidationFunction(_, __);
            const ValidationStatus = !IsDefined || IsFileWriteable;
            const ValidationResult = this._FormValidationResult(_, __, ValidationStatus, PreviousValidation, FileSystemFileValidator.Default, BaseValidator.TypeError.Custom.FileSystem.File.Unwriteable);
            return ValidationResult;
        };
        return this;
    }
}
class BaseURLValidator extends BaseValidator {
    // TODO: JSDoc
    static Default = {
        Function: BaseValidator.TypeGuard.Custom.URL.IsURL,
        Error: {
            Type: {
                Invalid: BaseValidator.TypeError.Custom.URL.Base.Invalid,
            },
            Parameter: {
                Unexpected: BaseValidator.TypeError.Custom.URL.Base.Unexpected,
            },
        },
    };
    // TODO: JSDoc
    constructor(defaultErrorConstructor, mainValidation, alternativeValidations) {
        super(defaultErrorConstructor, mainValidation, alternativeValidations);
    }
}
class BaseValidationInitter {
    // TODO: JSDoc
    _AlternativeValidations;
    // TODO: JSDoc
    constructor(alternativeValidations) {
        this._AlternativeValidations = alternativeValidations;
    }
}
class ValidationInitter_Default extends BaseValidationInitter {
    // TODO: JSDoc
    constructor(alternativeValidations) {
        super(alternativeValidations);
    }
    // TODO: JSDoc
    Any() {
        const NewValidationFunction = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = AnyValidator.Default.Function(_);
            const ValidationStatus = !IsDefined || IsTypeValid;
            const IsValidationErrorRequired = __;
            const ValidationResult = {
                Status: ValidationStatus,
                Error: IsValidationErrorRequired ? (ValidationStatus ? undefined : AnyValidator.Default.Error.Type.Invalid(_)) : undefined,
            };
            return ValidationResult;
        };
        const NewValidator = new AnyValidator(AnyValidator.Default.Error, NewValidationFunction, this._AlternativeValidations);
        return NewValidator;
    }
    // TODO: JSDoc
    Symbol() {
        const NewValidationFunction = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = SymbolValidator.Default.Function(_);
            const ValidationStatus = !IsDefined || IsTypeValid;
            const IsValidationErrorRequired = __;
            const ValidationResult = {
                Status: ValidationStatus,
                Error: IsValidationErrorRequired ? (ValidationStatus ? undefined : SymbolValidator.Default.Error.Type.Invalid(_)) : undefined,
            };
            return ValidationResult;
        };
        const NewValidator = new SymbolValidator(SymbolValidator.Default.Error, NewValidationFunction, this._AlternativeValidations);
        return NewValidator;
    }
    // TODO: JSDoc
    String() {
        const NewValidationFunction = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = StringValidator.Default.Function(_);
            const ValidationStatus = !IsDefined || IsTypeValid;
            const IsValidationErrorRequired = __;
            const ValidationResult = {
                Status: ValidationStatus,
                Error: IsValidationErrorRequired ? (ValidationStatus ? undefined : StringValidator.Default.Error.Type.Invalid(_)) : undefined,
            };
            return ValidationResult;
        };
        const NewValidator = new StringValidator(StringValidator.Default.Error, NewValidationFunction, this._AlternativeValidations);
        return NewValidator;
    }
    // TODO: JSDoc
    Numeric() {
        const NewValidationFunction = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = NumericValidator.Default.Function(_);
            const ValidationStatus = !IsDefined || IsTypeValid;
            const IsValidationErrorRequired = __;
            const ValidationResult = {
                Status: ValidationStatus,
                Error: IsValidationErrorRequired ? (ValidationStatus ? undefined : NumericValidator.Default.Error.Type.Invalid(_)) : undefined,
            };
            return ValidationResult;
        };
        const NewValidator = new NumericValidator(NumericValidator.Default.Error, NewValidationFunction, this._AlternativeValidations);
        return NewValidator;
    }
    // TODO: JSDoc
    Array() {
        const NewValidationFunction = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = ArrayValidator.Default.Function(_);
            const ValidationStatus = !IsDefined || IsTypeValid;
            const IsValidationErrorRequired = __;
            const ValidationResult = {
                Status: ValidationStatus,
                Error: IsValidationErrorRequired ? (ValidationStatus ? undefined : ArrayValidator.Default.Error.Type.Invalid(_)) : undefined,
            };
            return ValidationResult;
        };
        const NewValidator = new ArrayValidator(ArrayValidator.Default.Error, NewValidationFunction, this._AlternativeValidations);
        return NewValidator;
    }
    // TODO: JSDoc
    Object() {
        const NewValidationFunction = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = ObjectValidator.Default.Function(_);
            const ValidationStatus = !IsDefined || IsTypeValid;
            const IsValidationErrorRequired = __;
            const ValidationResult = {
                Status: ValidationStatus,
                Error: IsValidationErrorRequired ? (ValidationStatus ? undefined : ObjectValidator.Default.Error.Type.Invalid(_)) : undefined,
            };
            return ValidationResult;
        };
        const NewValidator = new ObjectValidator(ObjectValidator.Default.Error, NewValidationFunction, this._AlternativeValidations);
        return NewValidator;
    }
    // TODO: JSDoc
    RegExp() {
        const NewValidationFunction = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = RegExpValidator.Default.Function(_);
            const ValidationStatus = !IsDefined || IsTypeValid;
            const IsValidationErrorRequired = __;
            const ValidationResult = {
                Status: ValidationStatus,
                Error: IsValidationErrorRequired ? (ValidationStatus ? undefined : RegExpValidator.Default.Error.Type.Invalid(_)) : undefined,
            };
            return ValidationResult;
        };
        const NewValidator = new RegExpValidator(RegExpValidator.Default.Error, NewValidationFunction, this._AlternativeValidations);
        return NewValidator;
    }
    // TODO: JSDoc
    Boolean() {
        const NewValidationFunction = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = BooleanValidator.Default.Function(_);
            const ValidationStatus = !IsDefined || IsTypeValid;
            const IsValidationErrorRequired = __;
            const ValidationResult = {
                Status: ValidationStatus,
                Error: IsValidationErrorRequired ? (ValidationStatus ? undefined : BooleanValidator.Default.Error.Type.Invalid(_)) : undefined,
            };
            return ValidationResult;
        };
        const NewValidator = new BooleanValidator(BooleanValidator.Default.Error, NewValidationFunction, this._AlternativeValidations);
        return NewValidator;
    }
    // TODO: JSDoc
    Date() {
        const NewValidationFunction = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = DateValidator.Default.Function(_);
            const ValidationStatus = !IsDefined || IsTypeValid;
            const IsValidationErrorRequired = __;
            const ValidationResult = {
                Status: ValidationStatus,
                Error: IsValidationErrorRequired ? (ValidationStatus ? undefined : DateValidator.Default.Error.Type.Invalid(_)) : undefined,
            };
            return ValidationResult;
        };
        const NewValidator = new DateValidator(DateValidator.Default.Error, NewValidationFunction, this._AlternativeValidations);
        return NewValidator;
    }
    // TODO: JSDoc
    Function() {
        const NewValidationFunction = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = FunctionValidator.Default.Function(_);
            const ValidationStatus = !IsDefined || IsTypeValid;
            const IsValidationErrorRequired = __;
            const ValidationResult = {
                Status: ValidationStatus,
                Error: IsValidationErrorRequired ? (ValidationStatus ? undefined : FunctionValidator.Default.Error.Type.Invalid(_)) : undefined,
            };
            return ValidationResult;
        };
        const NewValidator = new FunctionValidator(FunctionValidator.Default.Error, NewValidationFunction, this._AlternativeValidations);
        return NewValidator;
    }
    // TODO: JSDoc
    Error() {
        const NewValidationFunction = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = ErrorValidator.Default.Function(_);
            const ValidationStatus = !IsDefined || IsTypeValid;
            const IsValidationErrorRequired = __;
            const ValidationResult = {
                Status: ValidationStatus,
                Error: IsValidationErrorRequired ? (ValidationStatus ? undefined : ErrorValidator.Default.Error.Type.Invalid(_)) : undefined,
            };
            return ValidationResult;
        };
        const NewValidator = new ErrorValidator(ErrorValidator.Default.Error, NewValidationFunction, this._AlternativeValidations);
        return NewValidator;
    }
    // TODO: JSDoc
    Class = {
        Declaration: () => {
            const NewValidationFunction = (_, __) => {
                const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
                const IsTypeValid = ClassDeclarationValidator.Default.Function(_);
                const ValidationStatus = !IsDefined || IsTypeValid;
                const IsValidationErrorRequired = __;
                const ValidationResult = {
                    Status: ValidationStatus,
                    Error: IsValidationErrorRequired ? (ValidationStatus ? undefined : ClassDeclarationValidator.Default.Error.Type.Invalid(_)) : undefined,
                };
                return ValidationResult;
            };
            const NewValidator = new ClassDeclarationValidator(ClassDeclarationValidator.Default.Error, NewValidationFunction, this._AlternativeValidations);
            return NewValidator;
        },
        Instance: () => {
            const NewValidationFunction = (_, __) => {
                const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
                const IsTypeValid = ClassInstanceValidator.Default.Function(_);
                const ValidationStatus = !IsDefined || IsTypeValid;
                const IsValidationErrorRequired = __;
                const ValidationResult = {
                    Status: ValidationStatus,
                    Error: IsValidationErrorRequired ? (ValidationStatus ? undefined : ClassInstanceValidator.Default.Error.Type.Invalid(_)) : undefined,
                };
                return ValidationResult;
            };
            const NewValidator = new ClassInstanceValidator(ClassInstanceValidator.Default.Error, NewValidationFunction, this._AlternativeValidations);
            return NewValidator;
        },
    };
}
class ValidationInitter_Custom_Color extends BaseValidationInitter {
    // TODO: JSDoc
    constructor(alternativeValidations) {
        super(alternativeValidations);
    }
    // TODO: JSDoc
    HEX() {
        const NewValidationFunction = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = StringValidator.Default.Function(_) && HEXColorValidator.Default.Function(_);
            const ValidationStatus = !IsDefined || IsTypeValid;
            const IsValidationErrorRequired = __;
            const ValidationResult = {
                Status: ValidationStatus,
                Error: IsValidationErrorRequired ? (ValidationStatus ? undefined : HEXColorValidator.Default.Error.Type.Invalid(_)) : undefined,
            };
            return ValidationResult;
        };
        const NewValidator = new HEXColorValidator(HEXColorValidator.Default.Error, NewValidationFunction, this._AlternativeValidations);
        return NewValidator;
    }
    // TODO: JSDoc
    RGB() {
        const NewValidationFunction = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = ArrayValidator.Default.Function(_) && RGBColorValidator.Default.Function(_);
            const ValidationStatus = !IsDefined || IsTypeValid;
            const IsValidationErrorRequired = __;
            const ValidationResult = {
                Status: ValidationStatus,
                Error: IsValidationErrorRequired ? (ValidationStatus ? undefined : RGBColorValidator.Default.Error.Type.Invalid(_)) : undefined,
            };
            return ValidationResult;
        };
        const NewValidator = new RGBColorValidator(RGBColorValidator.Default.Error, NewValidationFunction, this._AlternativeValidations);
        return NewValidator;
    }
    // TODO: JSDoc
    RGBA() {
        const NewValidationFunction = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = ArrayValidator.Default.Function(_) && RGBAColorValidator.Default.Function(_);
            const ValidationStatus = !IsDefined || IsTypeValid;
            const IsValidationErrorRequired = __;
            const ValidationResult = {
                Status: ValidationStatus,
                Error: IsValidationErrorRequired ? (ValidationStatus ? undefined : RGBAColorValidator.Default.Error.Type.Invalid(_)) : undefined,
            };
            return ValidationResult;
        };
        const NewValidator = new RGBAColorValidator(RGBAColorValidator.Default.Error, NewValidationFunction, this._AlternativeValidations);
        return NewValidator;
    }
}
class ValidationInitter_Custom_FileSystem_Location extends BaseValidationInitter {
    // TODO: JSDoc
    constructor(alternativeValidations) {
        super(alternativeValidations);
    }
    // TODO: JSDoc
    Path() {
        const NewValidationFunction = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = StringValidator.Default.Function(_) && FileSystemPathValidator.Default.Function(_);
            const ValidationStatus = !IsDefined || IsTypeValid;
            const IsValidationErrorRequired = __;
            const ValidationResult = {
                Status: ValidationStatus,
                Error: IsValidationErrorRequired ? (ValidationStatus ? undefined : FileSystemPathValidator.Default.Error.Type.Invalid(_)) : undefined,
            };
            return ValidationResult;
        };
        const NewValidator = new FileSystemPathValidator(FileSystemPathValidator.Default.Error, NewValidationFunction, this._AlternativeValidations);
        return NewValidator;
    }
    // TODO: JSDoc
    URL() {
        const NewValidationFunction = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = StringValidator.Default.Function(_) && FileSystemURLValidator.Default.Function(_);
            const ValidationStatus = !IsDefined || IsTypeValid;
            const IsValidationErrorRequired = __;
            const ValidationResult = {
                Status: ValidationStatus,
                Error: IsValidationErrorRequired ? (ValidationStatus ? undefined : FileSystemURLValidator.Default.Error.Type.Invalid(_)) : undefined,
            };
            return ValidationResult;
        };
        const NewValidator = new FileSystemURLValidator(FileSystemURLValidator.Default.Error, NewValidationFunction, this._AlternativeValidations);
        return NewValidator;
    }
}
class ValidationInitter_Custom_FileSystem_Entity extends BaseValidationInitter {
    // TODO: JSDoc
    constructor(alternativeValidations) {
        super(alternativeValidations);
    }
    // TODO: JSDoc
    Directory() {
        const NewValidationFunction = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = StringValidator.Default.Function(_) && FileSystemDirectoryValidator.Default.Function(_);
            const ValidationStatus = !IsDefined || IsTypeValid;
            const IsValidationErrorRequired = __;
            const ValidationResult = {
                Status: ValidationStatus,
                Error: IsValidationErrorRequired ? (ValidationStatus ? undefined : FileSystemDirectoryValidator.Default.Error.Type.Invalid(_)) : undefined,
            };
            return ValidationResult;
        };
        const NewValidator = new FileSystemDirectoryValidator(FileSystemDirectoryValidator.Default.Error, NewValidationFunction, this._AlternativeValidations);
        return NewValidator;
    }
    // TODO: JSDoc
    File() {
        const NewValidationFunction = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = StringValidator.Default.Function(_) && FileSystemFileValidator.Default.Function(_);
            const ValidationStatus = !IsDefined || IsTypeValid;
            const IsValidationErrorRequired = __;
            const ValidationResult = {
                Status: ValidationStatus,
                Error: IsValidationErrorRequired ? (ValidationStatus ? undefined : FileSystemFileValidator.Default.Error.Type.Invalid(_)) : undefined,
            };
            return ValidationResult;
        };
        const NewValidator = new FileSystemFileValidator(FileSystemFileValidator.Default.Error, NewValidationFunction, this._AlternativeValidations);
        return NewValidator;
    }
}
class ValidationInitter_Custom_FileSystem extends BaseValidationInitter {
    // TODO: JSDoc
    Location;
    // TODO: JSDoc
    Entity;
    // TODO: JSDoc
    constructor(alternativeValidations) {
        super(alternativeValidations);
        this.Location = new ValidationInitter_Custom_FileSystem_Location(this._AlternativeValidations);
        this.Entity = new ValidationInitter_Custom_FileSystem_Entity(this._AlternativeValidations);
    }
}
class ValidationInitter_Custom_URL extends BaseValidationInitter {
    // TODO: JSDoc
    constructor(alternativeValidations) {
        super(alternativeValidations);
    }
    // TODO: JSDoc
    Base() {
        const NewValidationFunction = (_, __) => {
            const IsDefined = !BaseValidator.TypeGuard.Default.IsNullOrUndefined(_);
            const IsTypeValid = StringValidator.Default.Function(_) && BaseURLValidator.Default.Function(_);
            const ValidationStatus = !IsDefined || IsTypeValid;
            const IsValidationErrorRequired = __;
            const ValidationResult = {
                Status: ValidationStatus,
                Error: IsValidationErrorRequired ? (ValidationStatus ? undefined : BaseURLValidator.Default.Error.Type.Invalid(_)) : undefined,
            };
            return ValidationResult;
        };
        const NewValidator = new BaseURLValidator(BaseURLValidator.Default.Error, NewValidationFunction, this._AlternativeValidations);
        return NewValidator;
    }
}
class ValidationInitter extends BaseValidationInitter {
    // TODO: JSDoc
    Default;
    // TODO: JSDoc
    Custom;
    // TODO: JSDoc
    constructor(alternativeValidations) {
        super(alternativeValidations);
        this.Default = new ValidationInitter_Default(this._AlternativeValidations);
        this.Custom = {
            Color: new ValidationInitter_Custom_Color(this._AlternativeValidations),
            FileSystem: new ValidationInitter_Custom_FileSystem(this._AlternativeValidations),
            URL: new ValidationInitter_Custom_URL(this._AlternativeValidations),
        };
    }
}
class Validator extends ValidationInitter {
    // TODO: JSDoc
    static TypeGuard = TypeGuard;
    // TODO: JSDoc
    static TypeError = TypeError;
    // TODO: JSDoc
    static Is = {
        Base: (_) => BaseValidator.TypeGuard.Default.IsInstanceOf(_, BaseValidator),
        Default: {
            Any: (_) => BaseValidator.TypeGuard.Default.IsInstanceOf(_, AnyValidator),
            Symbol: (_) => BaseValidator.TypeGuard.Default.IsInstanceOf(_, SymbolValidator),
            String: (_) => BaseValidator.TypeGuard.Default.IsInstanceOf(_, StringValidator),
            Numeric: (_) => BaseValidator.TypeGuard.Default.IsInstanceOf(_, NumericValidator),
            Array: (_) => BaseValidator.TypeGuard.Default.IsInstanceOf(_, ArrayValidator),
            Object: (_) => BaseValidator.TypeGuard.Default.IsInstanceOf(_, ObjectValidator),
            RegExp: (_) => BaseValidator.TypeGuard.Default.IsInstanceOf(_, RegExpValidator),
            Boolean: (_) => BaseValidator.TypeGuard.Default.IsInstanceOf(_, BooleanValidator),
            Date: (_) => BaseValidator.TypeGuard.Default.IsInstanceOf(_, DateValidator),
            Function: (_) => BaseValidator.TypeGuard.Default.IsInstanceOf(_, FunctionValidator),
            Error: (_) => BaseValidator.TypeGuard.Default.IsInstanceOf(_, ErrorValidator),
            Class: {
                Declaration: (_) => BaseValidator.TypeGuard.Default.IsInstanceOf(_, ClassDeclarationValidator),
                Instance: (_) => BaseValidator.TypeGuard.Default.IsInstanceOf(_, ClassInstanceValidator),
            },
        },
        Custom: {
            Color: {
                HEX: (_) => BaseValidator.TypeGuard.Default.IsInstanceOf(_, HEXColorValidator),
                RGB: (_) => BaseValidator.TypeGuard.Default.IsInstanceOf(_, RGBColorValidator),
                RGBA: (_) => BaseValidator.TypeGuard.Default.IsInstanceOf(_, RGBAColorValidator),
            },
            FileSystem: {
                Location: {
                    Path: (_) => BaseValidator.TypeGuard.Default.IsInstanceOf(_, FileSystemPathValidator),
                    URL: (_) => BaseValidator.TypeGuard.Default.IsInstanceOf(_, FileSystemURLValidator),
                },
                Entity: {
                    Directory: (_) => BaseValidator.TypeGuard.Default.IsInstanceOf(_, FileSystemDirectoryValidator),
                    File: (_) => BaseValidator.TypeGuard.Default.IsInstanceOf(_, FileSystemFileValidator),
                },
            },
            URL: {
                Base: (_) => BaseValidator.TypeGuard.Default.IsInstanceOf(_, BaseURLValidator),
            },
        },
    };
    // TODO: JSDoc
    static __Init(parameter, validator) {
        const DoesValidatorExist = BaseValidator.TypeGuard.Default.IsInstanceOf(validator, BaseValidator);
        if (!DoesValidatorExist) {
            throw BaseValidator.TypeError.Default.Class.Instance.Expected.InstanceOf(BaseValidator)(validator);
        }
        const NewValidation = BaseValidator.GetFunction(validator);
        const PreValidationResult = NewValidation(parameter, false);
        const IsPreValidationResultValid = PreValidationResult.Status;
        const ValidationResult = IsPreValidationResultValid ? PreValidationResult : NewValidation(parameter, true);
        return ValidationResult;
    }
    // TODO: JSDoc
    static Strict(parameter, validator) {
        const ValidationResult = Validator.__Init(parameter, validator);
        const ValidationError = ValidationResult.Error;
        const DoesValidationErrorExist = ErrorValidator.Default.Function(ValidationError);
        if (DoesValidationErrorExist) {
            if (BaseValidator.TypeGuard.Default.IsInstanceOf(ValidationError, GlobalModule.Classes.Error.BaseError)) {
                const ResultValidationError = new GlobalModule.Classes.Error.BaseError(ValidationError.Tag, ValidationError.TagColor, ValidationError.Code, ValidationError.CodeName, ValidationError.CodeNameColor, undefined, ValidationError.Message);
                throw ResultValidationError;
            }
            throw ValidationError;
        }
    }
    // TODO: JSDoc
    static Soft(parameter, validator) {
        const ValidationResult = Validator.__Init(parameter, validator);
        return ValidationResult;
    }
    // TODO: JSDoc
    static GetOneOf(valuesArray, validator) {
        const ValidValue = valuesArray.find((_el, _ind, _arr) => {
            const IsValudValid = Validator.Soft(_el, validator).Status;
            return IsValudValid;
        });
        const DoesValidValueExist = !Validator.TypeGuard.Default.IsNullOrUndefined(ValidValue);
        if (DoesValidValueExist) {
            return ValidValue;
        }
        else {
            return undefined;
        }
    }
    // TODO: JSDoc
    static GetSomeOf(valuesArray, validator) {
        const ValidValues = valuesArray.filter((_el, _ind, _arr) => {
            const IsValudValid = Validator.Soft(_el, validator).Status;
            return IsValudValid;
        });
        return ValidValues;
    }
    // TODO: JSDoc
    constructor() {
        super([]);
    }
}
export default Validator;
//# sourceMappingURL=Validator.js.map