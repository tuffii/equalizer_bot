import * as GlobalModule from '../@module.js';
export default class FileSystem {
    // TODO: JSDoc
    Path;
    // TODO: JSDoc
    static FormatPath(anyPath) {
        const FormattedPath = FileSystem.__FormatPath(anyPath);
        return FormattedPath;
    }
    // TODO: JSDoc
    static GetPathFromRootDirectory(absoluteStartPath, relativeFinalPathParts) {
        const PathFromRootDirectory = FileSystem.__GetPathFromRootDirectory(absoluteStartPath, relativeFinalPathParts);
        return PathFromRootDirectory;
    }
    // TODO: JSDoc
    static DoesDirectoryExist(absolutePath) {
        const DoesDirectoryExist = FileSystem.__DoesDirectoryExist(absolutePath);
        return DoesDirectoryExist;
    }
    // TODO: JSDoc
    static DoesFileExist(absolutePath) {
        const DoesFileExist = FileSystem.__DoesFileExist(absolutePath);
        return DoesFileExist;
    }
    // TODO: JSDoc
    static IsFileReachable(absolutePath) {
        const IsFileReachable = FileSystem.__IsFileReachable(absolutePath);
        return IsFileReachable;
    }
    // TODO: JSDoc
    static IsFileReadable(absolutePath) {
        const IsFileReadable = FileSystem.__IsFileReadable(absolutePath);
        return IsFileReadable;
    }
    // TODO: JSDoc
    static IsFileWriteable(absolutePath) {
        const IsFileWriteable = FileSystem.__IsFileWriteable(absolutePath);
        return IsFileWriteable;
    }
    // TODO: JSDoc
    GetPathFromRootDirectory(relativeFinalPathParts) {
        const PathFromRootDirectory = this.__GetPathFromRootDirectory(relativeFinalPathParts);
        return PathFromRootDirectory;
    }
    // TODO: JSDoc
    DoesDirectoryExist(relativePath) {
        const DoesDirectoryExist = this.__DoesDirectoryExist(relativePath);
        return DoesDirectoryExist;
    }
    // TODO: JSDoc
    DoesFileExist(relativePath) {
        const DoesFileExist = this.__DoesFileExist(relativePath);
        return DoesFileExist;
    }
    // TODO: JSDoc
    IsFileReachable(relativePath) {
        const IsFileReachable = this.__IsFileReachable(relativePath);
        return IsFileReachable;
    }
    // TODO: JSDoc
    IsFileReadable(relativePath) {
        const IsFileReadable = this.__IsFileReadable(relativePath);
        return IsFileReadable;
    }
    // TODO: JSDoc
    IsFileWriteable(relativePath) {
        const IsFileWriteable = this.__IsFileWriteable(relativePath);
        return IsFileWriteable;
    }
    // TODO: JSDoc
    GetDepth(relativePath) {
        const MaximumFolderLevel = this.__GetDepth(relativePath);
        return MaximumFolderLevel;
    }
    // TODO: JSDoc
    GetFilesList(relativePath, pathsToInclude, pathsToExclude) {
        const FilesList = this.__GetFilesList(relativePath, pathsToInclude, pathsToExclude);
        return FilesList;
    }
    // TODO: JSDoc
    GetModel(relativePath, pathsToInclude, pathsToExclude) {
        const SourceFolderModel = this.__GetModel(relativePath, pathsToInclude, pathsToExclude);
        return SourceFolderModel;
    }
    // TODO: JSDoc
    async Import(relativePath, pathsToInclude, pathsToExclude, moduleImport) {
        await this.__Import(relativePath, pathsToInclude, pathsToExclude, moduleImport);
    }
    // TODO: JSDoc
    constructor(absolutePath) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(absolutePath, new Validator().Custom.FileSystem.Location.URL().Directory().Required().Or(new Validator().Custom.FileSystem.Location.Path().Directory().Required()));
        const FormattedAbsolutePath = FileSystem.FormatPath(absolutePath);
        Validator.Strict(FormattedAbsolutePath, new Validator().Custom.FileSystem.Entity.Directory().Required().Exist());
        this.Path = FormattedAbsolutePath;
    }
    // TODO: JSDoc
    static __FormatPath(anyPath) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(anyPath, new Validator().Default.String().Required());
        const IsPathURLBased = Validator.TypeGuard.Custom.FileSystem.IsPathURL(anyPath);
        const IsPathDefaultBased = !IsPathURLBased && Validator.TypeGuard.Custom.FileSystem.IsPath(anyPath);
        let FormattedPath = anyPath;
        if (IsPathURLBased)
            FormattedPath = GlobalModule.Dependencies.Default.Node.url.fileURLToPath(anyPath);
        if (IsPathDefaultBased)
            FormattedPath = anyPath;
        return FormattedPath;
    }
    // TODO: JSDoc
    static __GetPathFromRootDirectory(absoluteStartPath, relativeFinalPathParts) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(absoluteStartPath, new Validator().Custom.FileSystem.Location.URL().Required().Or(new Validator().Custom.FileSystem.Location.Path().Required()));
        Validator.Strict(relativeFinalPathParts, new Validator().Default.Array().Required().Of(new Validator().Default.String().Required()));
        const FormattedAbsoluteStartPath = GlobalModule.Classes.FileSystem.FormatPath(absoluteStartPath);
        Validator.Strict(FormattedAbsoluteStartPath, new Validator().Custom.FileSystem.Entity.Directory().Required().Exist().Or(new Validator().Custom.FileSystem.Entity.File().Required().Exist()));
        const RelativeFinalPath = GlobalModule.Dependencies.Default.Node.path.join(...relativeFinalPathParts);
        let StartEntityPath = FormattedAbsoluteStartPath;
        if (Validator.TypeGuard.Custom.FileSystem.IsDirectoryURL(FormattedAbsoluteStartPath) || Validator.TypeGuard.Custom.FileSystem.IsDirectoryPath(FormattedAbsoluteStartPath)) {
            StartEntityPath = FormattedAbsoluteStartPath;
        }
        else if (Validator.TypeGuard.Custom.FileSystem.IsFileURL(FormattedAbsoluteStartPath) || Validator.TypeGuard.Custom.FileSystem.IsFilePath(FormattedAbsoluteStartPath)) {
            StartEntityPath = GlobalModule.Dependencies.Default.Node.path.dirname(FormattedAbsoluteStartPath);
        }
        const AbsoluteFinalPath = GlobalModule.Dependencies.Default.Node.path.join(StartEntityPath, RelativeFinalPath);
        Validator.Strict(AbsoluteFinalPath, new Validator().Custom.FileSystem.Entity.Directory().Required().Exist().Or(new Validator().Custom.FileSystem.Entity.File().Required().Exist()));
        const AbsoluteRootDirectoryPath = GlobalModule.Classes.Process.Source.Directory.Path.Get();
        const RelativeFinalPathFromRootDirectory = GlobalModule.Dependencies.Default.Node.path.relative(AbsoluteRootDirectoryPath, AbsoluteFinalPath);
        return RelativeFinalPathFromRootDirectory;
    }
    // TODO: JSDoc
    static __DoesDirectoryExist(absolutePath) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(absolutePath, new Validator().Default.String().Required().MinLength(1));
        const FormattedPath = FileSystem.FormatPath(absolutePath);
        Validator.Strict(FormattedPath, new Validator().Custom.FileSystem.Location.Path().Required());
        const DoesDirectoryExist = GlobalModule.Dependencies.Default.Node.fs.existsSync(FormattedPath);
        return DoesDirectoryExist;
    }
    // TODO: JSDoc
    static __DoesFileExist(absolutePath) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(absolutePath, new Validator().Default.String().Required().MinLength(1));
        const FormattedPath = FileSystem.FormatPath(absolutePath);
        Validator.Strict(FormattedPath, new Validator().Custom.FileSystem.Location.Path().Required());
        const DoesFileExist = GlobalModule.Dependencies.Default.Node.fs.existsSync(FormattedPath);
        return DoesFileExist;
    }
    // TODO: JSDoc
    static __IsFileReachable(absolutePath) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(absolutePath, new Validator().Default.String().Required().MinLength(1));
        const FormattedPath = FileSystem.FormatPath(absolutePath);
        Validator.Strict(FormattedPath, new Validator().Custom.FileSystem.Location.Path().Required());
        const DoesFileExist = FileSystem.DoesFileExist(absolutePath);
        let IsFileReachable = false;
        if (DoesFileExist) {
            try {
                GlobalModule.Dependencies.Default.Node.fs.accessSync(FormattedPath, GlobalModule.Dependencies.Default.Node.fs.constants.F_OK);
                IsFileReachable = true;
            }
            catch (e) {
                IsFileReachable = false;
            }
        }
        return IsFileReachable;
    }
    // TODO: JSDoc
    static __IsFileReadable(absolutePath) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(absolutePath, new Validator().Default.String().Required().MinLength(1));
        const FormattedPath = FileSystem.FormatPath(absolutePath);
        Validator.Strict(FormattedPath, new Validator().Custom.FileSystem.Location.Path().Required());
        const DoesFileExist = FileSystem.DoesFileExist(absolutePath);
        const IsFileReachable = DoesFileExist && FileSystem.IsFileReachable(absolutePath);
        let IsFileReadable = false;
        if (IsFileReachable) {
            try {
                GlobalModule.Dependencies.Default.Node.fs.accessSync(FormattedPath, GlobalModule.Dependencies.Default.Node.fs.constants.R_OK);
                IsFileReadable = true;
            }
            catch (e) {
                IsFileReadable = false;
            }
        }
        return IsFileReadable;
    }
    // TODO: JSDoc
    static __IsFileWriteable(absolutePath) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(absolutePath, new Validator().Default.String().Required().MinLength(1));
        const FormattedPath = FileSystem.FormatPath(absolutePath);
        Validator.Strict(FormattedPath, new Validator().Custom.FileSystem.Location.Path().Required());
        const DoesFileExist = FileSystem.DoesFileExist(absolutePath);
        const IsFileReachable = DoesFileExist && FileSystem.IsFileReachable(absolutePath);
        let IsFileWriteable = false;
        if (IsFileReachable) {
            try {
                GlobalModule.Dependencies.Default.Node.fs.accessSync(FormattedPath, GlobalModule.Dependencies.Default.Node.fs.constants.W_OK);
                IsFileWriteable = true;
            }
            catch (e) {
                IsFileWriteable = false;
            }
        }
        return IsFileWriteable;
    }
    // TODO: JSDoc
    __GetPathFromRootDirectory(relativeFinalPathParts) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(relativeFinalPathParts, new Validator().Default.Array().Required().Of(new Validator().Default.String().Required()));
        const FormattedAbsoluteStartPath = this.Path;
        const RelativeFinalPath = GlobalModule.Dependencies.Default.Node.path.join(...relativeFinalPathParts);
        let StartEntityPath = FormattedAbsoluteStartPath;
        if (Validator.TypeGuard.Custom.FileSystem.IsDirectoryURL(FormattedAbsoluteStartPath) || Validator.TypeGuard.Custom.FileSystem.IsDirectoryPath(FormattedAbsoluteStartPath)) {
            StartEntityPath = FormattedAbsoluteStartPath;
        }
        else if (Validator.TypeGuard.Custom.FileSystem.IsFileURL(FormattedAbsoluteStartPath) || Validator.TypeGuard.Custom.FileSystem.IsFilePath(FormattedAbsoluteStartPath)) {
            StartEntityPath = GlobalModule.Dependencies.Default.Node.path.dirname(FormattedAbsoluteStartPath);
        }
        const AbsoluteFinalPath = GlobalModule.Dependencies.Default.Node.path.join(StartEntityPath, RelativeFinalPath);
        Validator.Strict(AbsoluteFinalPath, new Validator().Custom.FileSystem.Entity.Directory().Required().Exist().Or(new Validator().Custom.FileSystem.Entity.File().Required().Exist()));
        const AbsoluteRootDirectoryPath = GlobalModule.Classes.Process.Source.Directory.Path.Get();
        const RelativeFinalPathFromRootDirectory = GlobalModule.Dependencies.Default.Node.path.relative(AbsoluteRootDirectoryPath, AbsoluteFinalPath);
        return RelativeFinalPathFromRootDirectory;
    }
    // TODO: JSDoc
    __DoesDirectoryExist(relativePath) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(relativePath, new Validator().Default.String().Required());
        const AbsolutePath = GlobalModule.Dependencies.Default.Node.path.join(this.Path, relativePath);
        Validator.Strict(AbsolutePath, new Validator().Custom.FileSystem.Location.Path().Directory().Required());
        const DoesDirectoryExist = FileSystem.DoesDirectoryExist(AbsolutePath);
        return DoesDirectoryExist;
    }
    // TODO: JSDoc
    __DoesFileExist(relativePath) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(relativePath, new Validator().Default.String().Required());
        const AbsolutePath = GlobalModule.Dependencies.Default.Node.path.join(this.Path, relativePath);
        Validator.Strict(AbsolutePath, new Validator().Custom.FileSystem.Location.Path().File().Required());
        const DoesFileExist = FileSystem.DoesFileExist(AbsolutePath);
        return DoesFileExist;
    }
    // TODO: JSDoc
    __IsFileReachable(relativePath) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(relativePath, new Validator().Default.String().Required());
        const AbsolutePath = GlobalModule.Dependencies.Default.Node.path.join(this.Path, relativePath);
        Validator.Strict(AbsolutePath, new Validator().Custom.FileSystem.Location.Path().File().Required());
        const IsFileReachable = FileSystem.IsFileReachable(AbsolutePath);
        return IsFileReachable;
    }
    // TODO: JSDoc
    __IsFileReadable(relativePath) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(relativePath, new Validator().Default.String().Required());
        const AbsolutePath = GlobalModule.Dependencies.Default.Node.path.join(this.Path, relativePath);
        Validator.Strict(AbsolutePath, new Validator().Custom.FileSystem.Location.Path().File().Required());
        const IsFileReadable = FileSystem.IsFileReadable(AbsolutePath);
        return IsFileReadable;
    }
    // TODO: JSDoc
    __IsFileWriteable(relativePath) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(relativePath, new Validator().Default.String().Required());
        const AbsolutePath = GlobalModule.Dependencies.Default.Node.path.join(this.Path, relativePath);
        Validator.Strict(AbsolutePath, new Validator().Custom.FileSystem.Location.Path().File().Required());
        const IsFileWriteable = FileSystem.IsFileWriteable(AbsolutePath);
        return IsFileWriteable;
    }
    // TODO: JSDoc
    __GetDepth(relativePath) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(relativePath, new Validator().Default.String().Required());
        const FoldersList = this.__GetFoldersList(relativePath, [[/.*/]], []);
        const MaximumFolderLevel = Math.max(...FoldersList.map((_el, _ind, _arr) => _el.Level));
        return MaximumFolderLevel;
    }
    // TODO: JSDoc
    __GetFilesList(relativePath, pathsToInclude, pathsToExclude) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(relativePath, new Validator().Default.String().Required());
        Validator.Strict(pathsToInclude, new Validator().Default.Array().Required().Of(new Validator().Default.Array().Required().Of(new Validator().Default.RegExp().Required())));
        Validator.Strict(pathsToExclude, new Validator().Default.Array().Required().Of(new Validator().Default.Array().Required().Of(new Validator().Default.RegExp().Required())));
        const FormPathPattern = (paths) => new RegExp(`^(?:${paths.map((_el, _ind, _arr) => _el.source).join(`\\${GlobalModule.Dependencies.Default.Node.path.sep}`)})$`);
        const IncludedPathsPatterns = pathsToInclude.map((_el, _ind, _arr) => FormPathPattern(_el));
        const ExcludedPathsPatterns = pathsToExclude.map((_el, _ind, _arr) => FormPathPattern(_el));
        const FoldersList = this.__GetFoldersList(relativePath, [[/.*/]], []);
        const FilesList = FoldersList.map((_el, _ind, _arr) => _el.Files.filter((__el, __ind, __arr) => {
            const IsPathToBeIncluded = IncludedPathsPatterns.some((___el, ___ind, ___arr) => ___el.test(__el.Path.Absolute) || ___el.test(__el.Path.Relative));
            const IsPathToBeExcluded = ExcludedPathsPatterns.some((___el, ___ind, ___arr) => ___el.test(__el.Path.Absolute) || ___el.test(__el.Path.Relative));
            const IsPathToBeIgnored = !IsPathToBeIncluded || IsPathToBeExcluded;
            return !IsPathToBeIgnored;
        }).map((__el, __ind, __arr) => __el.Path.Absolute)).reduce((_prev, _curr, _currInd, _arr) => [..._prev, ..._curr], []);
        return FilesList;
    }
    // TODO: JSDoc
    __GetModel(relativePath, pathsToInclude, pathsToExclude) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(relativePath, new Validator().Default.String().Required());
        Validator.Strict(pathsToInclude, new Validator().Default.Array().Required().Of(new Validator().Default.Array().Required().Of(new Validator().Default.RegExp().Required())));
        Validator.Strict(pathsToExclude, new Validator().Default.Array().Required().Of(new Validator().Default.Array().Required().Of(new Validator().Default.RegExp().Required())));
        const AbsolutePath = GlobalModule.Dependencies.Default.Node.path.join(this.Path, relativePath);
        Validator.Strict(AbsolutePath, new Validator().Custom.FileSystem.Location.Path().Directory().Required());
        const IsSourceFolder = (absPath) => absPath === AbsolutePath;
        const FoldersList = this.__GetFoldersList(relativePath, pathsToInclude, pathsToExclude);
        const MaximumFolderLevel = this.__GetDepth(relativePath);
        const GetFoldersListByLevel = (level, nextLevelModel) => {
            const FoldersByCurrentLevel = FoldersList.filter((_el, _ind, _arr) => _el.Level === level);
            const FoldersListByLevel = [];
            for (let i = 0; i < FoldersByCurrentLevel.length; i++) {
                const CurrentFolder = FoldersByCurrentLevel[i];
                const SubFoldersForCurrentFolder = nextLevelModel.filter((_el, _ind, _arr) => _el.Path.Absolute === GlobalModule.Dependencies.Default.Node.path.join(CurrentFolder.Path.Absolute, _el.Name));
                const CurrentFolderModel = {
                    Name: CurrentFolder.Name,
                    Path: {
                        Absolute: CurrentFolder.Path.Absolute,
                        Relative: CurrentFolder.Path.Relative,
                    },
                    Size: CurrentFolder.Size + SubFoldersForCurrentFolder.reduce((_prev, _curr, _currInd, _arr) => _prev + _curr.Size, 0),
                    Level: CurrentFolder.Level,
                    Context: {
                        Folders: SubFoldersForCurrentFolder.length + SubFoldersForCurrentFolder.reduce((_prev, _curr, _currInd, _arr) => _prev + _curr.Context.Folders, 0),
                        Files: CurrentFolder.Files.length + SubFoldersForCurrentFolder.reduce((_prev, _curr, _currInd, _arr) => _prev + _curr.Context.Files, 0),
                    },
                    Files: [...SubFoldersForCurrentFolder, ...CurrentFolder.Files],
                };
                FoldersListByLevel.push(CurrentFolderModel);
            }
            return FoldersListByLevel;
        };
        const GetFoldersLevelModel = (level) => {
            const IsCurrentFoldersLevelMaximum = level === MaximumFolderLevel;
            const NextFoldersLevel = level + 1;
            const FoldersByNextLevel = IsCurrentFoldersLevelMaximum ? [] : GetFoldersLevelModel(NextFoldersLevel);
            const CurrentFoldersLevelModel = GetFoldersListByLevel(level, FoldersByNextLevel);
            return CurrentFoldersLevelModel;
        };
        const SourceFolder = FoldersList.find((_el, _ind, _arr) => _el.Level === 0 && IsSourceFolder(_el.Path.Absolute));
        const FirstLevelFoldersModel = GetFoldersLevelModel(1);
        const SourceFolderModel = {
            Name: SourceFolder.Name,
            Path: {
                Absolute: SourceFolder.Path.Absolute,
                Relative: SourceFolder.Path.Relative,
            },
            Size: SourceFolder.Size + FirstLevelFoldersModel.reduce((_prev, _curr, _currInd, _arr) => _prev + _curr.Size, 0),
            Level: SourceFolder.Level,
            Context: {
                Folders: FirstLevelFoldersModel.length + FirstLevelFoldersModel.reduce((_prev, _curr, _currInd, _arr) => _prev + _curr.Context.Folders, 0),
                Files: SourceFolder.Files.length + FirstLevelFoldersModel.reduce((_prev, _curr, _currInd, _arr) => _prev + _curr.Context.Files, 0),
            },
            Files: [...FirstLevelFoldersModel, ...SourceFolder.Files],
        };
        return SourceFolderModel;
    }
    // TODO: JSDoc
    async __Import(relativePath, pathsToInclude, pathsToExclude, moduleImport) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(relativePath, new Validator().Default.String().Required());
        Validator.Strict(pathsToInclude, new Validator().Default.Array().Required().Of(new Validator().Default.Array().Required().Of(new Validator().Default.RegExp().Required())));
        Validator.Strict(pathsToExclude, new Validator().Default.Array().Required().Of(new Validator().Default.Array().Required().Of(new Validator().Default.RegExp().Required())));
        Validator.Strict(moduleImport, new Validator().Default.Function().Required());
        const FilesToImport = this.__GetFilesList(relativePath, pathsToInclude, pathsToExclude);
        const ImportFile = async (filePath) => {
            const FileAbsolutePath = filePath;
            const FileAbsoluteURL = GlobalModule.Dependencies.Default.Node.url.pathToFileURL(FileAbsolutePath).href;
            const FileName = GlobalModule.Dependencies.Default.Node.path.basename(FileAbsolutePath);
            let ImportedModule = undefined;
            const ProcessPlatformType = GlobalModule.Classes.Process.Platform.Type;
            try {
                if (ProcessPlatformType === `win32`) {
                    ImportedModule = await import(FileAbsoluteURL);
                    // const CurrentFileAbsolutePath = FileSystem.FormatPath(import.meta.url)
                    // const FileRelativePath = GlobalModule.Dependencies.Default.Node.path.relative(CurrentFileAbsolutePath, FileAbsolutePath)
                    // ImportedModule = await import(FileRelativePath)
                }
                else if (ProcessPlatformType === `linux`) {
                    ImportedModule = await import(FileAbsolutePath);
                }
                GlobalModule.Classes.Console.Log.Preset.Info(`Файл '${FileName}' (${FileAbsolutePath}) был динамически подключен для выполнения`);
            }
            catch (ImportError) {
                GlobalModule.Classes.Console.Log.Preset.Warn(`При динамическом подключении файла '${FileName}' (${FileAbsolutePath}) произошла непредвиденная ошибка`);
                const IsImportErrorOccured = Validator.TypeGuard.Default.IsError(ImportError);
                if (IsImportErrorOccured) {
                    GlobalModule.Classes.Console.Log.Preset.Error(ImportError, false);
                }
            }
            await moduleImport(ImportedModule, FileAbsolutePath);
        };
        await Promise.all(FilesToImport.map((_el, _ind, _arr) => ImportFile(_el)));
    }
    // TODO: JSDoc
    __GetFoldersList(relativePath, pathsToInclude, pathsToExclude) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(relativePath, new Validator().Default.String().Required());
        Validator.Strict(pathsToInclude, new Validator().Default.Array().Required().Of(new Validator().Default.Array().Required().Of(new Validator().Default.RegExp().Required())));
        Validator.Strict(pathsToExclude, new Validator().Default.Array().Required().Of(new Validator().Default.Array().Required().Of(new Validator().Default.RegExp().Required())));
        const AbsolutePath = GlobalModule.Dependencies.Default.Node.path.join(this.Path, relativePath);
        Validator.Strict(AbsolutePath, new Validator().Custom.FileSystem.Location.Path().Directory().Required());
        const IsSourceFolder = (absPath) => absPath === AbsolutePath;
        const FormPathPattern = (paths) => new RegExp(`^(?:${paths.map((_el, _ind, _arr) => _el.source).join(`\\${GlobalModule.Dependencies.Default.Node.path.sep}`)})$`);
        const IncludedPathsPatterns = pathsToInclude.map((_el, _ind, _arr) => FormPathPattern(_el));
        const ExcludedPathsPatterns = pathsToExclude.map((_el, _ind, _arr) => FormPathPattern(_el));
        const FolderList = [];
        const FormFolderStructure = (relPath) => {
            const FolderAbsolutePath = GlobalModule.Dependencies.Default.Node.path.join(AbsolutePath, relPath);
            const FolderRelativePath = GlobalModule.Dependencies.Default.Node.path.relative(AbsolutePath, FolderAbsolutePath);
            const FolderFileNames = GlobalModule.Dependencies.Default.Node.fs.readdirSync(FolderAbsolutePath);
            const FolderFileStructures = [];
            for (let i = 0; i < FolderFileNames.length; i++) {
                const FolderFileName = FolderFileNames[i];
                const FolderFileAbsolutePath = GlobalModule.Dependencies.Default.Node.path.join(FolderAbsolutePath, FolderFileName);
                const FolderFileRelativePath = GlobalModule.Dependencies.Default.Node.path.relative(AbsolutePath, FolderFileAbsolutePath);
                const ParsedFolderFile = GlobalModule.Dependencies.Default.Node.path.parse(FolderFileAbsolutePath);
                const FolderFile = GlobalModule.Dependencies.Default.Node.fs.lstatSync(FolderFileAbsolutePath);
                const IsFolderFileANewSubFolder = FolderFile.isDirectory();
                const IsPathToBeIncluded = IncludedPathsPatterns.some((_el, _ind, _arr) => _el.test(FolderFileAbsolutePath) || _el.test(FolderFileRelativePath));
                const IsPathToBeExcluded = ExcludedPathsPatterns.some((_el, _ind, _arr) => _el.test(FolderFileAbsolutePath) || _el.test(FolderFileRelativePath));
                const IsPathToBeIgnored = !IsPathToBeIncluded || IsPathToBeExcluded;
                if (!IsPathToBeIgnored) {
                    if (IsFolderFileANewSubFolder) {
                        FormFolderStructure(GlobalModule.Dependencies.Default.Node.path.join(FolderRelativePath, FolderFileName));
                    }
                    else {
                        const FolderFileStructure = {
                            Base: ParsedFolderFile.base,
                            Name: ParsedFolderFile.name,
                            Extension: ParsedFolderFile.ext,
                            Path: {
                                Absolute: FolderFileAbsolutePath,
                                Relative: FolderFileRelativePath,
                            },
                            Size: FolderFile.size,
                        };
                        FolderFileStructures.push(FolderFileStructure);
                    }
                }
            }
            const IsFolderFirst = IsSourceFolder(FolderAbsolutePath);
            const FolderStructure = {
                Name: GlobalModule.Dependencies.Default.Node.path.basename(FolderAbsolutePath),
                Path: {
                    Absolute: FolderAbsolutePath,
                    Relative: FolderRelativePath,
                },
                Size: FolderFileStructures.reduce((_prev, _curr, _currInd, _arr) => _prev + _curr.Size, 0),
                Level: IsFolderFirst ? 0 : FolderRelativePath.split(GlobalModule.Dependencies.Default.Node.path.sep).length,
                Context: {
                    Files: FolderFileStructures.length,
                },
                Files: FolderFileStructures,
            };
            FolderList.push(FolderStructure);
        };
        FormFolderStructure(`./`);
        return FolderList;
    }
}
//# sourceMappingURL=FileSystem.js.map