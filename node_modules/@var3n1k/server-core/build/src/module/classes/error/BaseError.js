import * as GlobalModule from '../../@module.js';
class BaseError extends globalThis.Error {
    // TODO: JSDoc
    static Pattern = {
        StackTrace: {
            Row: {
                RegExp: /(?:[\s]*at[\s]*)(.+)/,
                Group: { Content: 1 },
            },
            Cause: {
                RegExp: /(?:(async)[\s]+)?(?:(.+?)[\s]+\()?(?:(.+?):([\d]+)(?::([\d]+))?|([^)]+))\)?/,
                Group: { File: { Path: 3 }, Cause: { Script: { Asynchronous: 1, Name: 2 }, Coordinates: { Line: 4, Column: 5 } } },
            },
        },
    };
    // TODO: JSDoc
    Tag;
    // TODO: JSDoc
    TagColor;
    // TODO: JSDoc
    Code;
    // TODO: JSDoc
    CodeName;
    // TODO: JSDoc
    CodeNameColor;
    // TODO: JSDoc
    Message;
    // TODO: JSDoc
    _StackTrace;
    // TODO: JSDoc
    static get CurrentStackTrace() {
        const Validator = GlobalModule.Classes.Validator;
        const SubError = new globalThis.Error();
        Error.stackTraceLimit = Infinity;
        Error.captureStackTrace(SubError);
        const NewStackTrace = SubError.stack;
        const NewStackTraceToArray = [];
        if (Validator.TypeGuard.Default.IsString(NewStackTrace)) {
            if (!Validator.TypeGuard.Default.IsEmptyString(NewStackTrace)) {
                GlobalModule.Functions.Parameter.Type.Manager.Default.Array.Clear(NewStackTraceToArray);
                NewStackTraceToArray.push(...NewStackTrace.split(/\n/));
            }
        }
        const StackTraceRows = NewStackTraceToArray;
        StackTraceRows.shift();
        return StackTraceRows;
    }
    // TODO: JSDoc
    static GetCauseTraceFromFile(absoluteFilePath, line, column, traceSize) {
        const CauseTraceFromFile = BaseError.__GetCauseTraceFromFile(absoluteFilePath, line, column, traceSize);
        return CauseTraceFromFile;
    }
    // TODO: JSDoc
    FormOutput() {
        const Output = this.__FormOutput();
        return Output;
    }
    // TODO: JSDoc
    constructor(tag = `BaseError`, tagColor, code = -1, codeName = `UNKNOWN`, codeNameColor, inherittedStackTrace, message) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(tag, new Validator().Default.String().Required().MinLength(1));
        Validator.Strict(tagColor, new Validator().Custom.Color.RGB().Required());
        Validator.Strict(code, new Validator().Default.Numeric().Number().Required().Integer());
        Validator.Strict(codeName, new Validator().Default.String().Required().MinLength(1));
        Validator.Strict(codeNameColor, new Validator().Custom.Color.RGB().Required());
        Validator.Strict(inherittedStackTrace, new Validator().Default.String());
        Validator.Strict(message, new Validator().Default.Array().Required());
        const InherittedStackTraceToArray = [];
        if (Validator.TypeGuard.Default.IsString(inherittedStackTrace)) {
            if (!Validator.TypeGuard.Default.IsEmptyString(inherittedStackTrace)) {
                GlobalModule.Functions.Parameter.Type.Manager.Default.Array.Clear(InherittedStackTraceToArray);
                InherittedStackTraceToArray.push(...inherittedStackTrace.split(/\n/));
            }
        }
        super();
        this.Tag = tag;
        this.TagColor = tagColor;
        this.Code = code;
        this.CodeName = codeName;
        this.CodeNameColor = codeNameColor;
        this.Message = message;
        // const ThisStackTrace = BaseError.CurrentStackTrace
        // ThisStackTrace.shift()
        this._StackTrace = {
            Depth: 0,
            List: {
                Inheritted: InherittedStackTraceToArray,
            },
        };
        // this.name
        // this.message = this.Message.map((_el, _ind, _arr) => String(_el)).join(` `)
        // this.cause
        // this.stack
    }
    // TODO: JSDoc
    static __GetCauseTraceFromFile(absoluteFilePath, line, column, traceSize) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(absoluteFilePath, new Validator().Custom.FileSystem.Location.URL().File().Required().Or(new Validator().Custom.FileSystem.Location.Path().File().Required()));
        Validator.Strict(traceSize, new Validator().Default.Numeric().Number().Required().Integer().Min(1));
        const FormattedAbsoluteFilePath = GlobalModule.Classes.FileSystem.FormatPath(absoluteFilePath);
        Validator.Strict(FormattedAbsoluteFilePath, new Validator().Custom.FileSystem.Entity.File().Required().Exist().Reachable().Readable());
        const FileContentLines = GlobalModule.Dependencies.Default.Node.fs.readFileSync(FormattedAbsoluteFilePath).toString().split(/\n/);
        const FileContentLinesLength = FileContentLines.length;
        Validator.Strict(line, new Validator().Default.Numeric().Number().Required().Integer().Min(1).Max(FileContentLinesLength));
        const MaximumFileContentLineLength = Math.max(...FileContentLines.map((_el, _ind, _arr) => _el.length));
        const FileContentCauseLineLength = FileContentLines[line - 1].length;
        Validator.Strict(column, new Validator().Default.Numeric().Number().Required().Integer().Min(1).Max(FileContentCauseLineLength));
        const StringManager = GlobalModule.Functions.Parameter.Type.Manager.Default.String;
        const ColorManager = GlobalModule.Functions.Parameter.Type.Manager.Custom.Color;
        const StringJustifier = StringManager.Justify;
        const StringStylizator = StringManager.Style;
        const StringInscriptionModifier = StringStylizator.Modify.Inscription;
        const SourceCodePrefix = {
            MainLine: `  ► `,
            MainColumn: {
                FromUp: `▼`,
                FromDown: `▲`,
            },
        };
        const SourceCodeLineSeparator = `${``.padStart(1, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default)}|`;
        const CauseTraceFromTop = GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.ToRange(Math.floor((traceSize - 1) * (1 / 2)), 0, undefined);
        const CauseTraceStartLine = GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.ToRange(line - CauseTraceFromTop, 1, undefined);
        const CauseTraceEndLine = GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.ToRange(CauseTraceStartLine + (traceSize - 1), 1, FileContentLinesLength);
        const MaximumCauseTraceLineNumberLength = `${CauseTraceEndLine}`.length;
        const MaximumCauseTraceMarginSize = SourceCodePrefix.MainLine.length + MaximumCauseTraceLineNumberLength + SourceCodeLineSeparator.length;
        const MaximumConsoleColumnsSize = GlobalModule.Classes.Console.Size.Width - 5;
        const MaximumCauseTraceLineLength = MaximumConsoleColumnsSize - MaximumCauseTraceMarginSize - 2;
        const CauseTraceStartColumn = GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.ToRange(column - Math.floor((MaximumCauseTraceLineLength - 1) / 2), 1, undefined);
        const CauseTraceLimits = {
            Line: {
                Start: CauseTraceStartLine,
                End: CauseTraceEndLine,
            },
            Column: {
                Start: CauseTraceStartColumn,
                End: GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.ToRange(CauseTraceStartColumn + (MaximumCauseTraceLineLength - 1), 1, MaximumFileContentLineLength),
            },
        };
        const MappedCauseTrace = FileContentLines.map((_el, _ind, _arr) => {
            const MappedFileContentLine = { Number: _ind + 1, Content: _el };
            return MappedFileContentLine;
        }).slice(CauseTraceLimits.Line.Start - 1, CauseTraceLimits.Line.End);
        const MaximumMappedCauseTraceLineNumber = Math.max(...MappedCauseTrace.map((_el, _ind, _arr) => _el.Number));
        const PartlyInvisible = (text) => StringInscriptionModifier(text, StringInscriptionModifier.Type.Dim); // StringColorModifier.Text(text, ...ColorManager.HEXToRGB(`#666666`))
        const SourceCodeTraceLines = MappedCauseTrace.map((_el, _ind, _arr) => {
            const InitialSourceCodeText = _el.Content.replace(/\t/g, ``.padStart(4, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default)).replace(/\r/g, ``);
            const InitialSourceCodeTextStartIndex = CauseTraceLimits.Column.Start - 1;
            const InitialSourceCodeTextEndIndex = CauseTraceLimits.Column.End;
            const IsInitialSourceCodeTextMoreThanMaximumLength = InitialSourceCodeText.length > InitialSourceCodeTextEndIndex;
            const BaseSourceCodeTex = InitialSourceCodeText.slice(InitialSourceCodeTextStartIndex, InitialSourceCodeTextEndIndex);
            const ShortenSourceCodeText = `${InitialSourceCodeText.slice(InitialSourceCodeTextStartIndex, InitialSourceCodeTextEndIndex - 5)}...`;
            const SourceCodeText = IsInitialSourceCodeTextMoreThanMaximumLength ? ShortenSourceCodeText : BaseSourceCodeTex;
            const ColoredSourceCodeText = SourceCodeText; // StringColorModifier.Text(SourceCodeText, ...ColorManager.HEXToRGB(``))
            const ColoredLineNumber = PartlyInvisible(`${_el.Number}`);
            const ColoredLineSeparator = PartlyInvisible(SourceCodeLineSeparator);
            const ColoredMainLinePrefix = PartlyInvisible(SourceCodePrefix.MainLine);
            const ColoredMainColumnPrefixFromUp = PartlyInvisible(SourceCodePrefix.MainColumn.FromUp);
            const ColoredMainColumnPrefixFromDown = PartlyInvisible(SourceCodePrefix.MainColumn.FromDown);
            let FixedSourceCodeLine = `${ColoredSourceCodeText}`;
            if (_el.Number < line) {
                FixedSourceCodeLine = `${ColoredSourceCodeText}`;
            }
            else if (_el.Number === line) {
                const SourceCodeTopLine = StringJustifier(ColoredMainColumnPrefixFromUp, column, StringJustifier.Type.Right);
                const SourceCodeBottomLine = StringJustifier(ColoredMainColumnPrefixFromDown, column, StringJustifier.Type.Right);
                FixedSourceCodeLine = `${SourceCodeTopLine}\n${ColoredSourceCodeText}\n${SourceCodeBottomLine}`;
            }
            else if (_el.Number > line) {
                FixedSourceCodeLine = `${ColoredSourceCodeText}`;
            }
            let FixedSourceCodeLinePrefix = `${ColoredMainLinePrefix}${ColoredLineNumber}`;
            if (_el.Number < line) {
                const SourceCodeLinePrefixLength = `${MaximumMappedCauseTraceLineNumber}`.length + SourceCodePrefix.MainLine.length;
                FixedSourceCodeLinePrefix = `${StringJustifier(ColoredLineNumber, SourceCodeLinePrefixLength, StringJustifier.Type.Right)}${ColoredLineSeparator}`;
            }
            else if (_el.Number === line) {
                const SourceCodeTopLinePrefixLength = `${MaximumMappedCauseTraceLineNumber}`.length + SourceCodePrefix.MainLine.length;
                const SourceCodePrefixTopLine = `${``.padStart(SourceCodeTopLinePrefixLength, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default)}${ColoredLineSeparator}`;
                const SourceCodeBottomLinePrefixLength = `${MaximumMappedCauseTraceLineNumber}`.length + SourceCodePrefix.MainLine.length;
                const SourceCodePrefixBottomLine = `${``.padStart(SourceCodeBottomLinePrefixLength, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default)}${ColoredLineSeparator}`;
                const SourceCodeLinePrefixLength = `${MaximumMappedCauseTraceLineNumber}`.length;
                const SourceCodeLinePrefix = `${ColoredMainLinePrefix}${StringJustifier(ColoredLineNumber, SourceCodeLinePrefixLength, StringJustifier.Type.Right)}${ColoredLineSeparator}`;
                FixedSourceCodeLinePrefix = `${SourceCodePrefixTopLine}\n${SourceCodeLinePrefix}\n${SourceCodePrefixBottomLine}`;
            }
            else if (_el.Number > line) {
                const SourceCodeLinePrefixLength = `${MaximumMappedCauseTraceLineNumber}`.length + SourceCodePrefix.MainLine.length;
                FixedSourceCodeLinePrefix = `${StringJustifier(ColoredLineNumber, SourceCodeLinePrefixLength, StringJustifier.Type.Right)}${ColoredLineSeparator}`;
            }
            const SourceCodeTraceLine = {
                Prefix: FixedSourceCodeLinePrefix,
                Content: FixedSourceCodeLine,
            };
            return SourceCodeTraceLine;
        });
        const SourceCodeTraceLinesToString = SourceCodeTraceLines.map((_el, _ind, _arr) => _el.Content).join(`\n`);
        const SourceCodeTraceLinePrefixesToString = SourceCodeTraceLines.map((_el, _ind, _arr) => _el.Prefix).join(`\n`);
        const SourceCodeBackgroundColor = undefined; // #0B0A0B // #1F1E1F // #011E33
        const SourceCodeTextColor = undefined;
        const SourceCode = GlobalModule.Functions.Table(0, {
            Sign: {
                Vertical: { Double: false },
                Horizontal: { Double: false },
            },
            Visible: true,
            Color: {
                Entity: ColorManager.HEXToRGB(GlobalModule.DataSet.Constants.Custom.Color.HEX.Custom.Console.Element.Default.Message),
                Background: undefined,
            },
        }, [
            {
                FootNote: {
                    Left: {
                        Text: SourceCodeTraceLinePrefixesToString,
                        Color: {
                            Entity: undefined,
                            Background: undefined,
                        },
                    },
                    Right: {
                        Text: ``,
                        Color: {
                            Entity: undefined,
                            Background: undefined,
                        },
                    },
                },
                Cells: [
                    {
                        Width: MaximumCauseTraceLineLength,
                        Padding: { Top: 0, Left: 0, Bottom: 0, Right: 0 },
                        JustifyType: GlobalModule.Functions.Table.Row.Cell.Justify.Type.Left,
                        Content: {
                            Text: SourceCodeTraceLinesToString,
                            Color: {
                                Entity: SourceCodeTextColor,
                                Background: SourceCodeBackgroundColor,
                            },
                        },
                    },
                ],
            },
        ]);
        return SourceCode;
    }
    // TODO: JSDoc
    static __FormStackTraceRows(initialStackTraceRows) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(initialStackTraceRows, new Validator().Default.Array().Required().Of(new Validator().Default.String().Required()));
        const FilteredStackTraceRows = initialStackTraceRows
            .filter((_el, _ind, _arr) => {
            const IsStackTraceRowValid = new RegExp(`^${BaseError.Pattern.StackTrace.Row.RegExp.source}$`, undefined).test(_el);
            return IsStackTraceRowValid;
        })
            .map((_el, _ind, _arr) => _el.split(new RegExp(`^${BaseError.Pattern.StackTrace.Row.RegExp.source}$`, undefined))[BaseError.Pattern.StackTrace.Row.Group.Content]);
        const StackTraceEntities = FilteredStackTraceRows.filter((_el, _ind, _arr) => {
            const IsStackTraceCauseValid = new RegExp(`^${BaseError.Pattern.StackTrace.Cause.RegExp.source}$`, undefined).test(_el);
            if (IsStackTraceCauseValid) {
                const StackTraceCauseParts = new RegExp(`^${BaseError.Pattern.StackTrace.Cause.RegExp.source}$`, undefined).exec(_el);
                const MainStackTraceCauseGroups = [
                    BaseError.Pattern.StackTrace.Cause.Group.File.Path,
                    BaseError.Pattern.StackTrace.Cause.Group.Cause.Coordinates.Column,
                    BaseError.Pattern.StackTrace.Cause.Group.Cause.Coordinates.Line,
                ];
                const IsStackTraceCauseFull = MainStackTraceCauseGroups.every((_el, _ind, _arr) => {
                    const IsStackTraceCausePartValid = Validator.Soft(StackTraceCauseParts[_el], new Validator().Default.String().Required().MinLength(1)).Status;
                    return IsStackTraceCausePartValid;
                });
                if (IsStackTraceCauseFull) {
                    const StackTraceCauseFilePath = GlobalModule.Classes.FileSystem.FormatPath(StackTraceCauseParts[BaseError.Pattern.StackTrace.Cause.Group.File.Path]);
                    const IsStackTraceCauseFilePathValid = Validator.TypeGuard.Custom.FileSystem.IsFilePath(StackTraceCauseFilePath);
                    const DoesStackTraceCauseFilePathExist = IsStackTraceCauseFilePathValid && GlobalModule.Classes.FileSystem.DoesFileExist(StackTraceCauseFilePath);
                    const IsStackTraceCauseValid = IsStackTraceCauseFilePathValid && DoesStackTraceCauseFilePathExist;
                    return IsStackTraceCauseValid;
                }
                else {
                    const IsStackTraceCauseValid = IsStackTraceCauseFull;
                    return IsStackTraceCauseValid;
                }
            }
            else {
                return IsStackTraceCauseValid;
            }
        }).map((_el, _ind, _arr) => {
            const StackTraceCauseParts = new RegExp(`^${BaseError.Pattern.StackTrace.Cause.RegExp.source}$`, undefined).exec(_el);
            const RootFileAbsolutePath = GlobalModule.Classes.FileSystem.FormatPath(GlobalModule.Classes.Process.Source.File.Path.Get());
            const StackTraceFileSource = StackTraceCauseParts[BaseError.Pattern.StackTrace.Cause.Group.File.Path];
            const StackTraceFilePath = GlobalModule.Classes.FileSystem.FormatPath(StackTraceFileSource);
            const StackTraceCauseAsyncScriptPrefix = StackTraceCauseParts[BaseError.Pattern.StackTrace.Cause.Group.Cause.Script.Asynchronous];
            const IsStackTraceCauseScriptAsync = Validator.TypeGuard.Default.IsString(StackTraceCauseAsyncScriptPrefix) && !Validator.TypeGuard.Default.IsEmptyString(StackTraceCauseAsyncScriptPrefix);
            const GetFixedStackTraceCauseScriptName = (initialScriptName) => {
                const DoesInitialStackTraceCauseScriptNameExist = Validator.TypeGuard.Default.IsString(initialScriptName) && !Validator.TypeGuard.Default.IsEmptyString(initialScriptName);
                let FixedStackTraceCauseScriptName;
                if (DoesInitialStackTraceCauseScriptNameExist)
                    FixedStackTraceCauseScriptName = initialScriptName;
                else {
                    if (StackTraceFilePath === RootFileAbsolutePath) {
                        FixedStackTraceCauseScriptName = `<Main Module>`;
                    }
                    else {
                        FixedStackTraceCauseScriptName = `<Anonymous Function>`;
                    }
                }
                if (IsStackTraceCauseScriptAsync)
                    FixedStackTraceCauseScriptName = `async ${FixedStackTraceCauseScriptName}`;
                return FixedStackTraceCauseScriptName;
            };
            const InitialStackTraceCauseScriptName = StackTraceCauseParts[BaseError.Pattern.StackTrace.Cause.Group.Cause.Script.Name];
            const FixedStackTraceCauseScriptName = GetFixedStackTraceCauseScriptName(InitialStackTraceCauseScriptName);
            const StackTraceCauseCoordinates = {
                Line: parseInt(StackTraceCauseParts[BaseError.Pattern.StackTrace.Cause.Group.Cause.Coordinates.Line], 10),
                Column: parseInt(StackTraceCauseParts[BaseError.Pattern.StackTrace.Cause.Group.Cause.Coordinates.Column], 10),
            };
            const StackTraceEntity = {
                File: {
                    Path: StackTraceFilePath,
                },
                Cause: {
                    Script: {
                        Name: FixedStackTraceCauseScriptName,
                    },
                    Coordinates: StackTraceCauseCoordinates,
                },
            };
            return StackTraceEntity;
        });
        return StackTraceEntities;
    }
    __FormMessageOutput() {
        const Validator = GlobalModule.Classes.Validator;
        const StringManager = GlobalModule.Functions.Parameter.Type.Manager.Default.String;
        const ColorManager = GlobalModule.Functions.Parameter.Type.Manager.Custom.Color;
        const StringStylizator = StringManager.Style;
        const StringColorModifier = StringStylizator.Modify.Color;
        const DisplayTag = `[${this.Tag}]`; // CaseModifier.Size.ToUpperCase(?, Array.from(Array(?.length), (_el, _ind) => _ind))
        const StyledDisplayTag = StringColorModifier.Text(DisplayTag, ...this.TagColor);
        const DisplayCode = `${this.Code}`;
        const DisplayCodeRGBColor = ColorManager.HEXToRGB(GlobalModule.DataSet.Constants.Custom.Color.HEX.Custom.Console.Element.Default.Number);
        const StyledDisplayCode = StringColorModifier.Text(DisplayCode, ...DisplayCodeRGBColor);
        const DisplayCodeName = `${this.CodeName}`;
        const StyledDisplayCodeName = StringColorModifier.Text(DisplayCodeName, ...this.CodeNameColor);
        const DisplayMessage = this.Message;
        const DisplayMessageRGBColor = ColorManager.HEXToRGB(GlobalModule.DataSet.Constants.Custom.Color.HEX.Custom.Console.Element.Default.Message);
        const StyledDisplayMessage = DisplayMessage.map((_el, _ind, _arr) => Validator.TypeGuard.Default.IsString(_el) ? `${StringColorModifier.Text(_el, ...DisplayMessageRGBColor)}` : _el);
        const MessageOutput = [
            `${StyledDisplayTag}`,
            GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default,
            `[${StyledDisplayCodeName} | ${StyledDisplayCode}]:`,
            GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default,
            GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default,
            ...StyledDisplayMessage,
        ];
        return MessageOutput;
    }
    __FormStackTraceOutput() {
        const Validator = GlobalModule.Classes.Validator;
        const StringManager = GlobalModule.Functions.Parameter.Type.Manager.Default.String;
        const SpaceSymbol = GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default;
        const StringStylizator = StringManager.Style;
        const StringInscriptionModifier = StringStylizator.Modify.Inscription;
        const DisplayStackPrefix = `${``.padStart(4, SpaceSymbol)}at${``.padStart(2, SpaceSymbol)}`;
        const StyledDisplayStackPrefix = StringInscriptionModifier(DisplayStackPrefix, StringInscriptionModifier.Type.Dim);
        const NativeStackTrace = this.stack;
        const TotalStackTraceToArray = [...this._StackTrace.List.Inheritted];
        if (Validator.TypeGuard.Default.IsString(NativeStackTrace)) {
            if (!Validator.TypeGuard.Default.IsEmptyString(NativeStackTrace)) {
                const NativeStackTraceRows = NativeStackTrace.split(/\n/);
                const NativeStackTraceToArray = NativeStackTraceRows.slice(this._StackTrace.Depth, NativeStackTraceRows.length);
                GlobalModule.Functions.Parameter.Type.Manager.Default.Array.Clear(TotalStackTraceToArray);
                TotalStackTraceToArray.push(...this._StackTrace.List.Inheritted, ...NativeStackTraceToArray);
            }
        }
        const DisplayStack = BaseError.__FormStackTraceRows(TotalStackTraceToArray);
        const StyledDisplayStack = DisplayStack.map((_el, _ind, _arr) => `${StyledDisplayStackPrefix}${StringInscriptionModifier(`${_el.Cause.Script.Name} (${_el.File.Path}:${_el.Cause.Coordinates.Line}:${_el.Cause.Coordinates.Column})`, StringInscriptionModifier.Type.Dim)}`);
        const StackTraceOutput = StyledDisplayStack.join(`\n`);
        return StackTraceOutput;
    }
    __FormCauseTraceOutput() {
        const Validator = GlobalModule.Classes.Validator;
        const NativeStackTrace = this.stack;
        const TotalStackTraceToArray = [...this._StackTrace.List.Inheritted];
        if (Validator.TypeGuard.Default.IsString(NativeStackTrace)) {
            if (!Validator.TypeGuard.Default.IsEmptyString(NativeStackTrace)) {
                const NativeStackTraceRows = NativeStackTrace.split(/\n/);
                const NativeStackTraceToArray = NativeStackTraceRows.slice(this._StackTrace.Depth, NativeStackTraceRows.length);
                GlobalModule.Functions.Parameter.Type.Manager.Default.Array.Clear(TotalStackTraceToArray);
                TotalStackTraceToArray.push(...this._StackTrace.List.Inheritted, ...NativeStackTraceToArray);
            }
        }
        const DisplayStack = BaseError.__FormStackTraceRows(TotalStackTraceToArray);
        const DisplayCauseStackEntity = DisplayStack[DisplayStack.length - 1];
        const DoesDisplayCauseStackEntityExist = Validator.TypeGuard.Default.IsObjectOfProperties(DisplayCauseStackEntity, [`Cause`, `File`]);
        const DisplayCauseStackRows = [];
        if (DoesDisplayCauseStackEntityExist) {
            const DisplayCauseStackFilePath = DisplayCauseStackEntity.File.Path;
            const DisplayCauseStackFileLine = DisplayCauseStackEntity.Cause.Coordinates.Line;
            const DisplayCauseStackFileColumn = DisplayCauseStackEntity.Cause.Coordinates.Column;
            const DisplayCauseStack = BaseError.__GetCauseTraceFromFile(DisplayCauseStackFilePath, DisplayCauseStackFileLine, DisplayCauseStackFileColumn, 15);
            GlobalModule.Functions.Parameter.Type.Manager.Default.Array.Clear(DisplayCauseStackRows);
            DisplayCauseStackRows.push(...DisplayCauseStack.split(/\n/));
        }
        const CauseTraceOutput = DisplayCauseStackRows.join(`\n`);
        return CauseTraceOutput;
    }
    // TODO: JSDoc
    __FormOutput() {
        const Validator = GlobalModule.Classes.Validator;
        const FormedOutputParts = [];
        const MessageOutput = this.__FormMessageOutput();
        FormedOutputParts.push(MessageOutput);
        const CauseTraceOutput = this.__FormCauseTraceOutput();
        const DoesCauseTraceOutputExist = Validator.Soft(CauseTraceOutput, new Validator().Default.String().Required().MinLength(1)).Status;
        if (DoesCauseTraceOutputExist)
            FormedOutputParts.push([`\n${CauseTraceOutput}\n`]);
        const StackTraceOutput = this.__FormStackTraceOutput();
        FormedOutputParts.push([`\n${StackTraceOutput}`]);
        const ExtendedErrorValues = {
            codeName: this.CodeName,
            code: this.Code,
        };
        FormedOutputParts.push([ExtendedErrorValues]);
        const FormedOutput = FormedOutputParts.reduce((_prev, _curr, _currInd, _arr) => {
            const IsFirstElement = _currInd === 0;
            const ArrayFromFirstElement = [..._prev, ..._curr];
            const ArrayFromSecondElement = [..._prev, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default, ..._curr];
            const SplittedArray = IsFirstElement ? ArrayFromFirstElement : ArrayFromSecondElement;
            return SplittedArray;
        }, []);
        return FormedOutput;
    }
}
export default BaseError;
//# sourceMappingURL=BaseError.js.map