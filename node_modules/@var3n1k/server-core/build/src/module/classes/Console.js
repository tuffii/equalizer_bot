import * as GlobalModule from '../@module.js';
const EventName = {
    Settings: {
        Update: `settingsUpdate`,
    },
    Log: {
        Custom: `logCustom`,
        Preset: {
            Success: `logPresetSuccess`,
            Info: `logPresetInfo`,
            Warning: `logPresetWarning`,
            Error: `logPresetError`,
        },
    },
};
class Console {
    // TODO: JSDoc
    static Event = { Name: EventName, Emitter: new GlobalModule.Classes.EventEmitter() };
    // TODO: JSDoc
    static Stream = {
        Input: GlobalModule.Dependencies.Default.Node.process.stdin,
        Output: GlobalModule.Dependencies.Default.Node.process.stdout,
        Error: GlobalModule.Dependencies.Default.Node.process.stderr,
    };
    // TODO: JSDoc
    static Size = {
        Width: Console.Stream.Output.columns,
        Height: Console.Stream.Output.rows,
    };
    // TODO: JSDoc
    static Pattern = {
        Cursor: {
            Position: {
                RegExp: /\u001b\[([\d]+);([\d]+)R/,
                Group: { Row: 1, Column: 2 },
            },
        },
    };
    // TODO: JSDoc
    static __Queue = {
        Logs: new GlobalModule.Classes.Queue(0, 1, (..._) => {
            const NewLogs = _;
            for (let i = 0; i < NewLogs.length; i++) {
                // const NewLog = NewLogs[i]
            }
        }),
    };
    // TODO: JSDoc
    static __Settings = { TimeTag: { FullYear: false, NamedMonth: false, Ms: false }, Elements: { Compact: false } };
    // TODO: JSDoc
    static get Settings() {
        const Validator = GlobalModule.Classes.Validator;
        const Settings = {
            Get: () => Console.__GetSettingsCopy(),
            Set: {
                TimeTag: (_, __, ___) => {
                    Validator.Strict(_, new Validator().Default.Boolean().Required());
                    Validator.Strict(__, new Validator().Default.Boolean().Required());
                    Validator.Strict(___, new Validator().Default.Boolean().Required());
                    Console.__UpdateSettings(() => {
                        Console.__Settings.TimeTag.FullYear = _;
                        Console.__Settings.TimeTag.NamedMonth = __;
                        Console.__Settings.TimeTag.Ms = ___;
                    });
                },
                Elements: (_) => {
                    Validator.Strict(_, new Validator().Default.Boolean().Required());
                    Console.__UpdateSettings(() => {
                        Console.__Settings.Elements.Compact = _;
                    });
                },
            },
        };
        return Settings;
    }
    // TODO: JSDoc
    static get Cursor() {
        const Validator = GlobalModule.Classes.Validator;
        const Cursor = {
            Get: async () => await Console.__GetCursorPosition(),
            Set: (_, __) => this.__SetCursor(_, __),
            Move: (_, __) => this.__MoveCursor(_, __),
        };
        return Cursor;
    }
    // TODO: JSDoc
    static get Log() {
        const Validator = GlobalModule.Classes.Validator;
        const StringManager = GlobalModule.Functions.Parameter.Type.Manager.Default.String;
        const ColorManager = GlobalModule.Functions.Parameter.Type.Manager.Custom.Color;
        const StringJustifier = StringManager.Justify;
        const StringStylizator = StringManager.Style;
        const StringStylizationCleaner = StringManager.Style.Clear;
        const StringColorModifier = StringStylizator.Modify.Color;
        const Log = {
            Custom: (_, __, ...___) => {
                Validator.Strict(_, new Validator().Default.Boolean().Required());
                Validator.Strict(__, new Validator().Default.Boolean().Required());
                this.__CustomLog(_, __, ...___);
                Console.Event.Emitter.Emit(Console.Event.Name.Log.Custom, _, __, ...___);
            },
            Preset: {
                Success: (..._) => {
                    const LogStatusTagText = `[SUCCESS]`;
                    const LogStatusTagColor = ColorManager.HEXToRGB(GlobalModule.DataSet.Constants.Custom.Color.HEX.Custom.Console.Log.Preset.Success.Tag);
                    const ColoredLogStatusTag = StringColorModifier.Text(LogStatusTagText, ...LogStatusTagColor);
                    const ResultLogStatusTag = ColoredLogStatusTag;
                    this.__CustomLog(true, true, ResultLogStatusTag, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default, ..._);
                    Console.Event.Emitter.Emit(Console.Event.Name.Log.Preset.Success, ..._);
                },
                Info: (..._) => {
                    const LogStatusTagText = `[INFO]`;
                    const LogStatusTagColor = ColorManager.HEXToRGB(GlobalModule.DataSet.Constants.Custom.Color.HEX.Custom.Console.Log.Preset.Info.Tag);
                    const ColoredLogStatusTag = StringColorModifier.Text(LogStatusTagText, ...LogStatusTagColor);
                    const ResultLogStatusTag = ColoredLogStatusTag;
                    this.__CustomLog(true, true, ResultLogStatusTag, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default, ..._);
                    Console.Event.Emitter.Emit(Console.Event.Name.Log.Preset.Info, ..._);
                },
                Warn: (..._) => {
                    const LogStatusTagText = `[WARNING]`;
                    const LogStatusTagColor = ColorManager.HEXToRGB(GlobalModule.DataSet.Constants.Custom.Color.HEX.Custom.Console.Log.Preset.Warning.Tag);
                    const ColoredLogStatusTag = StringColorModifier.Text(LogStatusTagText, ...LogStatusTagColor);
                    const ResultLogStatusTag = ColoredLogStatusTag;
                    this.__CustomLog(true, true, ResultLogStatusTag, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default, ..._);
                    Console.Event.Emitter.Emit(Console.Event.Name.Log.Preset.Warning, ..._);
                },
                Error: ((_, __) => {
                    Validator.Strict(_, new Validator().Default.Class.Instance().Required().Of(globalThis.Error));
                    Validator.Strict(__, new Validator().Default.Boolean().Required());
                    const LogErrorTagText = `NODE.JS ERROR | ${_.name}`;
                    const LogErrorTagColor = ColorManager.HEXToRGB(GlobalModule.DataSet.Constants.Custom.Color.HEX.Custom.Console.Log.Preset.Error.Tag);
                    const LogErrorCodeNumber = -1;
                    const LogErrorCodeNameText = `UNKNOWN`;
                    const LogErrorCodeNameColor = ColorManager.HEXToRGB(GlobalModule.DataSet.Constants.Custom.Color.HEX.Custom.Console.Log.Preset.Error.Code.Name);
                    const LogErrorInitialStackTrace = _.stack;
                    const LogErrorMessage = [_.message];
                    const UniversalErrorDisplayParameters = Validator.TypeGuard.Default.IsInstanceOf(_, GlobalModule.Classes.Error.BaseError)
                        ? _.FormOutput()
                        : new GlobalModule.Classes.Error.BaseError(LogErrorTagText, LogErrorTagColor, LogErrorCodeNumber, LogErrorCodeNameText, LogErrorCodeNameColor, LogErrorInitialStackTrace, LogErrorMessage).FormOutput();
                    this.__CustomLog(true, true, ...UniversalErrorDisplayParameters);
                    Console.Event.Emitter.Emit(Console.Event.Name.Log.Preset.Error, _, __);
                    if (__)
                        GlobalModule.Classes.Process.Stop(0);
                }),
            },
        };
        return Log;
    }
    // TODO: JSDoc
    static get Clear() {
        const Validator = GlobalModule.Classes.Validator;
        const Clear = {
            Screen: {
                Whole: () => {
                    Console.Cursor.Set(0, 0);
                    this.__ClearScreenFromCurrentLine();
                },
                FromCurrentLine: () => this.__ClearScreenFromCurrentLine(),
            },
            Row: {
                Left: () => this.__ClearCurrentLine(-1),
                Whole: () => this.__ClearCurrentLine(0),
                Rigth: () => this.__ClearCurrentLine(1),
            },
        };
        return Clear;
    }
    // TODO: JSDoc
    static __GetSettingsCopy() {
        const SettingsCopy = GlobalModule.Functions.Parameter.Type.Manager.Default.Object.Copy(Console.__Settings);
        return SettingsCopy;
    }
    // TODO: JSDoc
    static __UpdateSettings(updateFunction) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(updateFunction, new Validator().Default.Function().Required());
        const OldSettings = Console.__GetSettingsCopy();
        updateFunction();
        const NewSettings = Console.__GetSettingsCopy();
        Console.Event.Emitter.Emit(Console.Event.Name.Settings.Update, OldSettings, NewSettings);
        const ModifiedParameters = GlobalModule.Functions.Parameter.Type.Manager.Default.Object.GetFullProperties(OldSettings, (propertiesPath, value) => false)
            .map((_el, _ind, _arr) => {
            const ParameterName = _el.Path.join(`.`);
            const OldParameterValue = _el.Value;
            const NewParameterValue = GlobalModule.Functions.Parameter.Type.Manager.Default.Object.GetValue(NewSettings, _el.Path);
            const ModifiedParameter = {
                Name: ParameterName,
                Value: {
                    Old: OldParameterValue,
                    New: NewParameterValue,
                },
            };
            return ModifiedParameter;
        })
            .filter((_el, _ind, _arr) => {
            const IsParameterValueModified = _el.Value.Old !== _el.Value.New;
            return IsParameterValueModified;
        });
        const DoesModifiedParameterExist = !Validator.TypeGuard.Default.IsEmptyArray(ModifiedParameters);
        if (DoesModifiedParameterExist) {
            GlobalModule.Classes.Console.Log.Preset.Info(`Для консоли приложения изменены настройки (${ModifiedParameters.length}): ${ModifiedParameters.map((_el, _ind, _arr) => `'${_el.Name}' (${_el.Value.Old} -> ${_el.Value.New})`).join(GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default)}`);
        }
    }
    // TODO: JSDoc
    static __FormatOutput(elements) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(elements, new Validator().Default.Array().Required());
        const StringManager = GlobalModule.Functions.Parameter.Type.Manager.Default.String;
        const ColorManager = GlobalModule.Functions.Parameter.Type.Manager.Custom.Color;
        const StringJustifier = StringManager.Justify;
        const StringStylizator = StringManager.Style;
        const StringStylizationCleaner = StringManager.Style.Clear;
        const StringColorModifier = StringStylizator.Modify.Color;
        const OutputFormattingConfig = {
            breakLength: Infinity,
            maxStringLength: Infinity,
            maxArrayLength: Infinity,
            compact: Console.__Settings.Elements.Compact,
            depth: Console.__Settings.Elements.Compact ? 2 : Infinity,
            getters: !Console.__Settings.Elements.Compact,
            showHidden: !Console.__Settings.Elements.Compact,
            showProxy: !Console.__Settings.Elements.Compact,
            colors: true,
            customInspect: true,
            numericSeparator: false,
            sorted: false,
        };
        // const FormatAll = (...message: Array<any>): string => GlobalModule.Dependencies.Default.Node.util.formatWithOptions(OutputFormattingConfig, ...message)
        const FormatOne = (message) => GlobalModule.Dependencies.Default.Node.util.inspect(message, OutputFormattingConfig);
        const IsFormatRequired = (element) => {
            const IsString = Validator.TypeGuard.Default.IsString(element);
            const IsFormatted = IsString;
            return !IsFormatted;
        };
        const FormattingElements = [];
        const FormattingElementsGroup = [];
        for (let i = 0; i < elements.length; i++) {
            const Element = elements[i];
            const IsElementFormatRequired = IsFormatRequired(Element);
            const FormattingElement = {
                Value: IsElementFormatRequired ? FormatOne(Element) : Element,
                Format: {
                    Justify: {
                        Required: !IsElementFormatRequired,
                    },
                },
            };
            const DoesPreviousFormattingElementExist = !Validator.TypeGuard.Default.IsEmptyArray(FormattingElementsGroup);
            if (DoesPreviousFormattingElementExist) {
                const PreviousFormattingElement = FormattingElementsGroup[FormattingElementsGroup.length - 1];
                if (PreviousFormattingElement.Format.Justify.Required === FormattingElement.Format.Justify.Required) {
                    FormattingElementsGroup.push(FormattingElement);
                }
                else {
                    const NewFormattingElement = {
                        Value: FormattingElementsGroup.map((_el, _ind, _arr) => _el.Value).join(``),
                        Format: {
                            Justify: {
                                Required: PreviousFormattingElement.Format.Justify.Required,
                            },
                        },
                    };
                    FormattingElements.push(NewFormattingElement);
                    GlobalModule.Functions.Parameter.Type.Manager.Default.Array.Clear(FormattingElementsGroup);
                    FormattingElementsGroup.push(FormattingElement);
                }
            }
            else {
                ;
                FormattingElementsGroup.push(FormattingElement);
            }
        }
        if (!Validator.TypeGuard.Default.IsEmptyArray(FormattingElementsGroup)) {
            const PreviousFormattingElement = FormattingElementsGroup[FormattingElementsGroup.length - 1];
            const NewFormattingElement = {
                Value: FormattingElementsGroup.map((_el, _ind, _arr) => _el.Value).join(``),
                Format: {
                    Justify: {
                        Required: PreviousFormattingElement.Format.Justify.Required,
                    },
                },
            };
            FormattingElements.push(NewFormattingElement);
            GlobalModule.Functions.Parameter.Type.Manager.Default.Array.Clear(FormattingElementsGroup);
        }
        const FormattedElements = FormattingElements.map((_el, _ind, _arr) => {
            const FormattingElementValue = _el.Value;
            const IsJustifyRequired = _el.Format.Justify.Required;
            let FormattedElement = FormattingElementValue;
            if (IsJustifyRequired) {
                const FormattingElementRows = FormattingElementValue.split(/\n/);
                const FormattedElementRows = FormattingElementRows.map((__el, __ind, __arr) => {
                    const IsLastRow = __ind === FormattingElementRows.length - 1;
                    const ClearedRow = StringStylizationCleaner(__el);
                    const RowJustifyWidth = IsLastRow ? ClearedRow.length : Console.Size.Width - 5;
                    const FormattedElementRow = StringJustifier(__el, RowJustifyWidth, StringJustifier.Type.Left);
                    return FormattedElementRow;
                });
                FormattedElement = FormattedElementRows.join(`\n`);
            }
            else {
                FormattedElement = FormattingElementValue;
            }
            return FormattedElement;
        });
        const FormattedOutput = FormattedElements.join(``)
            .replace(/\t/g, ``.padStart(4, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default))
            .replace(/\r/g, ``);
        return FormattedOutput;
    }
    // TODO: JSDoc
    static __CustomLog(mark, timeTag, ...elements) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(mark, new Validator().Default.Boolean().Required());
        Validator.Strict(timeTag, new Validator().Default.Boolean().Required());
        const StringManager = GlobalModule.Functions.Parameter.Type.Manager.Default.String;
        const ColorManager = GlobalModule.Functions.Parameter.Type.Manager.Custom.Color;
        const StringJustifier = StringManager.Justify;
        const StringStylizator = StringManager.Style;
        const StringStylizationCleaner = StringManager.Style.Clear;
        const StringColorModifier = StringStylizator.Modify.Color;
        const LogDate = new Date();
        const LogMarkText = GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Mark.Status.Radio.On;
        const LogMarkColor = GlobalModule.DataSet.Constants.Custom.Color.HEX.Default.Blue.Default.Initial;
        const ColoredLogMark = StringColorModifier.Text(LogMarkText, ...ColorManager.HEXToRGB(LogMarkColor));
        const ResultLogMark = ColoredLogMark;
        const LogDay = GlobalModule.Functions.Parameter.Type.Manager.Default.Date.GetStringDate(LogDate, true, Console.__Settings.TimeTag.FullYear, Console.__Settings.TimeTag.NamedMonth);
        const LogTime = GlobalModule.Functions.Parameter.Type.Manager.Default.Date.GetStringTime(LogDate, true, Console.__Settings.TimeTag.Ms);
        const LogTimeTagText = `[${LogDay} | ${LogTime}]`;
        const LogTimeTagColor = GlobalModule.DataSet.Constants.Custom.Color.HEX.Default.Grey.Default.Dark[60];
        const ColoredLogTimeTag = StringColorModifier.Text(LogTimeTagText, ...ColorManager.HEXToRGB(LogTimeTagColor));
        const ResultLogTimeTag = ColoredLogTimeTag;
        const FormattedLogElements = [];
        if (mark)
            FormattedLogElements.push(ResultLogMark, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default);
        if (timeTag)
            FormattedLogElements.push(ResultLogTimeTag, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default);
        const FormattedLogOutputElements = [...FormattedLogElements, ...elements];
        const FormattedLogOutput = this.__FormatOutput(FormattedLogOutputElements);
        const ResultLogOutputElements = [FormattedLogOutput];
        const ResultLogOutput = ResultLogOutputElements.join(``)
            .split(/\n/)
            .map((_el, _ind, _arr) => _el.trimEnd())
            .join(`\n`);
        console.log(ResultLogOutput);
        this.__Queue.Logs.Elements.Set.Add.End(ResultLogOutput);
    }
    // TODO: JSDoc
    static __ClearCurrentLine(direction) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(direction, new Validator().Default.Numeric().Number().Required().Integer().In([-1, 0, 1]));
        GlobalModule.Dependencies.Default.Node.readline.clearLine(Console.Stream.Output, direction);
    }
    // TODO: JSDoc
    static __ClearScreenFromCurrentLine() {
        this.__ClearCurrentLine(0);
        GlobalModule.Dependencies.Default.Node.readline.clearScreenDown(Console.Stream.Output);
    }
    // TODO: JSDoc
    static async __GetCursorPosition() {
        const GetCursorPositionUnicode = async () => {
            return new Promise(async (resolve, reject) => {
                Console.Stream.Input.setEncoding('utf8');
                Console.Stream.Input.setRawMode(true);
                const ReadCursorPosition = () => {
                    const CursorPositionBuffer = Console.Stream.Input.read();
                    const CursorPositionUnicode = `${CursorPositionBuffer}`; // JSON.stringify(CursorPositionBuffer)
                    Console.Stream.Input.setRawMode(false);
                    resolve(CursorPositionUnicode);
                };
                Console.Stream.Input.once('readable', () => ReadCursorPosition());
                Console.Stream.Output.write(GlobalModule.DataSet.Dictionary.Unicode.Cursor.Position.Get);
            });
        };
        const CursorPositionUnicode = await GetCursorPositionUnicode();
        const CursorPositionContext = new RegExp(`^${Console.Pattern.Cursor.Position.RegExp.source}$`, undefined).exec(CursorPositionUnicode);
        const CursorPosition = {
            Row: Number.parseInt(CursorPositionContext[Console.Pattern.Cursor.Position.Group.Row]),
            Column: Number.parseInt(CursorPositionContext[Console.Pattern.Cursor.Position.Group.Column]),
        };
        return CursorPosition;
    }
    // TODO: JSDoc
    static __SetCursor(row, column) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(row, new Validator().Default.Numeric().Number().Required().Integer().Min(1).Max(Console.Size.Width));
        Validator.Strict(column, new Validator().Default.Numeric().Number().Required().Integer().Min(1).Max(Console.Size.Height));
        GlobalModule.Dependencies.Default.Node.readline.cursorTo(Console.Stream.Output, row, column);
    }
    // TODO: JSDoc
    static __MoveCursor(rows, columns) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(rows, new Validator().Default.Numeric().Number().Required().Integer());
        Validator.Strict(columns, new Validator().Default.Numeric().Number().Required().Integer());
        GlobalModule.Dependencies.Default.Node.readline.moveCursor(Console.Stream.Output, columns, rows);
    }
}
export default Console;
//# sourceMappingURL=Console.js.map