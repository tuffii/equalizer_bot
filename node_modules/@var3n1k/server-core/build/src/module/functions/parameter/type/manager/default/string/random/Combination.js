import * as GlobalModule from '../../../../../../../@module.js';
//* -------------------------------------------------------------------------
//* Realization
//* -------------------------------------------------------------------------
export default function Combination(length, mandatorySymbols = [], additionalSymbols = [], combinationsToCompare = []) {
    const Validator = GlobalModule.Classes.Validator;
    Validator.Strict(length, new Validator().Default.Numeric().Number().Required().Integer().Min(1));
    Validator.Strict(mandatorySymbols, new Validator().Default.Array().Required().Of(new Validator().Default.String().Required().Length(1)));
    Validator.Strict(additionalSymbols, new Validator().Default.Array().Required().Of(new Validator().Default.String().Required().Length(1)));
    Validator.Strict(additionalSymbols, new Validator().Default.Array().Required().Of(new Validator().Default.String().Required().MinLength(1)));
    function GenerateRandomCode() {
        const RandomCodeSymbols = Array.from(Array(length), (_el, _ind) => undefined);
        // Array(length).fill(undefined, 0, length - 1)
        for (let i = 0; i < mandatorySymbols.length; i++) {
            const MandatorySymbol = mandatorySymbols[i];
            const EmptySymbolSlots = RandomCodeSymbols.map((_el, _ind, _arr) => {
                const SymbolSlot = { el: _el, ind: _ind };
                return SymbolSlot;
            })
                .filter((_el, _ind, _arr) => !Validator.TypeGuard.Default.IsSymbolLikeString(_el.el))
                .map((_el, _ind, _arr) => _el.ind);
            const DoesEmptySymbolSlotExist = !Validator.TypeGuard.Default.IsEmptyArray(EmptySymbolSlots);
            if (DoesEmptySymbolSlotExist) {
                const RandomEmptySymbolSlot = GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.Random.InList(...EmptySymbolSlots);
                RandomCodeSymbols[RandomEmptySymbolSlot] = MandatorySymbol;
            }
        }
        while (!Validator.TypeGuard.Default.IsEmptyArray(RandomCodeSymbols.filter((_el, _ind, _arr) => !Validator.TypeGuard.Default.IsSymbolLikeString(_el)))) {
            const EmptySymbolSlots = RandomCodeSymbols.map((_el, _ind, _arr) => {
                const SymbolSlot = { el: _el, ind: _ind };
                return SymbolSlot;
            })
                .filter((_el, _ind, _arr) => !Validator.TypeGuard.Default.IsSymbolLikeString(_el.el))
                .map((_el, _ind, _arr) => _el.ind);
            const DoesEmptySymbolSlotExist = !Validator.TypeGuard.Default.IsEmptyArray(EmptySymbolSlots);
            if (DoesEmptySymbolSlotExist) {
                const RandomEmptySymbolSlot = GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.Random.InList(...EmptySymbolSlots);
                const IsRandomMandatorySymbolObtainable = !Validator.TypeGuard.Default.IsEmptyArray(mandatorySymbols);
                const IsRandomAdditionalSymbolObtainable = !Validator.TypeGuard.Default.IsEmptyArray(additionalSymbols);
                if (IsRandomAdditionalSymbolObtainable) {
                    const RandomSymbol = GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.Random.InList(...additionalSymbols);
                    RandomCodeSymbols[RandomEmptySymbolSlot] = RandomSymbol;
                }
                else if (IsRandomMandatorySymbolObtainable) {
                    const RandomSymbol = GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.Random.InList(...mandatorySymbols);
                    RandomCodeSymbols[RandomEmptySymbolSlot] = RandomSymbol;
                }
            }
        }
        const RandomSymbolCode = RandomCodeSymbols.join(``);
        return RandomSymbolCode;
    }
    let ResultRandomSymbolCode = GenerateRandomCode();
    while (combinationsToCompare.includes(ResultRandomSymbolCode))
        ResultRandomSymbolCode = GenerateRandomCode();
    return ResultRandomSymbolCode;
}
//# sourceMappingURL=Combination.js.map