import * as GlobalModule from '../../../../../../@module.js';
const JustifyType = {
    Left: `left`,
    Center: `center`,
    Right: `right`,
};
Justify.Type = JustifyType;
//* -------------------------------------------------------------------------
//* Realization
//* -------------------------------------------------------------------------
export default function Justify(initialString, width, justifyType) {
    const JustifyTypes = GlobalModule.Functions.Parameter.Type.Manager.Default.Object.GetProperties(Justify.Type).map((_el, _ind, _arr) => Justify.Type[_el]);
    const Validator = GlobalModule.Classes.Validator;
    Validator.Strict(initialString, new Validator().Default.String().Required());
    Validator.Strict(width, new Validator().Default.Numeric().Number().Required().Integer().Min(1));
    Validator.Strict(justifyType, new Validator().Default.String().Required().In(JustifyTypes));
    function ConvertToUnicodeArray(initialStr) {
        let InitialStrCopy = initialStr;
        const InitialStrTextParts = InitialStrCopy.split(new RegExp(GlobalModule.Functions.Parameter.Type.Manager.Default.String.Style.Clear.Pattern.Unicode.RegExp.source, undefined));
        const InitialStrCopyToArray = [];
        for (let i = 0; i < InitialStrTextParts.length; i++) {
            const InitialStrTextPart = InitialStrTextParts[i];
            if (Validator.TypeGuard.Default.IsEmptyString(InitialStrTextPart))
                continue;
            if (InitialStrCopy.startsWith(InitialStrTextPart)) {
                const InitialStrFreeTextPart = InitialStrCopy.substring(InitialStrTextPart.length);
                InitialStrCopy = InitialStrFreeTextPart;
                InitialStrCopyToArray.push(InitialStrTextPart);
            }
            else {
                const InitialStrRegExpPart = InitialStrCopy.split(InitialStrTextPart)[0];
                const InitialStrFreePart = InitialStrCopy.substring(InitialStrRegExpPart.length);
                InitialStrCopy = InitialStrFreePart;
                InitialStrCopyToArray.push(InitialStrRegExpPart);
                const InitialStrFreeTextPart = InitialStrCopy.substring(InitialStrTextPart.length);
                InitialStrCopy = InitialStrFreeTextPart;
                InitialStrCopyToArray.push(InitialStrTextPart);
            }
        }
        if (!Validator.TypeGuard.Default.IsEmptyString(InitialStrCopy.split(/[\s]+/).join(GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default)))
            InitialStrCopyToArray.push(InitialStrCopy);
        return InitialStrCopyToArray;
    }
    const InitialStringUnicodeArray = ConvertToUnicodeArray(initialString);
    const ResultStringUnicodeArray = [];
    const GetCurrentStringLastRowLength = (currentRows, currentWords) => {
        const AdditionalWords = currentWords.join(GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default);
        const AdditionalRows = [...currentRows, AdditionalWords].join(`\n`);
        const UnicodeArrayToString = [...ResultStringUnicodeArray, AdditionalRows].join(``);
        const CurrentStringRows = UnicodeArrayToString.split(/\n/);
        const CurrentStringLastRow = CurrentStringRows[CurrentStringRows.length - 1];
        const ClearedCurrentStringLastRow = GlobalModule.Functions.Parameter.Type.Manager.Default.String.Style.Clear(CurrentStringLastRow);
        const ClearedCurrentStringLastRowLength = ClearedCurrentStringLastRow.length;
        return ClearedCurrentStringLastRowLength;
    };
    for (let i = 0; i < InitialStringUnicodeArray.length; i++) {
        const InitialStringUnicodeArrayPart = InitialStringUnicodeArray[i];
        const IsInitialStringStylizationMaskPart = new RegExp(`(?=${GlobalModule.Functions.Parameter.Type.Manager.Default.String.Style.Clear.Pattern.Unicode.RegExp.source})(?:.+)`).test(InitialStringUnicodeArrayPart);
        if (IsInitialStringStylizationMaskPart) {
            ResultStringUnicodeArray.push(InitialStringUnicodeArrayPart);
        }
        else {
            const InitialStringPartRows = InitialStringUnicodeArrayPart.split(/\n/);
            const ResultStringPartRows = [];
            for (let j = 0; j < InitialStringPartRows.length; j++) {
                const InitialStringPartRow = InitialStringPartRows[j];
                const InitialStringPartRowSplit = InitialStringPartRow.split(/[\s]/); // .split(/[\s]+/))
                const IsInitialStringPartRowSplitEmpty = Validator.TypeGuard.Default.IsEmptyString(InitialStringPartRowSplit.join(``));
                if (IsInitialStringPartRowSplitEmpty) {
                    const InitialStringPartRowWord = InitialStringPartRow;
                    // const RowPreviousWordsLength = GetCurrentStringLastRowLength(ResultStringPartRows, [])
                    const PredictRowLength = GetCurrentStringLastRowLength(ResultStringPartRows, [InitialStringPartRowWord]);
                    const IsPredictRowLengthValid = PredictRowLength <= width;
                    if (IsPredictRowLengthValid) {
                        ResultStringPartRows.push(InitialStringPartRowWord);
                    }
                    else {
                        continue;
                    }
                }
                else {
                    const InitialStringPartRowWords = InitialStringPartRowSplit;
                    const ResultStringPartRowWords = [];
                    for (let k = 0; k < InitialStringPartRowWords.length; k++) {
                        const InitialStringPartRowWord = InitialStringPartRowWords[k];
                        const IsInitialStringPartRowWordBiggerThanRowLength = InitialStringPartRowWord.length > width;
                        if (IsInitialStringPartRowWordBiggerThanRowLength) {
                            let InitialStringPartRowWordFreePart = InitialStringPartRowWord;
                            while (!Validator.TypeGuard.Default.IsEmptyString(InitialStringPartRowWordFreePart)) {
                                // const RowPreviousWordsLength = GetCurrentStringLastRowLength(ResultStringPartRows, ResultStringPartRowWords)
                                const PredictRowLength = GetCurrentStringLastRowLength(ResultStringPartRows, [...ResultStringPartRowWords, ``]);
                                const FreeRowWidth = width - PredictRowLength;
                                if (FreeRowWidth <= 0) {
                                    ResultStringPartRows.push(ResultStringPartRowWords.join(GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default));
                                    GlobalModule.Functions.Parameter.Type.Manager.Default.Array.Clear(ResultStringPartRowWords);
                                    continue;
                                }
                                const InitialStringPartRowWordPart = InitialStringPartRowWordFreePart.substring(0, FreeRowWidth);
                                const NewInitialStringPartRowWordFreePart = InitialStringPartRowWordFreePart.substring(FreeRowWidth);
                                ResultStringPartRowWords.push(InitialStringPartRowWordPart);
                                InitialStringPartRowWordFreePart = NewInitialStringPartRowWordFreePart;
                            }
                        }
                        else {
                            // const RowPreviousWordsLength = GetCurrentStringLastRowLength(ResultStringPartRows, ResultStringPartRowWords)
                            const PredictRowLength = GetCurrentStringLastRowLength(ResultStringPartRows, [...ResultStringPartRowWords, InitialStringPartRowWord]);
                            const IsPredictRowLengthValid = PredictRowLength <= width;
                            if (IsPredictRowLengthValid) {
                                ResultStringPartRowWords.push(InitialStringPartRowWord);
                            }
                            else {
                                ResultStringPartRows.push(ResultStringPartRowWords.join(GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default));
                                GlobalModule.Functions.Parameter.Type.Manager.Default.Array.Clear(ResultStringPartRowWords);
                                ResultStringPartRowWords.push(InitialStringPartRowWord);
                            }
                        }
                    }
                    if (!Validator.TypeGuard.Default.IsEmptyArray(ResultStringPartRowWords)) {
                        ResultStringPartRows.push(ResultStringPartRowWords.join(GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default));
                    }
                    GlobalModule.Functions.Parameter.Type.Manager.Default.Array.Clear(ResultStringPartRowWords);
                }
            }
            ResultStringUnicodeArray.push(ResultStringPartRows.join(`\n`));
        }
    }
    const JustifiedStringRows = ResultStringUnicodeArray.join(``).split(/\n/);
    const FullFilledJustifiedStringRows = [];
    for (let i = 0; i < JustifiedStringRows.length; i++) {
        const JustifiedStringRow = JustifiedStringRows[i];
        const ClearJustifiedStringRow = JustifiedStringRow.replace(new RegExp(GlobalModule.Functions.Parameter.Type.Manager.Default.String.Style.Clear.Pattern.Unicode.RegExp.source, `g`), ``);
        const JustifiedStringRowFreeSpace = width - ClearJustifiedStringRow.length;
        let PadFromStart = ``;
        let PadFromEnd = ``;
        switch (justifyType) {
            case Justify.Type.Left:
                PadFromStart = ``;
                PadFromEnd = ``.padStart(JustifiedStringRowFreeSpace, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default);
                break;
            case Justify.Type.Center:
                const JustifiedStringRowFreeSpaceFromLeft = Math.floor(JustifiedStringRowFreeSpace / 2);
                const JustifiedStringRowFreeSpaceFromRight = JustifiedStringRowFreeSpace - JustifiedStringRowFreeSpaceFromLeft;
                PadFromStart = ``.padStart(JustifiedStringRowFreeSpaceFromLeft, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default);
                PadFromEnd = ``.padStart(JustifiedStringRowFreeSpaceFromRight, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default);
                break;
            case Justify.Type.Right:
                PadFromStart = ``.padStart(JustifiedStringRowFreeSpace, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default);
                PadFromEnd = ``;
                break;
        }
        const FullFilledJustifiedStringRow = `${PadFromStart}${JustifiedStringRow}${PadFromEnd}`;
        FullFilledJustifiedStringRows.push(FullFilledJustifiedStringRow);
    }
    const JustifiedString = FullFilledJustifiedStringRows.join(`\n`);
    return JustifiedString;
}
//# sourceMappingURL=Justify.js.map