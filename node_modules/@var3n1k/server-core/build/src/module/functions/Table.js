import * as GlobalModule from '../@module.js';
const TableBorderType = {
    Single: `Single`,
    Double: `Double`,
    DoubleVertical: `DoubleVertical`,
    DoubleHorizontal: `DoubleHorizontal`,
};
const TableBorderSymbol = {
    Line: {
        Vertical: {
            [TableBorderType.Single]: `│`,
            [TableBorderType.Double]: `║`,
            [TableBorderType.DoubleVertical]: `║`,
            [TableBorderType.DoubleHorizontal]: `│`,
        },
        Horizontal: {
            [TableBorderType.Single]: `─`,
            [TableBorderType.Double]: `═`,
            [TableBorderType.DoubleVertical]: `─`,
            [TableBorderType.DoubleHorizontal]: `═`,
        },
    },
    Corner: {
        Top: {
            Left: {
                [TableBorderType.Single]: `┘`,
                [TableBorderType.Double]: `╝`,
                [TableBorderType.DoubleVertical]: `╜`,
                [TableBorderType.DoubleHorizontal]: `╛`,
            },
            Right: {
                [TableBorderType.Single]: `└`,
                [TableBorderType.Double]: `╚`,
                [TableBorderType.DoubleVertical]: `╙`,
                [TableBorderType.DoubleHorizontal]: `╘`,
            },
        },
        Bottom: {
            Left: {
                [TableBorderType.Single]: `┐`,
                [TableBorderType.Double]: `╗`,
                [TableBorderType.DoubleVertical]: `╖`,
                [TableBorderType.DoubleHorizontal]: `╕`,
            },
            Right: {
                [TableBorderType.Single]: `┌`,
                [TableBorderType.Double]: `╔`,
                [TableBorderType.DoubleVertical]: `╓`,
                [TableBorderType.DoubleHorizontal]: `╒`,
            },
        },
    },
    Connector: {
        Top: {
            [TableBorderType.Single]: `┴`,
            [TableBorderType.Double]: `╩`,
            [TableBorderType.DoubleVertical]: `╨`,
            [TableBorderType.DoubleHorizontal]: `╧`,
        },
        Bottom: {
            [TableBorderType.Single]: `┬`,
            [TableBorderType.Double]: `╦`,
            [TableBorderType.DoubleVertical]: `╥`,
            [TableBorderType.DoubleHorizontal]: `╤`,
        },
        Left: {
            [TableBorderType.Single]: `┤`,
            [TableBorderType.Double]: `╣`,
            [TableBorderType.DoubleVertical]: `╢`,
            [TableBorderType.DoubleHorizontal]: `╡`,
        },
        Right: {
            [TableBorderType.Single]: `├`,
            [TableBorderType.Double]: `╠`,
            [TableBorderType.DoubleVertical]: `╟`,
            [TableBorderType.DoubleHorizontal]: `╞`,
        },
        All: {
            [TableBorderType.Single]: `┼`,
            [TableBorderType.Double]: `╬`,
            [TableBorderType.DoubleVertical]: `╫`,
            [TableBorderType.DoubleHorizontal]: `╪`,
        },
    },
};
const JustifyType = GlobalModule.Functions.Parameter.Type.Manager.Default.String.Justify.Type;
Table.Row = {
    Cell: {
        Justify: {
            Type: JustifyType,
        },
    },
};
//* -------------------------------------------------------------------------
//* Realization
//* -------------------------------------------------------------------------
export default function Table(margin, borders, rows) {
    const JustifyTypes = GlobalModule.Functions.Parameter.Type.Manager.Default.Object.GetProperties(Table.Row.Cell.Justify.Type).map((_el, _ind, _arr) => Table.Row.Cell.Justify.Type[_el]);
    const Validator = GlobalModule.Classes.Validator;
    Validator.Strict(margin, new Validator().Default.Numeric().Number().Required().Integer().Min(0));
    Validator.Strict(borders, new Validator().Default.Object()
        .Required()
        .Exact({
        Sign: new Validator().Default.Object()
            .Required()
            .Exact({
            Vertical: new Validator().Default.Object().Required().Exact({
                Double: new Validator().Default.Boolean().Required(),
            }),
            Horizontal: new Validator().Default.Object().Required().Exact({
                Double: new Validator().Default.Boolean().Required(),
            }),
        }),
        Visible: new Validator().Default.Boolean().Required(),
        Color: new Validator().Default.Object().Required().Exact({
            Entity: new Validator().Custom.Color.RGB(),
            Background: new Validator().Custom.Color.RGB(),
        }),
    }));
    Validator.Strict(rows, new Validator().Default.Array()
        .Required()
        .Of(new Validator().Default.Object()
        .Required()
        .Exact({
        FootNote: new Validator().Default.Object()
            .Required()
            .Exact({
            Left: new Validator().Default.Object()
                .Required()
                .Exact({
                Text: new Validator().Default.String().Required(),
                Color: new Validator().Default.Object().Required().Exact({
                    Entity: new Validator().Custom.Color.RGB(),
                    Background: new Validator().Custom.Color.RGB(),
                }),
            }),
            Right: new Validator().Default.Object()
                .Required()
                .Exact({
                Text: new Validator().Default.String().Required(),
                Color: new Validator().Default.Object().Required().Exact({
                    Entity: new Validator().Custom.Color.RGB(),
                    Background: new Validator().Custom.Color.RGB(),
                }),
            }),
        }),
        Cells: new Validator().Default.Array()
            .Required()
            .Of(new Validator().Default.Object()
            .Required()
            .Exact({
            Width: new Validator().Default.Numeric().Number().Required().Integer().Min(1),
            Padding: new Validator().Default.Object()
                .Required()
                .Exact({
                Top: new Validator().Default.Numeric().Number().Required().Integer().Min(0),
                Left: new Validator().Default.Numeric().Number().Required().Integer().Min(0),
                Bottom: new Validator().Default.Numeric().Number().Required().Integer().Min(0),
                Right: new Validator().Default.Numeric().Number().Required().Integer().Min(0),
            }),
            JustifyType: new Validator().Default.String().Required().In(JustifyTypes),
            Content: new Validator().Default.Object()
                .Required()
                .Exact({
                Text: new Validator().Default.String().Required(),
                Color: new Validator().Default.Object().Required().Exact({
                    Entity: new Validator().Custom.Color.RGB(),
                    Background: new Validator().Custom.Color.RGB(),
                }),
            }),
        })),
    })));
    for (let i = 0; i < rows.length; i++) {
        const CurrentRow = rows[i];
        const CurrentRowCellsWidth = CurrentRow.Cells.reduce((_prev, _curr, _currInd, _arr) => _prev + _curr.Width, 0) + CurrentRow.Cells.length;
        for (let j = 0; j < rows.length; j++) {
            const OtherRow = rows[j];
            const OtherRowCellsWidth = OtherRow.Cells.reduce((_prev, _curr, _currInd, _arr) => _prev + _curr.Width, 0) + OtherRow.Cells.length;
            Validator.Strict(CurrentRowCellsWidth, new Validator().Default.Numeric().Number().Required().Integer().EqualTo(OtherRowCellsWidth));
        }
    }
    for (let i = 0; i < rows.length; i++) {
        const CurrentRow = rows[i];
        for (let j = 0; j < CurrentRow.Cells.length; j++) {
            const CurrentCell = CurrentRow.Cells[j];
            const CellFreeHorizontalLength = CurrentCell.Width - (CurrentCell.Padding.Left + CurrentCell.Padding.Right);
            Validator.Strict(CellFreeHorizontalLength, new Validator().Default.Numeric().Number().Required().Integer().Min(1));
        }
    }
    const StringManager = GlobalModule.Functions.Parameter.Type.Manager.Default.String;
    const StringJustifier = StringManager.Justify;
    const StringStylizator = StringManager.Style;
    const StringStylizationCleaner = StringStylizator.Clear;
    const StringColorModifier = StringStylizator.Modify.Color;
    const StringInscriptionModifier = StringStylizator.Modify.Inscription;
    let BorderType = TableBorderType.Single;
    if (borders.Sign.Vertical.Double && borders.Sign.Horizontal.Double)
        BorderType = TableBorderType.Double;
    if (borders.Sign.Vertical.Double && !borders.Sign.Horizontal.Double)
        BorderType = TableBorderType.DoubleVertical;
    if (!borders.Sign.Vertical.Double && borders.Sign.Horizontal.Double)
        BorderType = TableBorderType.DoubleHorizontal;
    const SetTextInvisible = (text) => StringInscriptionModifier(text, StringInscriptionModifier.Type.Hidden);
    const ColorizeText = (text, color) => Validator.TypeGuard.Custom.Color.IsRGB(color) ? StringColorModifier.Text(text, ...color) : text;
    const ColorizeBackground = (text, color) => Validator.TypeGuard.Custom.Color.IsRGB(color) ? StringColorModifier.Background(text, ...color) : text;
    const ColorizeBorderSignText = (text) => ColorizeText(text, borders.Color.Entity);
    const ColorizeBorderSignBackground = (text) => ColorizeBackground(text, borders.Color.Background);
    const ColorizeBorderSign = (text) => (borders.Visible ? ColorizeBorderSignBackground(ColorizeBorderSignText(text)) : SetTextInvisible(text));
    const InsertEmptyLines = (linesCount, lineWidth, background) => {
        const EmptyLinesList = [];
        for (let i = 0; i < linesCount; i++) {
            EmptyLinesList.push(ColorizeBackground(``.padStart(lineWidth, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default), background));
        }
        const EmptyLines = EmptyLinesList.map((_el, _ind, _arr) => _el).join(`\n`);
        return EmptyLines;
    };
    const FixedRows = [];
    for (let i = 0; i < rows.length; i++) {
        const Row = rows[i];
        const RowCells = Row.Cells;
        const FixedRowCells = [];
        for (let j = 0; j < RowCells.length; j++) {
            const RowCell = RowCells[j];
            const RowCellPaddingTop = InsertEmptyLines(RowCell.Padding.Top, RowCell.Width, RowCell.Content.Color.Background);
            const FixedRowCellPaddingTop = RowCell.Padding.Top > 0 ? `${RowCellPaddingTop}\n` : ``;
            const RowCellPaddingBottom = InsertEmptyLines(RowCell.Padding.Bottom, RowCell.Width, RowCell.Content.Color.Background);
            const FixedRowCellPaddingBottom = RowCell.Padding.Bottom > 0 ? `\n${RowCellPaddingBottom}` : ``;
            const RowCellFreeHorizontalLength = RowCell.Width - (RowCell.Padding.Left + RowCell.Padding.Right);
            const RowCellJustifiedText = StringJustifier(RowCell.Content.Text, RowCellFreeHorizontalLength, RowCell.JustifyType);
            const ModifiedRowCellJustifiedText = RowCellJustifiedText.split(/\n/)
                .map((_el, _ind, _arr) => {
                const FullLinedRowCellPaddingLeft = ``.padStart(RowCell.Padding.Left, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default);
                const FullLinedRowCellPaddingRight = ``.padStart(RowCell.Padding.Right, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default);
                const FullLinedRowCellText = `${FullLinedRowCellPaddingLeft}${_el}${FullLinedRowCellPaddingRight}`;
                const ColoredFullLinedRowCellText = ColorizeText(FullLinedRowCellText, RowCell.Content.Color.Entity);
                const ColoredFullLinedRowCellBackground = ColorizeBackground(ColoredFullLinedRowCellText, RowCell.Content.Color.Background);
                return ColoredFullLinedRowCellBackground;
            })
                .join(`\n`);
            const RowCellText = `${FixedRowCellPaddingTop}${ModifiedRowCellJustifiedText}${FixedRowCellPaddingBottom}`;
            const FixedRowCell = {
                Text: RowCellText,
                Color: RowCell.Content.Color,
                Width: RowCell.Width,
            };
            FixedRowCells.push(FixedRowCell);
        }
        const MaximumRowFootNoteHeight = Math.max(Row.FootNote.Left.Text.split(/\n/).length, Row.FootNote.Right.Text.split(/\n/).length);
        const MaximumRowCellHeight = Math.max(...FixedRowCells.map((_el, _ind, _arr) => _el.Text.split(/\n/).length), MaximumRowFootNoteHeight);
        const MaximumRowLeftFootNoteWidth = Math.max(...Row.FootNote.Left.Text.split(/\n/).map((_el, _ind, _arr) => StringStylizationCleaner(_el).length));
        const RowLeftFootNote = Row.FootNote.Left.Text.split(/\n/)
            .map((_el, _ind, _arr) => {
            const FullLinedFootNotePaddingLeftSize = MaximumRowLeftFootNoteWidth - StringStylizationCleaner(_el).length;
            const FullLinedFootNotePaddingRightSize = 0;
            const FullLinedFootNotePaddingLeft = ``.padStart(FullLinedFootNotePaddingLeftSize, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default);
            const FullLinedFootNotePaddingRight = ``.padStart(FullLinedFootNotePaddingRightSize, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default);
            const FullLinedFootNoteText = `${FullLinedFootNotePaddingLeft}${_el}${FullLinedFootNotePaddingRight}`;
            const ColoredFootNoteText = ColorizeText(FullLinedFootNoteText, Row.FootNote.Left.Color.Entity);
            const ColoredFootNoteBackground = ColorizeBackground(ColoredFootNoteText, Row.FootNote.Left.Color.Background);
            return ColoredFootNoteBackground;
        })
            .join(`\n`);
        const FixedRowLeftFootNoteHeight = RowLeftFootNote.split(/\n/).length;
        const FixedRowLeftFootNoteFreeHeight = MaximumRowCellHeight - FixedRowLeftFootNoteHeight;
        const RowLeftFootNoteExtraPadding = InsertEmptyLines(FixedRowLeftFootNoteFreeHeight, MaximumRowLeftFootNoteWidth, Row.FootNote.Left.Color.Background);
        const FixedRowLeftFootNoteExtraPadding = FixedRowLeftFootNoteFreeHeight > 0 ? `\n${RowLeftFootNoteExtraPadding}` : ``;
        const FixedRowLeftFootNote = `${RowLeftFootNote}${FixedRowLeftFootNoteExtraPadding}`;
        const MaximumRowRightFootNoteWidth = Math.max(...Row.FootNote.Right.Text.split(/\n/).map((_el, _ind, _arr) => StringStylizationCleaner(_el).length));
        const RowRightFootNote = Row.FootNote.Right.Text.split(/\n/)
            .map((_el, _ind, _arr) => {
            const FullLinedFootNotePaddingLeftSize = 0;
            const FullLinedFootNotePaddingRightSize = MaximumRowRightFootNoteWidth - StringStylizationCleaner(_el).length;
            const FullLinedFootNotePaddingLeft = ``.padStart(FullLinedFootNotePaddingLeftSize, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default);
            const FullLinedFootNotePaddingRight = ``.padStart(FullLinedFootNotePaddingRightSize, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default);
            const FullLinedFootNoteText = `${FullLinedFootNotePaddingLeft}${_el}${FullLinedFootNotePaddingRight}`;
            const ColoredFootNoteText = ColorizeText(FullLinedFootNoteText, Row.FootNote.Left.Color.Entity);
            const ColoredFootNoteBackground = ColorizeBackground(ColoredFootNoteText, Row.FootNote.Left.Color.Background);
            return ColoredFootNoteBackground;
        })
            .join(`\n`);
        const FixedRowRightFootNoteHeight = RowRightFootNote.split(/\n/).length;
        const FixedRowRightFootNoteFreeHeight = MaximumRowCellHeight - FixedRowRightFootNoteHeight;
        const RowRightFootNoteExtraPadding = InsertEmptyLines(FixedRowRightFootNoteFreeHeight, MaximumRowRightFootNoteWidth, Row.FootNote.Right.Color.Background);
        const FixedRowRightFootNoteExtraPadding = FixedRowRightFootNoteFreeHeight > 0 ? `\n${RowRightFootNoteExtraPadding}` : ``;
        const FixedRowRightFootNote = `${RowRightFootNote}${FixedRowRightFootNoteExtraPadding}`;
        const FixedRowCellsByMaximumHeight = FixedRowCells.map((_el, _ind, _arr) => {
            const FixedRowCellText = _el.Text;
            const FixedRowCellHeight = FixedRowCellText.split(/\n/).length;
            const FixedRowCellFreeHeight = MaximumRowCellHeight - FixedRowCellHeight;
            const RowCellExtraPadding = InsertEmptyLines(FixedRowCellFreeHeight, _el.Width, _el.Color.Background);
            const FixedRowCellExtraPadding = FixedRowCellFreeHeight > 0 ? `\n${RowCellExtraPadding}` : ``;
            const FixedRowCellByMaximumHeight = {
                Text: `${FixedRowCellText}${FixedRowCellExtraPadding}`,
                Color: _el.Color,
                Width: _el.Width,
            };
            return FixedRowCellByMaximumHeight;
        });
        const FixedRow = {
            FootNote: {
                Left: {
                    Text: FixedRowLeftFootNote,
                    Color: Row.FootNote.Left.Color,
                    Width: MaximumRowLeftFootNoteWidth,
                },
                Right: {
                    Text: FixedRowRightFootNote,
                    Color: Row.FootNote.Right.Color,
                    Width: MaximumRowRightFootNoteWidth,
                },
            },
            Height: MaximumRowCellHeight,
            Cells: FixedRowCellsByMaximumHeight,
        };
        FixedRows.push(FixedRow);
    }
    const FixedRowsStringParts = [];
    for (let i = 0; i < FixedRows.length; i++) {
        const FixedRow = FixedRows[i];
        const FixedRowWidth = FixedRow.Cells.reduce((_prev, _curr, _currInd, _arr) => _prev + _curr.Width, 0) + FixedRow.Cells.length - 1;
        const FixedRowHeight = FixedRow.Height;
        const FixedRowCells = FixedRow.Cells;
        const MaximumFixedRowsLeftFootNoteWidth = Math.max(...FixedRows.map((_el, _ind, _arr) => _el.FootNote.Left.Width));
        const MaximumFixedRowsLeftFootNotePadding = ``.padStart(MaximumFixedRowsLeftFootNoteWidth, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default);
        const MaximumFixedRowsRightFootNoteWidth = Math.max(...FixedRows.map((_el, _ind, _arr) => _el.FootNote.Right.Width));
        const MaximumFixedRowsRightFootNotePadding = ``.padStart(MaximumFixedRowsRightFootNoteWidth, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default);
        const FixedRowStringParts = [];
        for (let j = 0; j < FixedRowHeight; j++) {
            const FixedRowHeightLevel = j;
            const VerticalBorder = ColorizeBorderSign(TableBorderSymbol.Line.Vertical[BorderType]);
            const FixedRowLeftFootNoteExtraPaddingLength = MaximumFixedRowsLeftFootNoteWidth - FixedRow.FootNote.Left.Width;
            const FixedRowLeftFootNoteExtraPadding = ``.padStart(FixedRowLeftFootNoteExtraPaddingLength, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default);
            const ColoredFixedRowLeftFootNoteExtraPadding = ColorizeBackground(FixedRowLeftFootNoteExtraPadding, FixedRow.FootNote.Left.Color.Background);
            const FixedRowLeftFootNoteHeightLevelToString = `${ColoredFixedRowLeftFootNoteExtraPadding}${FixedRow.FootNote.Left.Text.split(/\n/)[FixedRowHeightLevel]}`;
            const FixedRowRightFootNoteExtraPaddingLength = MaximumFixedRowsRightFootNoteWidth - FixedRow.FootNote.Right.Width;
            const FixedRowRightFootNoteExtraPadding = ``.padStart(FixedRowRightFootNoteExtraPaddingLength, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default);
            const ColoredFixedRowRightFootNoteExtraPadding = ColorizeBackground(FixedRowRightFootNoteExtraPadding, FixedRow.FootNote.Right.Color.Background);
            const FixedRowRightFootNoteHeightLevelToString = `${FixedRow.FootNote.Right.Text.split(/\n/)[FixedRowHeightLevel]}${ColoredFixedRowRightFootNoteExtraPadding}`;
            const FixedRowCellsHeightLevelsToString = FixedRowCells.map((_el, _ind, _arr) => _el.Text.split(/\n/)[FixedRowHeightLevel]);
            const FixedRowHeightLevelToString = `${FixedRowLeftFootNoteHeightLevelToString}${VerticalBorder}${FixedRowCellsHeightLevelsToString.join(VerticalBorder)}${VerticalBorder}${FixedRowRightFootNoteHeightLevelToString}`;
            FixedRowStringParts.push(FixedRowHeightLevelToString);
        }
        const FixedRowCellsIndexes = [];
        let FixedRowPreviousCellIndex = 0;
        for (let j = 0; j < FixedRowCells.length; j++) {
            const FixedRowPreviousCell = FixedRowCells[j];
            const FixedRowPreviousCellWidth = FixedRowPreviousCell.Width;
            const FixedRowPreviousCellConnectionIndex = FixedRowPreviousCellIndex + FixedRowPreviousCellWidth + j;
            FixedRowCellsIndexes.push(FixedRowPreviousCellConnectionIndex);
            FixedRowPreviousCellIndex = FixedRowPreviousCellConnectionIndex;
        }
        const IsFixedRowFirst = i === 0;
        const IsFixedRowLast = i === FixedRows.length - 1;
        const PreviousFixedRow = FixedRows[i - 1];
        const PreviousFixedRowCellsIndexes = [];
        let PreviousFixedRowPreviousCellIndex = 0;
        if (!IsFixedRowFirst) {
            const PreviousFixedRowCells = PreviousFixedRow.Cells;
            for (let j = 0; j < PreviousFixedRowCells.length; j++) {
                const PreviousFixedRowCell = PreviousFixedRowCells[j];
                const PreviousFixedRowCellWidth = PreviousFixedRowCell.Width;
                const PreviousFixedRowPreviousCellConnectionIndex = PreviousFixedRowPreviousCellIndex + PreviousFixedRowCellWidth + j;
                PreviousFixedRowCellsIndexes.push(PreviousFixedRowPreviousCellConnectionIndex);
                PreviousFixedRowPreviousCellIndex = PreviousFixedRowPreviousCellConnectionIndex;
            }
        }
        let FixedRowUpConnector = ``;
        for (let j = 0; j < FixedRowWidth; j++) {
            const FixedRowUpConnectorIndex = j;
            let ConnectorEntity = TableBorderSymbol.Line.Horizontal[BorderType];
            if (FixedRowCellsIndexes.includes(FixedRowUpConnectorIndex)) {
                if (PreviousFixedRowCellsIndexes.includes(FixedRowUpConnectorIndex)) {
                    ConnectorEntity = TableBorderSymbol.Connector.All[BorderType];
                }
                else {
                    ConnectorEntity = TableBorderSymbol.Connector.Bottom[BorderType];
                }
            }
            else {
                if (PreviousFixedRowCellsIndexes.includes(FixedRowUpConnectorIndex)) {
                    ConnectorEntity = TableBorderSymbol.Connector.Top[BorderType];
                }
                else {
                    ConnectorEntity = TableBorderSymbol.Line.Horizontal[BorderType];
                }
            }
            FixedRowUpConnector += ConnectorEntity;
        }
        const LeftCornerBorder = IsFixedRowFirst ? TableBorderSymbol.Corner.Bottom.Right[BorderType] : TableBorderSymbol.Connector.Right[BorderType];
        const RightCornerBorder = IsFixedRowFirst ? TableBorderSymbol.Corner.Bottom.Left[BorderType] : TableBorderSymbol.Connector.Left[BorderType];
        const FixedRowUpConnectorLine = ColorizeBorderSign(`${LeftCornerBorder}${FixedRowUpConnector}${RightCornerBorder}`);
        const FixedRowUpConnectorWithFootNotes = `${MaximumFixedRowsLeftFootNotePadding}${FixedRowUpConnectorLine}${MaximumFixedRowsRightFootNotePadding}`;
        FixedRowStringParts.unshift(FixedRowUpConnectorWithFootNotes);
        const LastFixedRowCellsIndexes = [];
        let LastFixedRowPreviousCellIndex = 0;
        if (IsFixedRowLast) {
            for (let j = 0; j < FixedRowCells.length; j++) {
                const LastFixedRowCell = FixedRowCells[j];
                const LastFixedRowCellWidth = LastFixedRowCell.Width;
                const LastFixedRowPreviousCellConnectionIndex = LastFixedRowPreviousCellIndex + LastFixedRowCellWidth + j;
                LastFixedRowCellsIndexes.push(LastFixedRowPreviousCellConnectionIndex);
                LastFixedRowPreviousCellIndex = LastFixedRowPreviousCellConnectionIndex;
            }
            let LastFixedRowUpConnector = ``;
            for (let j = 0; j < FixedRowWidth; j++) {
                const FixedRowUpConnectorIndex = j;
                let ConnectorEntity = TableBorderSymbol.Line.Horizontal[BorderType];
                if (LastFixedRowCellsIndexes.includes(FixedRowUpConnectorIndex)) {
                    ConnectorEntity = TableBorderSymbol.Connector.Top[BorderType];
                }
                else {
                    ConnectorEntity = TableBorderSymbol.Line.Horizontal[BorderType];
                }
                LastFixedRowUpConnector += ConnectorEntity;
            }
            const LastLeftCornerBorder = TableBorderSymbol.Corner.Top.Right[BorderType];
            const LastRightCornerBorder = TableBorderSymbol.Corner.Top.Left[BorderType];
            const LastFixedRowUpConnectorLine = ColorizeBorderSign(`${LastLeftCornerBorder}${LastFixedRowUpConnector}${LastRightCornerBorder}`);
            const LastFixedRowUpConnectorWithFootNotes = `${MaximumFixedRowsLeftFootNotePadding}${LastFixedRowUpConnectorLine}${MaximumFixedRowsRightFootNotePadding}`;
            FixedRowStringParts.push(LastFixedRowUpConnectorWithFootNotes);
        }
        FixedRowsStringParts.push(FixedRowStringParts.join(`\n`));
    }
    const CompletedTable = FixedRowsStringParts.join(`\n`);
    const TableMarginLeftToString = ``.padStart(margin, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default);
    const CompletedTableRows = CompletedTable.split(/\n/).map((_el, _ind, _arr) => `${TableMarginLeftToString}${_el}`);
    const ResultTable = CompletedTableRows.join(`\n`);
    return ResultTable;
}
//# sourceMappingURL=Table.js.map