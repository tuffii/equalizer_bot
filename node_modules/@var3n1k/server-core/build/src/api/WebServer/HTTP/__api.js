import * as GlobalModule from '../../../module/@module.js';
import * as BaseAPI from '../../BaseAPI.js';
import * as Router from './router/__router.js';
import * as Dependencies from './__dependencies.js';
class HTTPWebServerResponder {
    // TODO: JSDoc
    __API;
    // TODO: JSDoc
    __InitialResponse;
    // TODO: JSDoc
    async Text(code, responseHeaders, responseData) {
        await this.__Text(code, responseHeaders, responseData);
    }
    // TODO: JSDoc
    async JSON(code, responseHeaders, responseData) {
        await this.__JSON(code, responseHeaders, responseData);
    }
    // TODO: JSDoc
    async File(code, responseHeaders, absoluteFilePath) {
        await this.__File(code, responseHeaders, absoluteFilePath);
    }
    // TODO: JSDoc
    constructor(api, initialResponse) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(api, new Validator().Default.Class.Instance().Required().Of(HTTPWebServerAPI));
        this.__API = api;
        this.__InitialResponse = initialResponse;
    }
    // TODO: JSDoc
    async __Text(code, responseHeaders, responseData) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(code, new Validator().Default.Numeric().Number().Required().Integer().Min(0));
        Validator.Strict(responseHeaders, new Validator().Default.Object().Required());
        Validator.Strict(responseData, new Validator().Default.String().Required());
        this.__InitialResponse.writeContinue();
        this.__InitialResponse.writeProcessing();
        try {
            const BaseResponseHeaders = {
                'Content-Type': `text/plain; charset=utf-8`,
                'Content-Length': `${responseData.length}`,
            };
            const ExistingResponseHeaders = this.__InitialResponse.getHeaders();
            const InitialResponseHeaders = responseHeaders;
            const ResponseHeaders = Object.assign({}, BaseResponseHeaders, ExistingResponseHeaders, InitialResponseHeaders);
            const ResponseHeadersNames = GlobalModule.Functions.Parameter.Type.Manager.Default.Object.GetProperties(ResponseHeaders);
            for (let i = 0; i < ResponseHeadersNames.length; i++) {
                const ResponseHeadersName = ResponseHeadersNames[i];
                const ResponseHeadersValue = ResponseHeaders[ResponseHeadersName];
                this.__InitialResponse.setHeader(ResponseHeadersName, ResponseHeadersValue);
            }
            const ResponseEntity = this.__InitialResponse.status(code).send(responseData);
        }
        catch (APIError) {
            GlobalModule.Classes.Console.Log.Preset.Warn(`При отправке ответа с сервера произошла непредвиденная ошибка`);
            const IsAPIErrorOccured = Validator.TypeGuard.Default.IsError(APIError);
            if (IsAPIErrorOccured) {
                throw APIError;
            }
        }
    }
    // TODO: JSDoc
    async __JSON(code, responseHeaders, responseData) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(code, new Validator().Default.Numeric().Number().Required().Integer().Min(0));
        Validator.Strict(responseHeaders, new Validator().Default.Object().Required());
        Validator.Strict(responseData, new Validator().Default.Object().Required());
        this.__InitialResponse.writeContinue();
        this.__InitialResponse.writeProcessing();
        try {
            const InitialResponseDataToJSON = JSON.stringify(responseData, (key, value) => {
                const IsValueUnknown = Validator.TypeGuard.Default.IsUnknown(value);
                const JSONValue = IsValueUnknown ? null : value;
                return JSONValue;
            });
            const InitialResponseData = JSON.parse(InitialResponseDataToJSON);
            const BaseResponseHeaders = {
                'Content-Type': `application/json; charset=utf-8`,
                'Content-Length': `${InitialResponseDataToJSON.length}`,
            };
            const ExistingResponseHeaders = this.__InitialResponse.getHeaders();
            const InitialResponseHeaders = responseHeaders;
            const ResponseHeaders = Object.assign({}, BaseResponseHeaders, ExistingResponseHeaders, InitialResponseHeaders);
            const ResponseHeadersNames = GlobalModule.Functions.Parameter.Type.Manager.Default.Object.GetProperties(ResponseHeaders);
            for (let i = 0; i < ResponseHeadersNames.length; i++) {
                const ResponseHeadersName = ResponseHeadersNames[i];
                const ResponseHeadersValue = ResponseHeaders[ResponseHeadersName];
                this.__InitialResponse.setHeader(ResponseHeadersName, ResponseHeadersValue);
            }
            const ResponseEntity = this.__InitialResponse.status(code).json(InitialResponseData);
        }
        catch (APIError) {
            GlobalModule.Classes.Console.Log.Preset.Warn(`При отправке ответа с сервера произошла непредвиденная ошибка`);
            const IsAPIErrorOccured = Validator.TypeGuard.Default.IsError(APIError);
            if (IsAPIErrorOccured) {
                throw APIError;
            }
        }
    }
    // TODO: JSDoc
    async __File(code, responseHeaders, absoluteFilePath) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(code, new Validator().Default.Numeric().Number().Required().Integer().Min(0));
        Validator.Strict(responseHeaders, new Validator().Default.Object().Required());
        Validator.Strict(absoluteFilePath, new Validator().Custom.FileSystem.Location.URL().File().Required().Or(new Validator().Custom.FileSystem.Location.Path().File().Required()));
        const FormattedAbsoluteFilePath = GlobalModule.Classes.FileSystem.FormatPath(absoluteFilePath);
        Validator.Strict(FormattedAbsoluteFilePath, new Validator().Custom.FileSystem.Entity.File().Required().Exist().Reachable().Readable());
        this.__InitialResponse.writeContinue();
        this.__InitialResponse.writeProcessing();
        try {
            const BaseResponseHeaders = {};
            const ExistingResponseHeaders = this.__InitialResponse.getHeaders();
            const InitialResponseHeaders = responseHeaders;
            const ResponseHeaders = Object.assign({}, BaseResponseHeaders, ExistingResponseHeaders, InitialResponseHeaders);
            const ResponseHeadersNames = GlobalModule.Functions.Parameter.Type.Manager.Default.Object.GetProperties(ResponseHeaders);
            for (let i = 0; i < ResponseHeadersNames.length; i++) {
                const ResponseHeadersName = ResponseHeadersNames[i];
                const ResponseHeadersValue = ResponseHeaders[ResponseHeadersName];
                this.__InitialResponse.setHeader(ResponseHeadersName, ResponseHeadersValue);
            }
            this.__InitialResponse.status(code).sendFile(FormattedAbsoluteFilePath, (APIError) => {
                const IsAPIErrorOccured = Validator.TypeGuard.Default.IsError(APIError);
                if (IsAPIErrorOccured) {
                    throw APIError;
                }
            });
        }
        catch (APIError) {
            GlobalModule.Classes.Console.Log.Preset.Warn(`При отправке ответа с сервера произошла непредвиденная ошибка`);
            const IsAPIErrorOccured = Validator.TypeGuard.Default.IsError(APIError);
            if (IsAPIErrorOccured) {
                throw APIError;
            }
        }
    }
}
const EventName = {
    Init: `init`,
    Request: {
        Any: `requestAny`,
        Method: {
            Get: `requestMethod${Router.HTTPRequestMethod.Get}`,
            Post: `requestMethod${Router.HTTPRequestMethod.Post}`,
            Patch: `requestMethod${Router.HTTPRequestMethod.Patch}`,
            Put: `requestMethod${Router.HTTPRequestMethod.Put}`,
            Update: `requestMethod${Router.HTTPRequestMethod.Update}`,
            Delete: `requestMethod${Router.HTTPRequestMethod.Delete}`,
        },
    },
};
export * as Router from './router/__router.js';
class HTTPWebServerAPI extends BaseAPI.default {
    // TODO: JSDoc
    static Event = { Name: EventName };
    // TODO: JSDoc
    Event = { Emitter: new GlobalModule.Classes.EventEmitter() };
    // TODO: JSDoc
    Server;
    // TODO: JSDoc
    Host;
    // TODO: JSDoc
    Source;
    // TODO: JSDoc
    static Request = {
        Method: Router.HTTPRequestMethod,
    };
    // TODO: JSDoc
    static Response = {
        Code: {
            Name: Router.HTTPResponseCodeName,
        },
    };
    // TODO: JSDoc
    async GetRequestBody(initialRequest) {
        const RequestBody = await this.__GetRequestBody(initialRequest);
        return RequestBody;
    }
    // TODO: JSDoc
    Handle(...routers) {
        this.__Handle(...routers);
    }
    // TODO: JSDoc
    async Init() {
        await this.__Init();
    }
    // TODO: JSDoc
    constructor(isRemote, isSecure, domain, port, relativeClientFolder) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(isRemote, new Validator().Default.Boolean().Required());
        Validator.Strict(isSecure, new Validator().Default.Boolean().Required());
        Validator.Strict(domain, new Validator().Default.String().Required().MinLength(1));
        Validator.Strict(port, new Validator().Default.Numeric().Number().Required().Integer().Min(0));
        Validator.Strict(relativeClientFolder, new Validator().Default.String().Required());
        const FormattedRelativeClientFolder = GlobalModule.Classes.FileSystem.FormatPath(relativeClientFolder);
        const AbsoluteRootDirectory = GlobalModule.Classes.FileSystem.FormatPath(GlobalModule.Classes.Process.Source.Directory.Path.Get());
        const AbsoluteClientFolder = GlobalModule.Classes.FileSystem.FormatPath(GlobalModule.Dependencies.Default.Node.path.join(AbsoluteRootDirectory, FormattedRelativeClientFolder));
        Validator.Strict(AbsoluteClientFolder, new Validator().Custom.FileSystem.Entity.Directory().Required().Exist());
        const APIFullTag = (tags) => {
            Validator.Strict(tags, new Validator().Default.Array().Required().Of(new Validator().Default.String().Required().MinLength(1)));
            const ServerURL = GlobalModule.Functions.Parameter.Type.Manager.Custom.URL.FormURL(isRemote, isSecure, domain, port);
            const FullTagParameters = [];
            FullTagParameters.push(`HTTP Server`);
            FullTagParameters.push(...tags);
            FullTagParameters.push(`${ServerURL}`);
            const SpaceSymbol = GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default;
            const FullTag = FullTagParameters.join(`${SpaceSymbol}|${SpaceSymbol}`);
            return FullTag;
        };
        const APITag = {
            Text: APIFullTag([]),
            Color: GlobalModule.Functions.Parameter.Type.Manager.Custom.Color.HEXToRGB(`#FF5500`),
        };
        super({
            Tag: {
                Text: APITag.Text,
                Color: APITag.Color,
            },
        });
        this.Source = {
            Client: {
                Folder: AbsoluteClientFolder,
            },
        };
        this.Host = {
            Domain: domain,
            Port: port,
            Connection: {
                Remote: isRemote,
                Secure: isSecure,
            },
        };
        this.Server = Dependencies.express();
        this.Server.use(Dependencies.express.static(this.Source.Client.Folder), async (request, response) => {
            response.setHeader(`Allow`, `*`);
            response.setHeader(`Accept`, `*/*`);
            response.setHeader(`Access-Control-Allow-Origin`, `*`);
            response.setHeader(`Access-Control-Request-Method`, `*`);
            response.setHeader(`Access-Control-Request-Headers`, `*`);
            response.setHeader(`Access-Control-Allow-Methods`, `*`);
            response.setHeader(`Access-Control-Allow-Headers`, `*`);
            response.setHeader(`Access-Control-Expose-Headers`, `*`);
            response.setHeader(`Access-Control-Max-Age`, 2592000);
            await this.__RedirectRequest(request, response);
        });
        this.__RegisterMetrics();
    }
    // TODO: JSDoc
    __Handle(...routers) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(routers, new Validator().Default.Array().Required().Of(new Validator().Default.Class.Instance().Required().Of(Router.default)).MinLength(1));
        for (let i = 0; i < routers.length; i++) {
            const Router = routers[i];
            Router.Connect(this);
        }
    }
    // TODO: JSDoc
    async __RedirectRequest(request, response) {
        const Validator = GlobalModule.Classes.Validator;
        const RequestMethod = request.method;
        const DoesRequestMethodExist = !Validator.TypeGuard.Default.IsNullOrUndefined(RequestMethod);
        if (!DoesRequestMethodExist)
            return;
        const RequestIP = request.ip;
        const DoesRequestIPExist = !Validator.TypeGuard.Default.IsNullOrUndefined(RequestIP);
        if (!DoesRequestIPExist)
            return;
        const RequestPort = request.socket.remotePort;
        const DoesRequestPortExist = !Validator.TypeGuard.Default.IsNullOrUndefined(RequestPort);
        if (!DoesRequestPortExist)
            return;
        const RequestProtocol = request.protocol;
        const DoesRequestProtocolExist = !Validator.TypeGuard.Default.IsNullOrUndefined(RequestProtocol);
        if (!DoesRequestProtocolExist)
            return;
        const IsRequestSecure = request.secure;
        const DoesIsRequestSecureExist = !Validator.TypeGuard.Default.IsNullOrUndefined(IsRequestSecure);
        if (!DoesIsRequestSecureExist)
            return;
        const RequestEndPoint = request.url;
        const DoesRequestEndPointExist = !Validator.TypeGuard.Default.IsNullOrUndefined(RequestEndPoint);
        if (!DoesRequestEndPointExist)
            return;
        const RequestHeaders = request.headers;
        const DoesRequestHeaderExist = !Validator.TypeGuard.Default.IsNullOrUndefined(RequestHeaders);
        if (!DoesRequestHeaderExist)
            return;
        const RequestHost = RequestHeaders.host;
        const DoesRequestHostExist = !Validator.TypeGuard.Default.IsNullOrUndefined(RequestHost);
        if (!DoesRequestHostExist)
            return;
        const RequestURL = GlobalModule.Dependencies.Default.Node.url.parse(`${RequestHost}${RequestEndPoint}`);
        const EmptyRequestBody = ``;
        const RequestURLToString = RequestURL.href;
        const DoesRequestURLToStringExist = !Validator.TypeGuard.Default.IsNullOrUndefined(RequestURLToString);
        if (!DoesRequestURLToStringExist)
            return;
        const InitialRequestEndpoint = RequestURL.path;
        const DoesInitialRequestEndpointExist = !Validator.TypeGuard.Default.IsNullOrUndefined(InitialRequestEndpoint);
        const FixedInitialRequestEndpoint = DoesInitialRequestEndpointExist ? InitialRequestEndpoint : `/`;
        const InitialRequestEndpointElements = FixedInitialRequestEndpoint.split(/\//).filter((_el, _ind, _arr) => !Validator.TypeGuard.Default.IsEmptyString(_el));
        const InitialRequestEndpointFirstElement = InitialRequestEndpointElements[0];
        const IsEndpointFromRemoteDomain = this.Host.Connection.Remote && InitialRequestEndpointFirstElement === this.Host.Domain;
        const FixedRequestEndpointElements = IsEndpointFromRemoteDomain ? InitialRequestEndpointElements.slice(1, InitialRequestEndpointElements.length) : InitialRequestEndpointElements;
        const FixedRequestEndpoint = `/${FixedRequestEndpointElements.join(`/`)}`;
        const RequestQuery = request.query;
        const DoesRequestQueryExist = !Validator.TypeGuard.Default.IsNullOrUndefined(RequestQuery);
        const FormRequestParameters = (requestBody) => {
            const DoesRequestBodyExist = !Validator.TypeGuard.Default.IsNullOrUndefined(requestBody);
            const Responder = new HTTPWebServerResponder(this, response);
            const Request = {
                Entity: request,
                Sender: {
                    IP: RequestIP,
                    Port: RequestPort,
                },
                Connection: {
                    Protocol: RequestProtocol,
                    IsSecure: IsRequestSecure,
                },
                Destination: {
                    URL: RequestURLToString,
                    Endpoint: FixedRequestEndpoint,
                    Query: DoesRequestQueryExist ? RequestQuery : {},
                },
                Headers: RequestHeaders,
                Body: DoesRequestBodyExist ? requestBody : EmptyRequestBody,
            };
            const Response = {
                Entity: response,
                Responder: Responder,
            };
            const RequestParameters = [Request, Response];
            return RequestParameters;
        };
        const ToUpperCase = GlobalModule.Functions.Parameter.Type.Manager.Default.String.Style.Modify.Case.Size.ToUpperCase;
        const CaseIgoredRequestMethod = ToUpperCase(RequestMethod, Array.from(Array(RequestMethod.length), (_el, _ind) => _ind));
        let RequestBody = EmptyRequestBody;
        if (CaseIgoredRequestMethod === Router.HTTPRequestMethod.Get) {
            RequestBody = EmptyRequestBody;
        }
        else if (CaseIgoredRequestMethod === Router.HTTPRequestMethod.Post) {
            RequestBody = await this.__GetRequestBody(request);
        }
        else if (CaseIgoredRequestMethod === Router.HTTPRequestMethod.Patch) {
            RequestBody = await this.__GetRequestBody(request);
        }
        else if (CaseIgoredRequestMethod === Router.HTTPRequestMethod.Put) {
            RequestBody = await this.__GetRequestBody(request);
        }
        else if (CaseIgoredRequestMethod === Router.HTTPRequestMethod.Update) {
            RequestBody = EmptyRequestBody;
        }
        else if (CaseIgoredRequestMethod === Router.HTTPRequestMethod.Delete) {
            RequestBody = EmptyRequestBody;
        }
        const RequestParameters = FormRequestParameters(RequestBody);
        this.Event.Emitter.Emit(HTTPWebServerAPI.Event.Name.Request.Any, CaseIgoredRequestMethod, ...RequestParameters);
    }
    // TODO: JSDoc
    async __GetRequestBody(initialRequest) {
        const Validator = GlobalModule.Classes.Validator;
        return new Promise(async (resolve, reject) => {
            const RequestDataStream = [];
            initialRequest
                .on(`error`, (APIError) => {
                this.Log.Preset.Warn(`При получении тела запроса с клиента произошла непредвиденная ошибка`);
                this.Log.Preset.Error(APIError, false);
            })
                .on(`data`, (chunk) => {
                RequestDataStream.push(chunk);
            })
                .on(`end`, () => {
                const IsRequestDataStreamEmpty = Validator.TypeGuard.Default.IsEmptyArray(RequestDataStream);
                if (IsRequestDataStreamEmpty) {
                    resolve(undefined);
                }
                else {
                    const RequestDataToString = Buffer.concat(RequestDataStream).toString();
                    // const RequestData = ParseRequestBody(RequestDataToString)
                    resolve(RequestDataToString);
                }
            });
        });
    }
    // TODO: JSDoc
    __RegisterRequestHandler() {
        const Validator = GlobalModule.Classes.Validator;
        this.Event.Emitter.On(HTTPWebServerAPI.Event.Name.Request.Any, async (method, request, response) => {
            this.Log.Preset.Info(`Получен запрос с методом ${method} по эндпоинту '${request.Destination.Endpoint}' от ${request.Sender.IP}:${request.Sender.Port}`);
            if (method === Router.HTTPRequestMethod.Get) {
                this.Event.Emitter.Emit(HTTPWebServerAPI.Event.Name.Request.Method.Get, request, response);
            }
            else if (method === Router.HTTPRequestMethod.Post) {
                this.Event.Emitter.Emit(HTTPWebServerAPI.Event.Name.Request.Method.Post, request, response);
            }
            else if (method === Router.HTTPRequestMethod.Patch) {
                this.Event.Emitter.Emit(HTTPWebServerAPI.Event.Name.Request.Method.Patch, request, response);
            }
            else if (method === Router.HTTPRequestMethod.Put) {
                this.Event.Emitter.Emit(HTTPWebServerAPI.Event.Name.Request.Method.Put, request, response);
            }
            else if (method === Router.HTTPRequestMethod.Update) {
                this.Event.Emitter.Emit(HTTPWebServerAPI.Event.Name.Request.Method.Update, request, response);
            }
            else if (method === Router.HTTPRequestMethod.Delete) {
                this.Event.Emitter.Emit(HTTPWebServerAPI.Event.Name.Request.Method.Delete, request, response);
            }
        });
    }
    // TODO: JSDoc
    __RegisterInitializationHandler() {
        this.Event.Emitter.On(HTTPWebServerAPI.Event.Name.Init, () => {
            const FormURL = GlobalModule.Functions.Parameter.Type.Manager.Custom.URL.FormURL;
            const ServerURL = FormURL(this.Host.Connection.Remote, this.Host.Connection.Secure, this.Host.Domain, this.Host.Port);
            this.Log.Preset.Info(`HTTP сервер запущен на порту`, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default, this.Host.Port, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default, `(${ServerURL})`);
        });
    }
    // TODO: JSDoc
    __RegisterHandlers() {
        this.__RegisterRequestHandler();
        this.__RegisterInitializationHandler();
    }
    // TODO: JSDoc
    __RegisterMetrics() {
        this.__RegisterHandlers();
    }
    // TODO: JSDoc
    async __Init() {
        this.Log.Preset.Info(`Инициализация HTTP сервера`);
        const Launch = async () => {
            return new Promise(async (resolve, reject) => {
                const LocalDomain = this.Host.Connection.Remote ? `localhost` : this.Host.Domain;
                this.Server.listen(this.Host.Port, LocalDomain, () => {
                    this._SetReady(true);
                    this.Event.Emitter.Emit(HTTPWebServerAPI.Event.Name.Init);
                    resolve(undefined);
                });
            });
        };
        await Launch();
    }
}
export default HTTPWebServerAPI;
//# sourceMappingURL=__api.js.map