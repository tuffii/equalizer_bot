import * as GlobalModule from '../../../../module/@module.js';
import * as HTTPWebServerAPI from '../__api.js';
export const HTTPRequestMethod = {
    Get: `GET`,
    Post: `POST`,
    Patch: `PATCH`,
    Put: `PUT`,
    Update: `UPDATE`,
    Delete: `DELETE`,
};
export const HTTPResponseCodeName = GlobalModule.Dependencies.Default.Node.http.STATUS_CODES;
export default class Router {
    // TODO: JSDoc
    __Handlers = [];
    // TODO: JSDoc
    get On() {
        const Validator = GlobalModule.Classes.Validator;
        const On = {
            Get: (_, ...__) => {
                const NewHTTPRequestHandler = this.__FormNewHTTPRequestHandler(HTTPRequestMethod.Get, _, __);
                this.__Handlers.push(NewHTTPRequestHandler);
            },
            Post: (_, ...__) => {
                const NewHTTPRequestHandler = this.__FormNewHTTPRequestHandler(HTTPRequestMethod.Post, _, __);
                this.__Handlers.push(NewHTTPRequestHandler);
            },
            Patch: (_, ...__) => {
                const NewHTTPRequestHandler = this.__FormNewHTTPRequestHandler(HTTPRequestMethod.Patch, _, __);
                this.__Handlers.push(NewHTTPRequestHandler);
            },
            Put: (_, ...__) => {
                const NewHTTPRequestHandler = this.__FormNewHTTPRequestHandler(HTTPRequestMethod.Put, _, __);
                this.__Handlers.push(NewHTTPRequestHandler);
            },
            Update: (_, ...__) => {
                const NewHTTPRequestHandler = this.__FormNewHTTPRequestHandler(HTTPRequestMethod.Update, _, __);
                this.__Handlers.push(NewHTTPRequestHandler);
            },
            Delete: (_, ...__) => {
                const NewHTTPRequestHandler = this.__FormNewHTTPRequestHandler(HTTPRequestMethod.Delete, _, __);
                this.__Handlers.push(NewHTTPRequestHandler);
            },
        };
        return On;
    }
    // TODO: JSDoc
    Add(endpointPrefix, routers) {
        this.__Add(endpointPrefix, routers);
    }
    // TODO: JSDoc
    Connect(api) {
        this.__Connect(api);
    }
    // TODO: JSDoc
    constructor() { }
    // TODO: JSDoc
    __Add(endpointPrefix, routers) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(endpointPrefix, new Validator().Default.String().Required().MinLength(1));
        Validator.Strict(routers, new Validator().Default.Array().Required().Of(new Validator().Default.Class.Instance().Required().Of(Router)).MinLength(1));
        for (let i = 0; i < routers.length; i++) {
            const NewRouter = routers[i];
            const NewRouterHandlers = GlobalModule.Functions.Parameter.Type.Manager.Default.Array.Copy(NewRouter.__Handlers);
            const ConnectedRouterHandlers = NewRouterHandlers.map((_el, _ind, _arr) => {
                const NewRouterHandlerEndpoint = _el.Endpoint;
                const ConnectedRouterHandlerEndpoint = [endpointPrefix, NewRouterHandlerEndpoint].join(`/`).replace(/[\/]+/g, `/`);
                const ConnectedRouterHandler = {
                    Method: _el.Method,
                    Endpoint: ConnectedRouterHandlerEndpoint,
                    Callbacks: _el.Callbacks,
                };
                return ConnectedRouterHandler;
            });
            this.__Handlers.push(...ConnectedRouterHandlers);
        }
    }
    // TODO: JSDoc
    __Connect(api) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(api, new Validator().Default.Class.Instance().Required().Of(HTTPWebServerAPI.default));
        this.__RegisterRequestHandler(api);
    }
    // TODO: JSDoc
    __FormNewHTTPRequestHandler(method, endpoint, callbacks) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(method, new Validator().Default.String()
            .Required()
            .In([HTTPRequestMethod.Get, HTTPRequestMethod.Post, HTTPRequestMethod.Patch, HTTPRequestMethod.Put, HTTPRequestMethod.Update, HTTPRequestMethod.Delete]));
        Validator.Strict(endpoint, new Validator().Default.String().Required().MinLength(1)); // .Or(new Validator().Default.RegExp().Required())
        Validator.Strict(callbacks, new Validator().Default.Array().Required().Of(new Validator().Default.Function().Required()).MinLength(1));
        const NewHTTPRequestHandler = {
            Method: method,
            Endpoint: endpoint,
            Callbacks: callbacks,
        };
        return NewHTTPRequestHandler;
    }
    // TODO: JSDoc
    __IsEndpointMatched(expectedEndpoint, receivedEndpoint) {
        const ExpectedEndpointPaths = expectedEndpoint.split(/\//);
        const ExpectedEndpointPattern = new RegExp(`^${ExpectedEndpointPaths.map((_el, _ind, _arr) => {
            let ExpectedEndpointPathPattern = _el;
            if (_el === `*`) {
                ExpectedEndpointPathPattern = `[^\\/]*`;
            }
            else if (_el === `**`) {
                ExpectedEndpointPathPattern = `.*`;
            }
            return ExpectedEndpointPathPattern;
        }).join(`\\/`)}$`);
        const EndpointMatch = ExpectedEndpointPattern.test(receivedEndpoint);
        return EndpointMatch;
    }
    // TODO: JSDoc
    __RegisterRequestHandler(api) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(api, new Validator().Default.Class.Instance().Required().Of(HTTPWebServerAPI.default));
        api.Event.Emitter.On(HTTPWebServerAPI.default.Event.Name.Request.Any, async (_, __, ___) => {
            const EndPointRequestHandlers = this.__Handlers.filter((_el, _ind, _arr) => this.__IsEndpointMatched(_el.Endpoint, __.Destination.Endpoint));
            const DoesEndPointRequestHandlerExist = !Validator.TypeGuard.Default.IsEmptyArray(EndPointRequestHandlers);
            if (!DoesEndPointRequestHandlerExist) {
                await ___.Responder.JSON(400, {}, { message: `Unknown request endpoint` });
                api.Log.Preset.Warn(`Для запроса по эндпоинту '${__.Destination.Endpoint}' не назначено ни одного обработчика`);
            }
            else {
                const MethodRequestHandlers = EndPointRequestHandlers.filter((_el, _ind, _arr) => _el.Method === _);
                const DoesMethodRequestHandlerExist = !Validator.TypeGuard.Default.IsEmptyArray(MethodRequestHandlers);
                if (!DoesMethodRequestHandlerExist) {
                    await ___.Responder.JSON(405, {}, { message: `Method not allowed` });
                    api.Log.Preset.Warn(`Для запроса с методом ${_} по эндпоинту '${__.Destination.Endpoint}' не назначено ни одного обработчика`);
                }
                else {
                    await this.__HandleMethodRequests(api, MethodRequestHandlers, __, ___);
                }
            }
        });
    }
    // TODO: JSDoc
    async __HandleRequest(api, endpoint, callbacks, parameters) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(api, new Validator().Default.Class.Instance().Required().Of(HTTPWebServerAPI.default));
        Validator.Strict(endpoint, new Validator().Default.String().Required().MinLength(1));
        Validator.Strict(callbacks, new Validator().Default.Array().Required().Of(new Validator().Default.Function().Required()).MinLength(1));
        Validator.Strict(parameters, new Validator().Default.Array().Required().Length(2));
        const Request = parameters[0];
        const Response = parameters[1];
        const RequestMethod = Request.Entity.method;
        const RequestIP = Request.Sender.IP;
        const RequestPort = Request.Sender.Port;
        const ResponseSent = () => Response.Entity.closed || Response.Entity.destroyed || !Response.Entity.writable || Response.Entity.headersSent;
        const ProceededCallbacks = [];
        for (let i = 0; i < callbacks.length; i++) {
            const RequestCallbackFunction = callbacks[i];
            const IsResponseSent = ResponseSent();
            if (IsResponseSent)
                continue;
            try {
                await RequestCallbackFunction(...parameters);
                ProceededCallbacks.push(RequestCallbackFunction);
            }
            catch (APIError) {
                api.Log.Preset.Warn(`При обработке запроса с методом ${RequestMethod} по эндпоинту '${Request.Destination.Endpoint}' от ${RequestIP}:${RequestPort} произошла непредвиденная ошибка`);
                await Response.Responder.JSON(500, {}, { message: `Internal server error in request's callback [${i}]` });
                const IsAPIErrorOccured = Validator.TypeGuard.Default.IsError(APIError);
                if (IsAPIErrorOccured) {
                    api.Log.Preset.Error(APIError, false);
                }
            }
        }
        const DoesProceededCallbackExist = !Validator.TypeGuard.Default.IsEmptyArray(ProceededCallbacks);
        if (DoesProceededCallbackExist) {
            const IsResponseSent = ResponseSent();
            if (IsResponseSent) {
                api.Log.Preset.Info(`Запрос с методом ${RequestMethod} по эндпоинту '${Request.Destination.Endpoint}' от ${RequestIP}:${RequestPort} обработан`);
            }
            else {
                api.Log.Preset.Warn(`После обработки запроса с методом ${RequestMethod} по эндпоинту '${Request.Destination.Endpoint}' клиенту ${RequestIP}:${RequestPort} не было передано никакого ответа`);
            }
        }
    }
    // TODO: JSDoc
    async __HandleMethodRequests(api, handlers, request, response) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(api, new Validator().Default.Class.Instance().Required().Of(HTTPWebServerAPI.default));
        Validator.Strict(handlers, new Validator().Default.Array().Required().Of(new Validator().Default.Object().Required()));
        Validator.Strict(request, new Validator().Default.Object().Required());
        Validator.Strict(response, new Validator().Default.Object().Required());
        const TriggerHandler = async (requestHandler) => {
            const RequestParameters = [api, requestHandler.Endpoint, requestHandler.Callbacks, [request, response]];
            await this.__HandleRequest(...RequestParameters);
        };
        await Promise.all(handlers.map((_el, _ind, _arr) => TriggerHandler(_el)));
    }
}
//# sourceMappingURL=__router.js.map