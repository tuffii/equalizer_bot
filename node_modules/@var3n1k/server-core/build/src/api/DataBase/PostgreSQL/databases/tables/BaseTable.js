import * as GlobalModule from '../../../../../module/@module.js';
import * as PostgreSQLAPI from '../../__api.js';
const ConditionOperand = {
    Default: {
        Single: {
            MoreThan: `>`,
            MoreThanOrEqual: `>=`,
            EqualTo: `=`,
            LessThan: `<`,
            LessThanOrEqual: `<=`,
        },
        Multiple: {
            Conjunction: `AND`,
            Disjunction: `OR`,
        },
    },
    Inverse: `NOT`,
    Like: `LIKE`,
};
export const DataType = {
    String: {
        Char: `CHAR`,
        VarChar: `VARCHAR`,
        Binary: `BINARY`,
        VarBinary: `VARBINARY`,
        TinyText: `TINYBLOB`,
        TinyBlob: `TINYTEXT`,
        Text: `TEXT`,
        Blob: `BLOB`,
        MediumText: `MEDIUMTEXT`,
        MediumBlob: `MEDIUMBLOB`,
        LongText: `LONGTEXT`,
        LongBlob: `LONGBLOB`,
    },
    Numeric: {
        Bit: `BIT`,
        TinyInt: `TINYINT`,
        SmallInt: `SMALLINT`,
        MediumInt: `MEDIUMINT`,
        Int: `INT`,
        Integer: `INTEGER`,
        Serial: `SERIAL`,
        BigInt: `BIGINT`,
        Float: `FLOAT`,
        Double: `DOUBLE`,
        Decimal: `DECIMAL`,
        Dec: `DEC`, // (255)
    },
    Date: {
        Date: `DATE`,
        DateTime: `DATETIME`,
        TimeStamp: `TIMESTAMP`,
        Time: `TIME`,
        Year: `YEAR`,
    },
    Other: {
        Bool: `BOOL`,
        Boolean: `BOOLEAN`,
    },
};
const FormatValueToStringQuery = (value) => {
    const Validator = GlobalModule.Classes.Validator;
    let FormattedValue = `${value}`;
    if (Validator.TypeGuard.Default.IsUnknown(value)) {
        FormattedValue = `null`;
    }
    else {
        if (Validator.TypeGuard.Default.IsString(value)) {
            FormattedValue = `'${value}'`;
        }
        if (Validator.TypeGuard.Default.IsDate(value)) {
            FormattedValue = `${value.toString()}`;
        }
    }
    return FormattedValue;
};
const FormatValueFromStringQuery = (value, convertType) => {
    const Validator = GlobalModule.Classes.Validator;
    let FormattedValue = value;
    if (Validator.TypeGuard.Default.IsUnknown(value)) {
        FormattedValue = undefined;
    }
    else {
        if (convertType === DataType.String.Char ||
            convertType === DataType.String.VarChar ||
            convertType === DataType.String.TinyText ||
            convertType === DataType.String.Text ||
            convertType === DataType.String.MediumText ||
            convertType === DataType.String.LongText) {
            FormattedValue = `${value}`;
        }
        if (convertType === DataType.Numeric.BigInt) {
            FormattedValue = BigInt(value);
        }
        if (convertType === DataType.Numeric.TinyInt ||
            convertType === DataType.Numeric.SmallInt ||
            convertType === DataType.Numeric.MediumInt ||
            convertType === DataType.Numeric.Int ||
            convertType === DataType.Numeric.Integer ||
            convertType === DataType.Numeric.Serial) {
            FormattedValue = Number.parseInt(value);
        }
        if (convertType === DataType.Numeric.Float || convertType === DataType.Numeric.Double) {
            FormattedValue = Number.parseFloat(value);
        }
        if (convertType === DataType.Date.Date) {
            FormattedValue = new Date(value);
        }
        if (convertType === DataType.Date.DateTime || convertType === DataType.Date.TimeStamp || convertType === DataType.Date.Time || convertType === DataType.Date.Year) {
            FormattedValue = Number.parseInt(value);
        }
        if (convertType === DataType.Other.Bool || convertType === DataType.Other.Boolean) {
            FormattedValue = Boolean(value);
        }
    }
    return FormattedValue;
};
export default class BaseTable {
    // TODO: JSDoc
    Name;
    // TODO: JSDoc
    Fields;
    // TODO: JSDoc
    __API;
    // TODO: JSDoc
    __DataBase;
    // TODO: JSDoc
    get Condition() {
        const Validator = GlobalModule.Classes.Validator;
        const Condition = {
            Single: {
                Like: (_, __) => {
                    Validator.Strict(_, new Validator().Default.String().Required().MinLength(1));
                    Validator.Strict(__, new Validator().Default.String().Required().MinLength(1));
                    const FieldName = _;
                    const ExpectedFieldValue = __;
                    const FormattedExpectedFieldValue = FormatValueToStringQuery(ExpectedFieldValue);
                    const QueryString = `${FieldName} ${ConditionOperand.Like} ${FormattedExpectedFieldValue}`;
                    return QueryString;
                },
                MoreThan: (_, __) => {
                    Validator.Strict(_, new Validator().Default.String().Required().MinLength(1));
                    const FieldName = _;
                    const ExpectedFieldValue = __;
                    const FormattedExpectedFieldValue = FormatValueToStringQuery(ExpectedFieldValue);
                    const QueryString = `${FieldName} ${ConditionOperand.Default.Single.MoreThan} ${FormattedExpectedFieldValue}`;
                    return QueryString;
                },
                NotMoreThan: (_, __) => {
                    Validator.Strict(_, new Validator().Default.String().Required().MinLength(1));
                    const MoreThanQueryString = this.Condition.Single.MoreThan(_, __);
                    const QueryString = `${ConditionOperand.Inverse} ${MoreThanQueryString}`;
                    return QueryString;
                },
                MoreThanOrEqual: (_, __) => {
                    Validator.Strict(_, new Validator().Default.String().Required().MinLength(1));
                    const FieldName = _;
                    const ExpectedFieldValue = __;
                    const FormattedExpectedFieldValue = FormatValueToStringQuery(ExpectedFieldValue);
                    const QueryString = `${FieldName} ${ConditionOperand.Default.Single.MoreThanOrEqual} ${FormattedExpectedFieldValue}`;
                    return QueryString;
                },
                NotMoreThanOrEqual: (_, __) => {
                    Validator.Strict(_, new Validator().Default.String().Required().MinLength(1));
                    const MoreThanOrEqualQueryString = this.Condition.Single.MoreThanOrEqual(_, __);
                    const QueryString = `${ConditionOperand.Inverse} ${MoreThanOrEqualQueryString}`;
                    return QueryString;
                },
                EqualTo: (_, __) => {
                    Validator.Strict(_, new Validator().Default.String().Required().MinLength(1));
                    const FieldName = _;
                    const ExpectedFieldValue = __;
                    const FormattedExpectedFieldValue = FormatValueToStringQuery(ExpectedFieldValue);
                    const QueryString = `${FieldName} ${ConditionOperand.Default.Single.EqualTo} ${FormattedExpectedFieldValue}`;
                    return QueryString;
                },
                NotEqualTo: (_, __) => {
                    Validator.Strict(_, new Validator().Default.String().Required().MinLength(1));
                    const EqualToQueryString = this.Condition.Single.EqualTo(_, __);
                    const QueryString = `${ConditionOperand.Inverse} ${EqualToQueryString}`;
                    return QueryString;
                },
                LessThan: (_, __) => {
                    Validator.Strict(_, new Validator().Default.String().Required().MinLength(1));
                    const FieldName = _;
                    const ExpectedFieldValue = __;
                    const FormattedExpectedFieldValue = FormatValueToStringQuery(ExpectedFieldValue);
                    const QueryString = `${FieldName} ${ConditionOperand.Default.Single.LessThan} ${FormattedExpectedFieldValue}`;
                    return QueryString;
                },
                NotLessThan: (_, __) => {
                    Validator.Strict(_, new Validator().Default.String().Required().MinLength(1));
                    const LessThanQueryString = this.Condition.Single.LessThan(_, __);
                    const QueryString = `${ConditionOperand.Inverse} ${LessThanQueryString}`;
                    return QueryString;
                },
                LessThanOrEqual: (_, __) => {
                    Validator.Strict(_, new Validator().Default.String().Required().MinLength(1));
                    const FieldName = _;
                    const ExpectedFieldValue = __;
                    const FormattedExpectedFieldValue = FormatValueToStringQuery(ExpectedFieldValue);
                    const QueryString = `${FieldName} ${ConditionOperand.Default.Single.LessThanOrEqual} ${FormattedExpectedFieldValue}`;
                    return QueryString;
                },
                NotLessThanOrEqual: (_, __) => {
                    Validator.Strict(_, new Validator().Default.String().Required().MinLength(1));
                    const LessThanOrEqualQueryString = this.Condition.Single.LessThanOrEqual(_, __);
                    const QueryString = `${ConditionOperand.Inverse} ${LessThanOrEqualQueryString}`;
                    return QueryString;
                },
            },
            Multiple: {
                Every: (..._) => {
                    Validator.Strict(_, new Validator().Default.Array().Required().Of(new Validator().Default.String().Required().MinLength(1)));
                    const Conditions = _;
                    const QueryString = Conditions.join(` ${ConditionOperand.Default.Multiple.Conjunction} `);
                    return QueryString;
                },
                Some: (..._) => {
                    Validator.Strict(_, new Validator().Default.Array().Required().Of(new Validator().Default.String().Required().MinLength(1)));
                    const Conditions = _;
                    const QueryString = Conditions.join(` ${ConditionOperand.Default.Multiple.Disjunction} `);
                    return QueryString;
                },
            },
        };
        return Condition;
    }
    // TODO: JSDoc
    get ValueSetter() {
        const Validator = GlobalModule.Classes.Validator;
        const ValueSetter = {
            Single: (_, __) => {
                Validator.Strict(_, new Validator().Default.String().Required().MinLength(1));
                const FieldName = _;
                const ExpectedFieldValue = __;
                const FormattedExpectedFieldValue = FormatValueToStringQuery(ExpectedFieldValue);
                const QueryString = `${FieldName} ${ConditionOperand.Default.Single.EqualTo} ${FormattedExpectedFieldValue}`;
                return QueryString;
            },
            Multiple: (..._) => {
                Validator.Strict(_, new Validator().Default.Array().Required().Of(new Validator().Default.String().Required().MinLength(1)));
                const Conditions = _;
                const QueryString = Conditions.join(`, `);
                return QueryString;
            },
        };
        return ValueSetter;
    }
    // TODO: JSDoc
    async Insert(...elements) {
        const InsertedElements = await this.__Insert(...elements);
        return InsertedElements;
    }
    // TODO: JSDoc
    async Update(valueSetter, condition) {
        const UpdatedElements = await this.__Update(valueSetter, condition);
        return UpdatedElements;
    }
    async Select(fields, condition, unique, limit) {
        const SelectedElements = await this.__Select(fields, condition, unique, limit);
        return SelectedElements;
    }
    // TODO: JSDoc
    async Delete(condition) {
        const DeletedElements = await this.__Delete(condition);
        return DeletedElements;
    }
    // TODO: JSDoc
    async DoesExist() {
        const DoesExist = this.__DoesExist();
        return DoesExist;
    }
    // TODO: JSDoc
    async CreateIfNotExist() {
        await this.__CreateIfNotExist();
    }
    // TODO: JSDoc
    constructor(api, database, name, fields) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(api, new Validator().Default.Class.Instance().Required().Of(PostgreSQLAPI.default));
        Validator.Strict(database, new Validator().Default.Class.Instance().Required().Of(PostgreSQLAPI.DataBases.BaseDataBase));
        Validator.Strict(name, new Validator().Default.String().Required().MinLength(1));
        const DataTypesList = GlobalModule.Functions.Parameter.Type.Manager.Default.Object.GetFullProperties(DataType, (_, __) => false).map((_el, _ind, _arr) => _el.Value);
        Validator.Strict(fields, new Validator().Default.Object()
            .Required()
            .Of(new Validator().Default.Object()
            .Required()
            .Exact({
            Type: new Validator().Default.String().Required().In(DataTypesList),
            MetaData: new Validator().Default.Object()
                .Required()
                .Exact({
                DefaultValue: new Validator().Default.Any(),
                IsPrimary: new Validator().Default.Boolean().Required(),
                IsRequired: new Validator().Default.Boolean().Required(),
                IsUnique: new Validator().Default.Boolean().Required(),
                MustBeAutoIncremented: new Validator().Default.Boolean().Required(),
                Reference: new Validator().Default.Object().Exact({
                    Table: new Validator().Default.Object().Required().Exact({
                        Name: new Validator().Default.String().Required(),
                    }),
                    Field: new Validator().Default.String().Required(),
                }),
            }),
        })));
        this.__API = api;
        this.__DataBase = database;
        this.Name = name;
        this.Fields = fields;
    }
    // TODO: JSDoc
    async __Insert(...elements) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(elements, new Validator().Default.Array().Required().MinLength(1));
        const InputElementGroups = elements.map((_el, _ind, _arr) => {
            const InputElementGroupNames = GlobalModule.Functions.Parameter.Type.Manager.Default.Object.GetProperties(_el);
            const InputElementGroup = InputElementGroupNames.map((__el, __ind, __arr) => {
                const ElementColumn = __el;
                const ElementValue = _el[__el];
                const FormattedElementValue = FormatValueToStringQuery(ElementValue);
                const Element = {
                    Column: ElementColumn,
                    Value: FormattedElementValue,
                };
                return Element;
            });
            return InputElementGroup;
        });
        const InputElementColumns = InputElementGroups[0].map((_el, _ind, _arr) => _el.Column);
        const InputElementValueGroups = InputElementGroups.map((_el, _ind, _arr) => _el.map((__el, __ind, __arr) => __el.Value));
        const QueryStringPrefix = `INSERT INTO ${this.Name}`;
        const QueryStringPostfix = `RETURNING *`;
        const InputElementColumnsQueryString = InputElementColumns.join(`, `);
        const InputElementValueGroupsQueryString = InputElementValueGroups.map((_el, _ind, _arr) => `(${_el.join(`, `)})`).join(`, `);
        const QueryString = `${QueryStringPrefix} (${InputElementColumnsQueryString}) values ${InputElementValueGroupsQueryString} ${QueryStringPostfix}`;
        const QueryResponse = await this.__DataBase.Request(QueryString);
        const QueryResult = QueryResponse.rows.map((_el, _ind, _arr) => {
            const TableFieldNames = GlobalModule.Functions.Parameter.Type.Manager.Default.Object.GetProperties(this.Fields);
            for (let i = 0; i < TableFieldNames.length; i++) {
                const TableFieldName = TableFieldNames[i];
                const TableField = this.Fields[TableFieldName];
                const QueryResultItemValue = _el[TableFieldName];
                const FormattedQueryResultItemValue = FormatValueFromStringQuery(QueryResultItemValue, TableField.Type);
                _el[TableFieldName] = FormattedQueryResultItemValue;
            }
            return _el;
        });
        const InsertedElements = QueryResult;
        this.__API.Event.Emitter.Emit(PostgreSQLAPI.default.Event.Name.DataBase.Table.Elements.Insert, this.__DataBase.Name, this.Name, InsertedElements);
        const InsertedElementsToString = GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.ToNamed(InsertedElements.length, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default, [`внесено`, `записей`], [`внесена`, `запись`], [`внесены`, `записи`]);
        this.__API.Log.Preset.Info(`В таблицу '${this.Name}' базы данных '${this.__DataBase.Name}' ${InsertedElementsToString}`);
        return InsertedElements;
    }
    // TODO: JSDoc
    async __Update(valueSetter, condition) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(valueSetter, new Validator().Default.String().Required().MinLength(1));
        Validator.Strict(condition, new Validator().Default.String().MinLength(1));
        const DoesConditionExist = !Validator.TypeGuard.Default.IsNullOrUndefined(condition);
        const QueryStringPrefix = `UPDATE ${this.Name}`;
        const QueryStringPostfix = `RETURNING *`;
        const QueryStringParts = [];
        QueryStringParts.push(QueryStringPrefix);
        QueryStringParts.push(`SET ${valueSetter}`);
        if (DoesConditionExist)
            QueryStringParts.push(`WHERE ${condition}`);
        QueryStringParts.push(QueryStringPostfix);
        const QueryString = QueryStringParts.join(GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default);
        const QueryResponse = await this.__DataBase.Request(QueryString);
        const QueryResult = QueryResponse.rows.map((_el, _ind, _arr) => {
            const TableFieldNames = GlobalModule.Functions.Parameter.Type.Manager.Default.Object.GetProperties(this.Fields);
            for (let i = 0; i < TableFieldNames.length; i++) {
                const TableFieldName = TableFieldNames[i];
                const TableField = this.Fields[TableFieldName];
                const QueryResultItemValue = _el[TableFieldName];
                const FormattedQueryResultItemValue = FormatValueFromStringQuery(QueryResultItemValue, TableField.Type);
                _el[TableFieldName] = FormattedQueryResultItemValue;
            }
            return _el;
        });
        const UpdatedElements = QueryResult;
        this.__API.Event.Emitter.Emit(PostgreSQLAPI.default.Event.Name.DataBase.Table.Elements.Update, this.__DataBase.Name, this.Name, UpdatedElements);
        const UpdatedElementsToString = GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.ToNamed(UpdatedElements.length, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default, [`обновлено`, `записей`], [`обновлена`, `запись`], [`обновлены`, `записи`]);
        this.__API.Log.Preset.Info(`В таблице '${this.Name}' базы данных '${this.__DataBase.Name}' ${UpdatedElementsToString}`);
        return UpdatedElements;
    }
    // TODO: JSDoc
    async __Select(fields, condition, unique, limit) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(fields, new Validator().Default.Array().Of(new Validator().Default.String().Required().MinLength(1)));
        Validator.Strict(condition, new Validator().Default.String().MinLength(1));
        Validator.Strict(unique, new Validator().Default.Boolean());
        Validator.Strict(limit, new Validator().Default.Numeric().Number().Integer().Min(1));
        const DoesSelectedFieldExist = !Validator.TypeGuard.Default.IsNullOrUndefined(fields);
        const DoesConditionExist = !Validator.TypeGuard.Default.IsNullOrUndefined(condition);
        const DoesLimitExist = !Validator.TypeGuard.Default.IsNullOrUndefined(limit);
        const SelectedFieldQueryString = DoesSelectedFieldExist ? `${fields.join(`, `)}` : `*`;
        const QueryStringPrefix = `SELECT ${SelectedFieldQueryString} FROM ${this.Name}`;
        const UniqueFieldsQueryString = `DISTINCT`;
        const LimitQueryString = `LIMIT ${limit}`;
        const QueryStringParts = [];
        QueryStringParts.push(QueryStringPrefix);
        if (DoesConditionExist)
            QueryStringParts.push(`WHERE ${condition}`);
        if (unique)
            QueryStringParts.push(UniqueFieldsQueryString);
        if (DoesLimitExist)
            QueryStringParts.push(LimitQueryString);
        const QueryString = QueryStringParts.join(GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default);
        const QueryResponse = await this.__DataBase.Request(QueryString);
        const QueryResult = QueryResponse.rows.map((_el, _ind, _arr) => {
            const TableFieldNames = GlobalModule.Functions.Parameter.Type.Manager.Default.Object.GetProperties(this.Fields);
            for (let i = 0; i < TableFieldNames.length; i++) {
                const TableFieldName = TableFieldNames[i];
                const TableField = this.Fields[TableFieldName];
                const QueryResultItemValue = _el[TableFieldName];
                const FormattedQueryResultItemValue = FormatValueFromStringQuery(QueryResultItemValue, TableField.Type);
                _el[TableFieldName] = FormattedQueryResultItemValue;
            }
            return _el;
        });
        const SelectedElements = QueryResult;
        this.__API.Event.Emitter.Emit(PostgreSQLAPI.default.Event.Name.DataBase.Table.Elements.Select, this.__DataBase.Name, this.Name, SelectedElements);
        const SelectedElementsToString = GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.ToNamed(SelectedElements.length, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default, [`просмотрено`, `записей`], [`просмотрена`, `запись`], [`просмотрены`, `записи`]);
        this.__API.Log.Preset.Info(`В таблице '${this.Name}' базы данных '${this.__DataBase.Name}' ${SelectedElementsToString}`);
        return SelectedElements;
    }
    // TODO: JSDoc
    async __Delete(condition) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(condition, new Validator().Default.String().MinLength(1));
        const DoesConditionExist = !Validator.TypeGuard.Default.IsNullOrUndefined(condition);
        const QueryStringPrefix = `DELETE FROM ${this.Name}`;
        const QueryStringPostfix = `RETURNING *`;
        const QueryStringParts = [];
        QueryStringParts.push(QueryStringPrefix);
        if (DoesConditionExist)
            QueryStringParts.push(`WHERE ${condition}`);
        QueryStringParts.push(QueryStringPostfix);
        const QueryString = QueryStringParts.join(GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default);
        const QueryResponse = await this.__DataBase.Request(QueryString);
        const QueryResult = QueryResponse.rows.map((_el, _ind, _arr) => {
            const TableFieldNames = GlobalModule.Functions.Parameter.Type.Manager.Default.Object.GetProperties(this.Fields);
            for (let i = 0; i < TableFieldNames.length; i++) {
                const TableFieldName = TableFieldNames[i];
                const TableField = this.Fields[TableFieldName];
                const QueryResultItemValue = _el[TableFieldName];
                const FormattedQueryResultItemValue = FormatValueFromStringQuery(QueryResultItemValue, TableField.Type);
                _el[TableFieldName] = FormattedQueryResultItemValue;
            }
            return _el;
        });
        const DeletedElements = QueryResult;
        this.__API.Event.Emitter.Emit(PostgreSQLAPI.default.Event.Name.DataBase.Table.Elements.Delete, this.__DataBase.Name, this.Name, DeletedElements);
        const DeletedElementsToString = GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.ToNamed(DeletedElements.length, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default, [`удалено`, `записей`], [`удалена`, `запись`], [`удалены`, `записи`]);
        this.__API.Log.Preset.Info(`Из таблицы '${this.Name}' базы данных '${this.__DataBase.Name}' ${DeletedElementsToString}`);
        return DeletedElements;
    }
    // TODO: JSDoc
    async __DoesExist() {
        const Validator = GlobalModule.Classes.Validator;
        const QueryString = `SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_schema = 'public' AND table_name = '${this.Name}');`;
        const QueryResponse = await this.__DataBase.Request(QueryString);
        const QueryResults = QueryResponse.rows;
        const [QueryResult] = QueryResults;
        const DoesQueryResultExist = !Validator.TypeGuard.Default.IsNullOrUndefined(QueryResult);
        const TableExistanceFilters = [];
        if (DoesQueryResultExist) {
            const TableExistanceResult = QueryResult.exists;
            const DoesTableExistanceResultExist = !Validator.TypeGuard.Default.IsNullOrUndefined(TableExistanceResult);
            if (DoesTableExistanceResultExist) {
                TableExistanceFilters.push(TableExistanceResult);
            }
        }
        const DoesTableExistanceFilterExist = !Validator.TypeGuard.Default.IsEmptyArray(TableExistanceFilters);
        const DoesTableExist = DoesTableExistanceFilterExist ? TableExistanceFilters.every((_el, _ind, _arr) => _el) : false;
        this.__API.Event.Emitter.Emit(PostgreSQLAPI.default.Event.Name.DataBase.Table.Validate.Existance, this.__DataBase.Name, this.Name);
        this.__API.Log.Preset.Info(`Проверка наличия таблицы '${this.Name}' в базе данных '${this.__DataBase.Name}'`);
        return DoesTableExist;
    }
    // TODO: JSDoc
    async __CreateIfNotExist() {
        const Validator = GlobalModule.Classes.Validator;
        const QueryStringPrefix = `CREATE TABLE IF NOT EXISTS ${this.Name}`;
        const QueryStringParts = [];
        QueryStringParts.push(QueryStringPrefix);
        const FieldsToCreateNames = GlobalModule.Functions.Parameter.Type.Manager.Default.Object.GetProperties(this.Fields);
        const FieldsToCreateQueryStringParts = [];
        for (let i = 0; i < FieldsToCreateNames.length; i++) {
            const FieldToCreateName = FieldsToCreateNames[i];
            const FieldToCreateValue = this.Fields[FieldToCreateName];
            const FieldToCreateQueryStringParts = [];
            FieldToCreateQueryStringParts.push(FieldToCreateName);
            if (FieldToCreateValue.MetaData.MustBeAutoIncremented) {
                FieldToCreateQueryStringParts.push(DataType.Numeric.Serial);
            }
            else {
                FieldToCreateQueryStringParts.push(FieldToCreateValue.Type);
            }
            if (FieldToCreateValue.MetaData.IsRequired)
                FieldToCreateQueryStringParts.push(`NOT NULL`);
            if (FieldToCreateValue.MetaData.IsUnique)
                FieldToCreateQueryStringParts.push(`UNIQUE`);
            if (FieldToCreateValue.MetaData.IsPrimary)
                FieldToCreateQueryStringParts.push(`PRIMARY KEY`);
            const DoesDefaultValueExist = !Validator.TypeGuard.Default.IsNullOrUndefined(FieldToCreateValue.MetaData.DefaultValue);
            if (DoesDefaultValueExist) {
                const FormattedDefaultValue = FormatValueToStringQuery(FieldToCreateValue.MetaData.DefaultValue);
                if (FieldToCreateValue.MetaData.DefaultValue)
                    FieldToCreateQueryStringParts.push(`DEFAULT ${FormattedDefaultValue}`);
            }
            const FieldToCreateQueryString = FieldToCreateQueryStringParts.join(GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default);
            FieldsToCreateQueryStringParts.push(FieldToCreateQueryString);
            const FieldToCreateReference = FieldToCreateValue.MetaData.Reference;
            const DoesFieldToCreateReferenceExist = !Validator.TypeGuard.Default.IsNullOrUndefined(FieldToCreateReference);
            if (DoesFieldToCreateReferenceExist) {
                FieldsToCreateQueryStringParts.push(`CONSTRAINT FK_${this.Name}_${FieldToCreateName} FOREIGN KEY(${FieldToCreateName}) REFERENCES ${FieldToCreateReference.Table.Name}(${FieldToCreateReference.Field})`);
            }
        }
        const FieldToCreateQueryString = FieldsToCreateQueryStringParts.join(`, `);
        QueryStringParts.push(`(${FieldToCreateQueryString})`);
        const QueryString = QueryStringParts.join(GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default);
        const DoesThisTableExist = await this.__DoesExist();
        if (!DoesThisTableExist) {
            /*const QueryResponse = */ await this.__DataBase.Request(QueryString);
            this.__API.Event.Emitter.Emit(PostgreSQLAPI.default.Event.Name.DataBase.Table.Create, this.__DataBase.Name, this.Name, FieldsToCreateNames);
            const FieldsToCreateNamesToString = FieldsToCreateNames.map((_el, _ind, _arr) => `'${_el}'`).join(` | `);
            const FieldsToCreateNamesLengthToString = GlobalModule.Functions.Parameter.Type.Manager.Default.Numeric.ToNamed(FieldsToCreateNamesToString.length, GlobalModule.DataSet.Dictionary.Symbol.Single.Service.Separator.Space.Default, [undefined, `столбцов`], [undefined, `столбец`], [undefined, `столбца`]);
            this.__API.Log.Preset.Info(`В базу данных '${this.__DataBase.Name}' внесена новая таблица '${this.Name}', содержащая ${FieldsToCreateNamesLengthToString} [${FieldsToCreateNamesToString}]`);
        }
    }
}
//# sourceMappingURL=BaseTable.js.map