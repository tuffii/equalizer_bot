import * as GlobalModule from '../../../module/@module.js';
import { default as BaseAPI } from '../../BaseAPI.js';
import * as Channel from './channel/__channel.js';
import * as Video from './video/__video.js';
import * as Playlist from './playlist/__playlist.js';
import * as Dependencies from './__dependencies.js';
class YouTubeService extends BaseAPI {
    // TODO: JSDoc
    static Pattern = {
        URL: {
            Video: {
                RegExp: /^(?:(https?):\/\/)?(?:(?:(?:www)|(?:m))\.)?(?:(?:(youtube(?:-nocookie)?\.com)(?:(?:\/watch(?:(?:\?v=)|(?:\/)))|(?:\/v\/)))|(?:(youtu\.be)(?:(?:\/watch(?:(?:\?v=)|(?:\/)))|(?:\/))))(?:([\w\-]+)([^\s\/\\]+)?)$/,
                Group: { Protocol: 1, Domain: { Default: 2, Short: 3 }, VideoID: 4, Query: 5 },
            },
            Playlist: {
                RegExp: /^(?:(https?):\/\/)?(?:(?:(?:www)|(?:m))\.)?(?:(?:(youtube(?:-nocookie)?\.com)(?:\/playlist(?:\?list=))))(?:([\w\-]+)([^\s\/\\]+)?)$/,
                Group: { Protocol: 1, Domain: 2, PlaylistID: 3, Query: 4 },
            },
            Author: {
                Channel: {
                    RegExp: /^(?:(https?):\/\/)?(?:(?:(?:www)|(?:m))\.)?(?:(?:(youtube(?:-nocookie)?\.com)(?:\/channel(?:\/))))(?:([\w\-]+)([^\s\/\\]+)?)$/,
                    Group: { Protocol: 1, Domain: 2, ChannelID: 3, Query: 4 },
                },
                User: {
                    RegExp: /^(?:(https?):\/\/)?(?:(?:(?:www)|(?:m))\.)?(?:(?:(youtube(?:-nocookie)?\.com)(?:\/)))(?:(\@?[\w\-]+)([^\s\/\\]+)?)$/,
                    Group: { Protocol: 1, Domain: 2, UserName: 3, Query: 4 },
                },
            },
        },
    };
    // TODO: JSDoc
    static TypeGuard = {
        Channel: (parameter) => {
            const Validator = GlobalModule.Classes.Validator;
            let InstanceMatch = false;
            if (!Validator.TypeGuard.Default.IsUnknown(parameter)) {
                if (Validator.TypeGuard.Default.IsInstanceOf(parameter, Channel.default))
                    InstanceMatch = true;
            }
            return InstanceMatch;
        },
        Video: (parameter) => {
            const Validator = GlobalModule.Classes.Validator;
            let InstanceMatch = false;
            if (!Validator.TypeGuard.Default.IsUnknown(parameter)) {
                if (Validator.TypeGuard.Default.IsInstanceOf(parameter, Video.default))
                    InstanceMatch = true;
            }
            return InstanceMatch;
        },
        Playlist: (parameter) => {
            const Validator = GlobalModule.Classes.Validator;
            let InstanceMatch = false;
            if (!Validator.TypeGuard.Default.IsUnknown(parameter)) {
                if (Validator.TypeGuard.Default.IsInstanceOf(parameter, Playlist.default))
                    InstanceMatch = true;
            }
            return InstanceMatch;
        },
    };
    // TODO: JSDoc
    static Validator = {
        Channel: () => new GlobalModule.Classes.Validator().Default.Class.Instance().Of(Channel.default),
        Video: () => new GlobalModule.Classes.Validator().Default.Class.Instance().Of(Video.default),
        Playlist: () => new GlobalModule.Classes.Validator().Default.Class.Instance().Of(Playlist.default),
    };
    // TODO: JSDoc
    static IsVideoURL(url) {
        const IsVideoURL = this.__IsVideoURL(url);
        return IsVideoURL;
    }
    // TODO: JSDoc
    static FormVideoURL(id) {
        const VideoURL = this.__FormVideoURL(id);
        return VideoURL;
    }
    // TODO: JSDoc
    static IsVideoID(id) {
        const IsVideoID = this.__IsVideoID(id);
        return IsVideoID;
    }
    // TODO: JSDoc
    static GetVideoID(url) {
        const VideoID = this.__GetVideoID(url);
        return VideoID;
    }
    // TODO: JSDoc
    static IsPlaylistURL(url) {
        const IsPlaylistURL = this.__IsPlaylistURL(url);
        return IsPlaylistURL;
    }
    // TODO: JSDoc
    static FormPlaylistURL(id) {
        const PlaylistURL = this.__FormPlaylistURL(id);
        return PlaylistURL;
    }
    // TODO: JSDoc
    static IsPlaylistID(id) {
        const IsPlaylistID = this.__IsPlaylistID(id);
        return IsPlaylistID;
    }
    // TODO: JSDoc
    static GetPlaylistID(url) {
        const PlaylistID = this.__GetPlaylistID(url);
        return PlaylistID;
    }
    // TODO: JSDoc
    static IsAnyResourceURL(url) {
        const IsAnyResourceURL = this.__IsAnyResourceURL(url);
        return IsAnyResourceURL;
    }
    // TODO: JSDoc
    static IsChannelURL(url) {
        const IsChannelURL = this.__IsChannelURL(url);
        return IsChannelURL;
    }
    // TODO: JSDoc
    static FormChannelURL(id) {
        const ChannelURL = this.__FormChannelURL(id);
        return ChannelURL;
    }
    // TODO: JSDoc
    static IsChannelID(id) {
        const IsChannelID = this.__IsChannelID(id);
        return IsChannelID;
    }
    // TODO: JSDoc
    static GetChannelID(url) {
        const ChannelID = this.__GetChannelID(url);
        return ChannelID;
    }
    // TODO: JSDoc
    static IsUserURL(url) {
        const IsUserURL = this.__IsUserURL(url);
        return IsUserURL;
    }
    // TODO: JSDoc
    static FormUserURL(name) {
        const UserURL = this.__FormUserURL(name);
        return UserURL;
    }
    // TODO: JSDoc
    static IsUserName(name) {
        const IsUserName = this.__IsUserName(name);
        return IsUserName;
    }
    // TODO: JSDoc
    static GetUserName(url) {
        const UserName = this.__GetUserName(url);
        return UserName;
    }
    // TODO: JSDoc
    static async SearchVideosByIDOrURL(videoIdOrURL) {
        const MatchedVideos = await this.__SearchVideosByIDOrURL(videoIdOrURL);
        return MatchedVideos;
    }
    // TODO: JSDoc
    static async SearchVideosByTitle(searchQuery, searchLimit) {
        const MatchedVideos = await this.__SearchVideosByTitle(searchQuery, searchLimit);
        return MatchedVideos;
    }
    // TODO: JSDoc
    static async SearchPlaylistsByIDOrURL(playlistIdOrURL) {
        const MatchedPlaylists = await this.__SearchPlaylistsByIDOrURL(playlistIdOrURL);
        return MatchedPlaylists;
    }
    // TODO: JSDoc
    static async SearchPlaylistsByTitle(searchQuery, searchLimit) {
        const MatchedPlaylists = await this.__SearchPlaylistsByTitle(searchQuery, searchLimit);
        return MatchedPlaylists;
    }
    // TODO: JSDoc
    static __IsVideoURL(url) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(url, new Validator().Default.String().Required());
        const IsVideoURL = YouTubeService.Pattern.URL.Video.RegExp.test(url);
        return IsVideoURL;
    }
    // TODO: JSDoc
    static __FormVideoURL(id) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(id, new Validator().Default.String().Required().MinLength(1));
        const VideoURLPrefix = `https://youtube.com/watch?v=`;
        const VideoURL = `${VideoURLPrefix}${id}`;
        return VideoURL;
    }
    // TODO: JSDoc
    static __IsVideoID(id) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(id, new Validator().Default.String().Required());
        const IsValidVideoURL = YouTubeService.__IsVideoURL(YouTubeService.__FormVideoURL(id));
        const IsValidVideoID = Dependencies.YTDLCore.validateID(id);
        const IsVideoID = IsValidVideoURL && IsValidVideoID;
        return IsVideoID;
    }
    // TODO: JSDoc
    static __GetVideoID(url) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(url, new Validator().Default.String()
            .Required()
            .Custom((_) => YouTubeService.__IsVideoURL(_), (_) => [`Ожидалось указание действительной ссылки на видеоресурс YouTube`]));
        const VideoURLMatchArray = YouTubeService.Pattern.URL.Video.RegExp.exec(url);
        const VideoID = VideoURLMatchArray[YouTubeService.Pattern.URL.Video.Group.VideoID];
        return VideoID;
    }
    // TODO: JSDoc
    static __IsPlaylistURL(url) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(url, new Validator().Default.String().Required());
        const IsPlaylistURL = YouTubeService.Pattern.URL.Playlist.RegExp.test(url);
        return IsPlaylistURL;
    }
    // TODO: JSDoc
    static __FormPlaylistURL(id) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(id, new Validator().Default.String().Required().MinLength(1));
        const PlaylistURLPrefix = `https://youtube.com/playlist?list=`;
        const PlaylistURL = `${PlaylistURLPrefix}${id}`;
        return PlaylistURL;
    }
    // TODO: JSDoc
    static __IsPlaylistID(id) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(id, new Validator().Default.String().Required());
        const IsValidPlaylistURL = YouTubeService.__IsPlaylistURL(YouTubeService.__FormPlaylistURL(id));
        const IsValidPlaylistID = Dependencies.YTPLCore.validateID(id);
        const IsPlaylistID = IsValidPlaylistURL && IsValidPlaylistID;
        return IsPlaylistID;
    }
    // TODO: JSDoc
    static __GetPlaylistID(url) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(url, new Validator().Default.String()
            .Required()
            .Custom((_) => YouTubeService.__IsPlaylistURL(_), (_) => [`Ожидалось указание действительной ссылки на плейлист YouTube`]));
        const PlaylistURLMatchArray = YouTubeService.Pattern.URL.Playlist.RegExp.exec(url);
        const PlaylistID = PlaylistURLMatchArray[YouTubeService.Pattern.URL.Playlist.Group.PlaylistID];
        return PlaylistID;
    }
    // TODO: JSDoc
    static __IsAnyResourceURL(url) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(url, new Validator().Default.String().Required());
        const IsVideoURL = YouTubeService.__IsVideoURL(url);
        const IsPlaylistURL = YouTubeService.__IsPlaylistURL(url);
        const IsAnyURL = IsVideoURL || IsPlaylistURL;
        return IsAnyURL;
    }
    // TODO: JSDoc
    static __IsChannelURL(url) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(url, new Validator().Default.String().Required());
        const IsChannelURL = YouTubeService.Pattern.URL.Author.Channel.RegExp.test(url);
        return IsChannelURL;
    }
    // TODO: JSDoc
    static __FormChannelURL(id) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(id, new Validator().Default.String().Required().MinLength(1));
        const ChannelURLPrefix = `https://www.youtube.com/channel/`;
        const ChannelURL = `${ChannelURLPrefix}${id}`;
        return ChannelURL;
    }
    // TODO: JSDoc
    static __IsChannelID(id) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(id, new Validator().Default.String().Required());
        const IsValidChannelURL = YouTubeService.__IsChannelURL(YouTubeService.__FormChannelURL(id));
        const IsChannelID = IsValidChannelURL;
        return IsChannelID;
    }
    // TODO: JSDoc
    static __GetChannelID(url) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(url, new Validator().Default.String()
            .Required()
            .Custom((_) => YouTubeService.__IsChannelURL(_), (_) => [`Ожидалось указание действительной ссылки на канал YouTube`]));
        const ChannelURLMatchArray = YouTubeService.Pattern.URL.Author.Channel.RegExp.exec(url);
        const ChannelID = ChannelURLMatchArray[YouTubeService.Pattern.URL.Author.Channel.Group.ChannelID];
        return ChannelID;
    }
    // TODO: JSDoc
    static __IsUserURL(url) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(url, new Validator().Default.String().Required());
        const IsUserURL = YouTubeService.Pattern.URL.Author.User.RegExp.test(url);
        return IsUserURL;
    }
    // TODO: JSDoc
    static __FormUserURL(name) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(name, new Validator().Default.String().Required().MinLength(1));
        const UserURLPrefix = `https://www.youtube.com/`;
        const UserURL = `${UserURLPrefix}${name}`;
        return UserURL;
    }
    // TODO: JSDoc
    static __IsUserName(name) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(name, new Validator().Default.String().Required());
        const IsValidUserURL = YouTubeService.__IsUserURL(YouTubeService.__FormUserURL(name));
        const IsUserName = IsValidUserURL;
        return IsUserName;
    }
    // TODO: JSDoc
    static __GetUserName(url) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(url, new Validator().Default.String()
            .Required()
            .Custom((_) => YouTubeService.__IsUserURL(_), (_) => [`Ожидалось указание действительной ссылки на пользователя YouTube`]));
        const UserURLMatchArray = YouTubeService.Pattern.URL.Author.User.RegExp.exec(url);
        const UserName = UserURLMatchArray[YouTubeService.Pattern.URL.Author.User.Group.UserName];
        return UserName;
    }
    // TODO: JSDoc
    static async __GetChannelsResourcesByName(searchLimit, channelName, channelId) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(searchLimit, new Validator().Default.Numeric().Number().Required().Integer().Min(1));
        Validator.Strict(channelName, new Validator().Default.String().Required().MinLength(1));
        Validator.Strict(channelId, new Validator().Default.String().Custom((_) => YouTubeService.__IsChannelID(_), (_) => [`Ожидалось указание ID канала YouTube`]));
        const ChannelsPerPage = 100;
        const ChannelsLimit = searchLimit;
        const PagesLimit = Math.floor(searchLimit / ChannelsPerPage) + 1;
        const ChannelSearchQuery = channelName;
        const ChannelSearchID = channelId;
        const MatchedChannels = [];
        try {
            const YTSRFilters = await Dependencies.YTSR.getFilters(ChannelSearchQuery);
            const YTSRTypeFilters = YTSRFilters.get(`Type`);
            const DoesYTSRTypeFilterExist = !Validator.TypeGuard.Default.IsNullOrUndefined(YTSRTypeFilters);
            if (DoesYTSRTypeFilterExist) {
                const YTSRChannelTypeFilters = YTSRTypeFilters.get(`Channel`);
                const DoesYTSRChannelTypeFilterExist = !Validator.TypeGuard.Default.IsNullOrUndefined(YTSRChannelTypeFilters);
                if (DoesYTSRChannelTypeFilterExist) {
                    const YTSRChannelSearchFiltersURL = YTSRChannelTypeFilters.url;
                    const DoesYTSRChannelSearchFiltersURLExist = !Validator.TypeGuard.Default.IsNullOrUndefined(YTSRChannelSearchFiltersURL);
                    if (DoesYTSRChannelSearchFiltersURLExist) {
                        const YTSRChannelSearchResult = await Dependencies.YTSR(YTSRChannelSearchFiltersURL, {
                            limit: ChannelsLimit,
                            pages: PagesLimit,
                            safeSearch: false,
                        });
                        const DoesChannelIDFilterExist = !Validator.TypeGuard.Default.IsNullOrUndefined(ChannelSearchID);
                        const YTSRMatchedChannels = YTSRChannelSearchResult.items.filter((_el, _ind, _arr) => _el.type === `channel`);
                        const FilteredYTSRMatchedChannels = YTSRMatchedChannels.filter((_el, _ind, _arr) => {
                            const RequiredMatches = [];
                            if (DoesChannelIDFilterExist) {
                                RequiredMatches.push(_el.channelID === ChannelSearchID);
                            }
                            const DoesRequiredMatchExist = !Validator.TypeGuard.Default.IsEmptyArray(RequiredMatches);
                            const ChannelMatch = DoesRequiredMatchExist ? RequiredMatches.every((_el, _ind, _arr) => _el) : true;
                            return ChannelMatch;
                        });
                        MatchedChannels.push(...FilteredYTSRMatchedChannels.map((_el, _ind, _arr) => {
                            const MatchedChannel = [_el];
                            return MatchedChannel;
                        }));
                    }
                }
            }
        }
        catch (e) { }
        return MatchedChannels;
    }
    // TODO: JSDoc
    static async __GetChannelResourceByID(channelId) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(channelId, new Validator().Default.String()
            .Required()
            .Custom((_) => YouTubeService.__IsChannelID(_), (_) => [`Ожидалось указание ID канала YouTube`]));
        const ChannelSearchID = channelId;
        const ChannelSearchURL = YouTubeService.__FormVideoURL(ChannelSearchID);
        const GetYTChannelInfo = async (query) => {
            try {
                const YTChannelInfo = await Dependencies.YTChannelInfo.getChannelInfo({
                    channelId: query,
                });
                return YTChannelInfo;
            }
            catch (e) {
                const YTChannelInfo = undefined;
                return YTChannelInfo;
            }
        };
        const ChannelSearchQueries = await Promise.all([GetYTChannelInfo(ChannelSearchID)]);
        return ChannelSearchQueries;
    }
    // TODO: JSDoc
    static async __GetVideosResourcesByTitle(searchLimit, videoTitle, videoId) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(searchLimit, new Validator().Default.Numeric().Number().Required().Integer().Min(1));
        Validator.Strict(videoTitle, new Validator().Default.String().Required().MinLength(1));
        Validator.Strict(videoId, new Validator().Default.String().Custom((_) => YouTubeService.__IsVideoID(_), (_) => [`Ожидалось указание ID видеоресурса YouTube`]));
        const VideosPerPage = 100;
        const VideosLimit = searchLimit;
        const PagesLimit = Math.floor(searchLimit / VideosPerPage) + 1;
        const VideoSearchQuery = videoTitle;
        const VideoSearchID = videoId;
        const MatchedVideos = [];
        try {
            const YTSRFilters = await Dependencies.YTSR.getFilters(VideoSearchQuery);
            const YTSRTypeFilters = YTSRFilters.get(`Type`);
            const DoesYTSRTypeFilterExist = !Validator.TypeGuard.Default.IsNullOrUndefined(YTSRTypeFilters);
            if (DoesYTSRTypeFilterExist) {
                const YTSRVideoTypeFilters = YTSRTypeFilters.get(`Video`);
                const DoesYTSRVideoTypeFilterExist = !Validator.TypeGuard.Default.IsNullOrUndefined(YTSRVideoTypeFilters);
                if (DoesYTSRVideoTypeFilterExist) {
                    const YTSRVideoSearchFiltersURL = YTSRVideoTypeFilters.url;
                    const DoesYTSRVideoSearchFiltersURLExist = !Validator.TypeGuard.Default.IsNullOrUndefined(YTSRVideoSearchFiltersURL);
                    if (DoesYTSRVideoSearchFiltersURLExist) {
                        const YTSRVideoSearchResult = await Dependencies.YTSR(YTSRVideoSearchFiltersURL, {
                            limit: VideosLimit,
                            pages: PagesLimit,
                            safeSearch: false,
                        });
                        const DoesVideoIDFilterExist = !Validator.TypeGuard.Default.IsNullOrUndefined(VideoSearchID);
                        const YTSRMatchedVideos = YTSRVideoSearchResult.items.filter((_el, _ind, _arr) => _el.type === `video`);
                        const FilteredYTSRMatchedVideos = YTSRMatchedVideos.filter((_el, _ind, _arr) => {
                            const RequiredMatches = [];
                            if (DoesVideoIDFilterExist) {
                                RequiredMatches.push(_el.id === VideoSearchID);
                            }
                            const DoesRequiredMatchExist = !Validator.TypeGuard.Default.IsEmptyArray(RequiredMatches);
                            const VideoMatch = DoesRequiredMatchExist ? RequiredMatches.every((_el, _ind, _arr) => _el) : true;
                            return VideoMatch;
                        });
                        MatchedVideos.push(...FilteredYTSRMatchedVideos.map((_el, _ind, _arr) => {
                            const MatchedVideo = [_el];
                            return MatchedVideo;
                        }));
                    }
                }
            }
        }
        catch (e) { }
        return MatchedVideos;
    }
    // TODO: JSDoc
    static async __GetVideoResourceByID(videoId) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(videoId, new Validator().Default.String()
            .Required()
            .Custom((_) => YouTubeService.__IsVideoID(_), (_) => [`Ожидалось указание ID видеоресурса YouTube`]));
        const VideoSearchID = videoId;
        const VideoSearchURL = YouTubeService.__FormVideoURL(VideoSearchID);
        const GetYTDLCoreBasicVideoInfo = async (query) => {
            try {
                const YTDLCoreBasicVideoInfo = await Dependencies.YTDLCore.getBasicInfo(query);
                return YTDLCoreBasicVideoInfo;
            }
            catch (e) {
                const YTDLCoreBasicVideoInfo = undefined;
                return YTDLCoreBasicVideoInfo;
            }
        };
        const GetYTDLCoreVideoInfo = async (query) => {
            try {
                const YTDLCoreVideoInfo = await Dependencies.YTDLCore.getInfo(query);
                return YTDLCoreVideoInfo;
            }
            catch (e) {
                const YTDLCoreVideoInfo = undefined;
                return YTDLCoreVideoInfo;
            }
        };
        const GetYTSearchVideoInfo = async (query) => {
            try {
                const YTSearchVideoInfo = await Dependencies.YTSearch({
                    videoId: query,
                });
                return YTSearchVideoInfo;
            }
            catch (e) {
                const YTSearchVideoInfo = undefined;
                return YTSearchVideoInfo;
            }
        };
        const VideoSearchQueries = await Promise.all([GetYTDLCoreBasicVideoInfo(VideoSearchURL), GetYTDLCoreVideoInfo(VideoSearchURL), GetYTSearchVideoInfo(VideoSearchID)]);
        return VideoSearchQueries;
    }
    // TODO: JSDoc
    static async __SearchVideosByIDOrURL(videoIdOrURL) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(videoIdOrURL, new Validator().Default.String()
            .Required()
            .Custom((_) => YouTubeService.__IsVideoURL(_) || YouTubeService.__IsVideoID(_), (_) => [`Ожидалось указание ID или ссылки на видеоресурс YouTube`]));
        const IsSearchQueryVideoURL = YouTubeService.__IsVideoURL(videoIdOrURL);
        const IsSearchQueryVideoID = YouTubeService.__IsVideoID(videoIdOrURL);
        let VideoID = `${videoIdOrURL}`;
        if (IsSearchQueryVideoURL) {
            VideoID = YouTubeService.__GetVideoID(videoIdOrURL);
        }
        if (IsSearchQueryVideoID) {
            VideoID = videoIdOrURL;
        }
        const ValidVideoID = VideoID;
        const ValidVideoURL = YouTubeService.__FormVideoURL(ValidVideoID);
        const MatchedVideos = [];
        const VideoSearchByIDQueryResults = await YouTubeService.__GetVideoResourceByID(ValidVideoID);
        const YTDLCoreBasicVideoInfo = VideoSearchByIDQueryResults[0];
        const DoesYTDLCoreBasicVideoInfoExist = !Validator.TypeGuard.Default.IsNullOrUndefined(YTDLCoreBasicVideoInfo);
        const YTDLCoreVideoInfo = VideoSearchByIDQueryResults[1];
        const DoesYTDLCoreVideoInfoExist = !Validator.TypeGuard.Default.IsNullOrUndefined(YTDLCoreVideoInfo);
        const YTSearchVideoInfo = VideoSearchByIDQueryResults[2];
        const DoesYTSearchVideoInfoExist = !Validator.TypeGuard.Default.IsNullOrUndefined(YTSearchVideoInfo);
        const VideoTitle = Validator.GetOneOf([
            DoesYTDLCoreBasicVideoInfoExist ? YTDLCoreBasicVideoInfo.videoDetails.title : undefined,
            DoesYTDLCoreVideoInfoExist ? YTDLCoreVideoInfo.videoDetails.title : undefined,
            DoesYTSearchVideoInfoExist ? YTSearchVideoInfo.title : undefined,
        ], new Validator().Default.String().Required().MinLength(1));
        const DoesVideoTitleExist = !Validator.TypeGuard.Default.IsNullOrUndefined(VideoTitle);
        if (DoesVideoTitleExist) {
            const VideoAuthorName = Validator.GetOneOf([
                DoesYTDLCoreBasicVideoInfoExist ? YTDLCoreBasicVideoInfo.videoDetails.author.name : undefined,
                DoesYTDLCoreVideoInfoExist ? YTDLCoreVideoInfo.videoDetails.author.name : undefined,
                DoesYTSearchVideoInfoExist ? YTSearchVideoInfo.author.name : undefined,
            ], new Validator().Default.String().Required().MinLength(1));
            const DoesVideoAuthorNameExist = !Validator.TypeGuard.Default.IsNullOrUndefined(VideoAuthorName);
            const VideoAuthorID = Validator.GetOneOf([
                DoesYTDLCoreBasicVideoInfoExist ? YTDLCoreBasicVideoInfo.videoDetails.author.id : undefined,
                DoesYTDLCoreVideoInfoExist ? YTDLCoreVideoInfo.videoDetails.author.id : undefined,
            ], new Validator().Default.String().Required().MinLength(1));
            const DoesVideoAuthorIDExist = !Validator.TypeGuard.Default.IsNullOrUndefined(VideoAuthorID);
            if (DoesVideoAuthorNameExist && DoesVideoAuthorIDExist) {
                const [VideoAuthorSearchByIDQueryResult, VideoAuthorSearchByNameIDQueryResult] = await Promise.all([
                    YouTubeService.__GetChannelResourceByID(VideoAuthorID),
                    YouTubeService.__GetChannelsResourcesByName(20, VideoAuthorName, VideoAuthorID),
                ]);
                const YTChannelInfo = VideoAuthorSearchByIDQueryResult[0];
                const DoesYTChannelInfoExist = !Validator.TypeGuard.Default.IsNullOrUndefined(YTChannelInfo);
                const VideoAuthorChannels = VideoAuthorSearchByNameIDQueryResult.map((_el, _ind, _arr) => {
                    const ChannelSearchByIDQueryResults = [
                        DoesYTDLCoreBasicVideoInfoExist ? YTDLCoreBasicVideoInfo.videoDetails.author : undefined,
                        DoesYTDLCoreVideoInfoExist ? YTDLCoreVideoInfo.videoDetails.author : undefined,
                        DoesYTSearchVideoInfoExist ? YTSearchVideoInfo.author : undefined,
                        DoesYTChannelInfoExist ? YTChannelInfo : undefined,
                    ];
                    const ChannelSearchByTitleQueryResults = _el;
                    const VideoAuthorChannel = new Channel.default(ChannelSearchByIDQueryResults, ChannelSearchByTitleQueryResults);
                    return VideoAuthorChannel;
                });
                const [VideoAuthorChannel] = VideoAuthorChannels;
                const DoesVideoAuthorChannelExist = !Validator.TypeGuard.Default.IsNullOrUndefined(VideoAuthorChannel);
                if (DoesVideoAuthorChannelExist) {
                    try {
                        const VideoEntity = new Video.default(VideoSearchByIDQueryResults, VideoAuthorChannel);
                        MatchedVideos.push(VideoEntity);
                    }
                    catch (e) { }
                }
            }
        }
        return MatchedVideos;
    }
    // TODO: JSDoc
    static async __SearchVideosByTitle(searchQuery, searchLimit) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(searchQuery, new Validator().Default.String().Required());
        Validator.Strict(searchLimit, new Validator().Default.Numeric().Number().Required().Integer().Min(1));
        const MatchedVideos = [];
        const VideoSearchQuery = searchQuery;
        const VideoURLValidator = new Validator().Default.String()
            .Required()
            .MinLength(1)
            .Custom((_) => YouTubeService.__IsVideoURL(_), (_) => []);
        const VideosSearchByTitleResults = await YouTubeService.__GetVideosResourcesByTitle(searchLimit, VideoSearchQuery, undefined);
        const VideosSearchByTitleURLs = VideosSearchByTitleResults.map((_el, _ind, _arr) => {
            const ExactVideoSearchByTitleQueryResult = _el;
            const VideoURL = [];
            const YTSRVideoInfo = ExactVideoSearchByTitleQueryResult[0];
            const DoesYTSRVideoInfoExist = !Validator.TypeGuard.Default.IsNullOrUndefined(YTSRVideoInfo);
            if (DoesYTSRVideoInfoExist) {
                VideoURL.push(YTSRVideoInfo.url);
            }
            const MatchedVideoURL = Validator.GetOneOf(VideoURL, VideoURLValidator);
            const DoesMatchedVideoURLExist = !Validator.TypeGuard.Default.IsNullOrUndefined(MatchedVideoURL);
            if (DoesMatchedVideoURLExist) {
                const VideoSearchByTitleQueryURL = MatchedVideoURL;
                return VideoSearchByTitleQueryURL;
            }
            else {
                const VideoSearchByTitleQueryURL = MatchedVideoURL;
                return VideoSearchByTitleQueryURL;
            }
        }).filter((_el, _ind, _arr) => !Validator.TypeGuard.Default.IsNullOrUndefined(_el));
        const SlicedVideosSearchByTitleURLs = VideosSearchByTitleURLs.length > searchLimit ? VideosSearchByTitleURLs.slice(0, searchLimit) : VideosSearchByTitleURLs;
        const GetMatchedVideoByID = async (videoIdOrURL) => {
            const [Video] = await YouTubeService.SearchVideosByIDOrURL(videoIdOrURL);
            const DoesVideoExist = !Validator.TypeGuard.Default.IsNullOrUndefined(Video);
            if (DoesVideoExist) {
                MatchedVideos.push(Video);
            }
        };
        await Promise.all(SlicedVideosSearchByTitleURLs.map((_el, _ind, _arr) => GetMatchedVideoByID(_el)));
        return MatchedVideos;
    }
    // TODO: JSDoc
    static async __GetPlaylistsResourcesByTitle(searchLimit, playlistTitle, playlistId) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(searchLimit, new Validator().Default.Numeric().Number().Required().Integer().Min(1));
        Validator.Strict(playlistTitle, new Validator().Default.String().Required().MinLength(1));
        Validator.Strict(playlistId, new Validator().Default.String().Custom((_) => YouTubeService.__IsPlaylistID(_), (_) => [`Ожидалось указание ID плейлиста YouTube`]));
        const PlaylistsPerPage = 100;
        const PlaylistsLimit = searchLimit;
        const PagesLimit = Math.floor(searchLimit / PlaylistsPerPage) + 1;
        const PlaylistSearchQuery = playlistTitle;
        const PlaylistSearchID = playlistId;
        const MatchedPlaylists = [];
        try {
            const YTSRFilters = await Dependencies.YTSR.getFilters(PlaylistSearchQuery);
            const YTSRTypeFilters = YTSRFilters.get(`Type`);
            const DoesYTSRTypeFilterExist = !Validator.TypeGuard.Default.IsNullOrUndefined(YTSRTypeFilters);
            if (DoesYTSRTypeFilterExist) {
                const YTSRPlaylistTypeFilters = YTSRTypeFilters.get(`Playlist`);
                const DoesYTSRPlaylistTypeFilterExist = !Validator.TypeGuard.Default.IsNullOrUndefined(YTSRPlaylistTypeFilters);
                if (DoesYTSRPlaylistTypeFilterExist) {
                    const YTSRPlaylistSearchFiltersURL = YTSRPlaylistTypeFilters.url;
                    const DoesYTSRPlaylistSearchFiltersURLExist = !Validator.TypeGuard.Default.IsNullOrUndefined(YTSRPlaylistSearchFiltersURL);
                    if (DoesYTSRPlaylistSearchFiltersURLExist) {
                        const YTSRPlaylistSearchResult = await Dependencies.YTSR(YTSRPlaylistSearchFiltersURL, {
                            limit: PlaylistsLimit,
                            pages: PagesLimit,
                            safeSearch: false,
                        });
                        const DoesPlaylistIDFilterExist = !Validator.TypeGuard.Default.IsNullOrUndefined(PlaylistSearchID);
                        const YTSRMatchedPlaylists = YTSRPlaylistSearchResult.items.filter((_el, _ind, _arr) => _el.type === `playlist`);
                        const FilteredYTSRMatchedPlaylists = YTSRMatchedPlaylists.filter((_el, _ind, _arr) => {
                            const RequiredMatches = [];
                            if (DoesPlaylistIDFilterExist) {
                                RequiredMatches.push(_el.playlistID === PlaylistSearchID);
                            }
                            const DoesRequiredMatchExist = !Validator.TypeGuard.Default.IsEmptyArray(RequiredMatches);
                            const PlaylistMatch = DoesRequiredMatchExist ? RequiredMatches.every((_el, _ind, _arr) => _el) : true;
                            return PlaylistMatch;
                        });
                        MatchedPlaylists.push(...FilteredYTSRMatchedPlaylists.map((_el, _ind, _arr) => {
                            const MatchedPlaylist = [_el];
                            return MatchedPlaylist;
                        }));
                    }
                }
            }
        }
        catch (e) { }
        return MatchedPlaylists;
    }
    // TODO: JSDoc
    static async __GetPlaylistResourceByID(playlistId) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(playlistId, new Validator().Default.String()
            .Required()
            .Custom((_) => YouTubeService.__IsPlaylistID(_), (_) => [`Ожидалось указание ID плейлиста YouTube`]));
        const PlaylistSearchID = playlistId;
        const PlaylistSearchURL = YouTubeService.__FormPlaylistURL(PlaylistSearchID);
        const GetYTPLCorePlaylistInfo = async (query) => {
            try {
                const YTPLCorePlaylistInfo = await Dependencies.YTPLCore(query, { limit: Infinity, pages: Infinity });
                return YTPLCorePlaylistInfo;
            }
            catch (e) {
                const YTPLCorePlaylistInfo = undefined;
                return YTPLCorePlaylistInfo;
            }
        };
        const GetYTSearchPlaylistInfo = async (query) => {
            try {
                const YTSearchPlaylistInfo = await Dependencies.YTSearch({
                    listId: query,
                });
                return YTSearchPlaylistInfo;
            }
            catch (e) {
                const YTSearchPlaylistInfo = undefined;
                return YTSearchPlaylistInfo;
            }
        };
        const PlaylistSearchQueries = await Promise.all([GetYTPLCorePlaylistInfo(PlaylistSearchURL), GetYTSearchPlaylistInfo(PlaylistSearchID)]);
        return PlaylistSearchQueries;
    }
    // TODO: JSDoc
    static async __SearchPlaylistsByIDOrURL(playlistIdOrURL) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(playlistIdOrURL, new Validator().Default.String()
            .Required()
            .Custom((_) => YouTubeService.__IsPlaylistURL(_) || YouTubeService.__IsPlaylistID(_), (_) => [`Ожидалось указание ID или ссылки на плейлист YouTube`]));
        const IsSearchQueryPlaylistURL = YouTubeService.__IsPlaylistURL(playlistIdOrURL);
        const IsSearchQueryPlaylistID = YouTubeService.__IsPlaylistID(playlistIdOrURL);
        let PlaylistID = `${playlistIdOrURL}`;
        if (IsSearchQueryPlaylistURL) {
            PlaylistID = YouTubeService.__GetPlaylistID(playlistIdOrURL);
        }
        if (IsSearchQueryPlaylistID) {
            PlaylistID = playlistIdOrURL;
        }
        const ValidPlaylistID = PlaylistID;
        const ValidPlaylistURL = YouTubeService.__FormPlaylistURL(ValidPlaylistID);
        const MatchedPlaylists = [];
        const PlaylistSearchByIDQueryResults = await YouTubeService.__GetPlaylistResourceByID(ValidPlaylistID);
        const YTPLCorePlaylistInfo = PlaylistSearchByIDQueryResults[0];
        const DoesYTPLCorePlaylistInfoExist = !Validator.TypeGuard.Default.IsNullOrUndefined(YTPLCorePlaylistInfo);
        const YTSearchPlaylistInfo = PlaylistSearchByIDQueryResults[1];
        const DoesYTSearchPlaylistInfoExist = !Validator.TypeGuard.Default.IsNullOrUndefined(YTSearchPlaylistInfo);
        const PlaylistTitle = Validator.GetOneOf([DoesYTPLCorePlaylistInfoExist ? YTPLCorePlaylistInfo.title : undefined, DoesYTSearchPlaylistInfoExist ? YTSearchPlaylistInfo.title : undefined], new Validator().Default.String().Required().MinLength(1));
        const DoesPlaylistTitleExist = !Validator.TypeGuard.Default.IsNullOrUndefined(PlaylistTitle);
        if (DoesPlaylistTitleExist) {
            const PlaylistAuthorName = Validator.GetOneOf([DoesYTPLCorePlaylistInfoExist ? YTPLCorePlaylistInfo.author.name : undefined, DoesYTSearchPlaylistInfoExist ? YTSearchPlaylistInfo.author.name : undefined], new Validator().Default.String().Required().MinLength(1));
            const DoesPlaylistAuthorNameExist = !Validator.TypeGuard.Default.IsNullOrUndefined(PlaylistAuthorName);
            const PlaylistAuthorID = Validator.GetOneOf([DoesYTPLCorePlaylistInfoExist ? YTPLCorePlaylistInfo.author.channelID : undefined], new Validator().Default.String().Required().MinLength(1));
            const DoesPlaylistAuthorIDExist = !Validator.TypeGuard.Default.IsNullOrUndefined(PlaylistAuthorID);
            if (DoesPlaylistAuthorNameExist && DoesPlaylistAuthorIDExist) {
                const [PlaylistAuthorSearchByIDQueryResult, PlaylistAuthorSearchByNameIDQueryResult] = await Promise.all([
                    YouTubeService.__GetChannelResourceByID(PlaylistAuthorID),
                    YouTubeService.__GetChannelsResourcesByName(20, PlaylistAuthorName, PlaylistAuthorID),
                ]);
                const YTChannelInfo = PlaylistAuthorSearchByIDQueryResult[0];
                const DoesYTChannelInfoExist = !Validator.TypeGuard.Default.IsNullOrUndefined(YTChannelInfo);
                const PlaylistAuthorChannels = PlaylistAuthorSearchByNameIDQueryResult.map((_el, _ind, _arr) => {
                    const ChannelSearchByIDQueryResults = [
                        undefined,
                        undefined,
                        DoesYTSearchPlaylistInfoExist ? YTSearchPlaylistInfo.author : undefined,
                        DoesYTChannelInfoExist ? YTChannelInfo : undefined,
                    ];
                    const ChannelSearchByTitleQueryResults = _el;
                    const VideoAuthorChannel = new Channel.default(ChannelSearchByIDQueryResults, ChannelSearchByTitleQueryResults);
                    return VideoAuthorChannel;
                });
                const [PlaylistAuthorChannel] = PlaylistAuthorChannels;
                const DoesPlaylistAuthorChannelExist = !Validator.TypeGuard.Default.IsNullOrUndefined(PlaylistAuthorChannel);
                if (DoesPlaylistAuthorChannelExist) {
                    const PlaylistVideosURL = Validator.GetOneOf([
                        DoesYTPLCorePlaylistInfoExist ? YTPLCorePlaylistInfo.items.map((_el, _ind, _arr) => YouTubeService.__FormVideoURL(_el.id)) : [],
                        DoesYTSearchPlaylistInfoExist ? YTSearchPlaylistInfo.videos.map((_el, _ind, _arr) => YouTubeService.__FormVideoURL(_el.videoId)) : [],
                    ], new Validator().Default.Array().Required().Of(new Validator().Default.String().Required().MinLength(1)).MinLength(1));
                    const DoesPlaylistVideoURLExist = !Validator.TypeGuard.Default.IsNullOrUndefined(PlaylistVideosURL);
                    if (DoesPlaylistVideoURLExist) {
                        const GetPlaylistVideo = async (videoIdOrURL) => {
                            const PlaylistVideoMatches = await YouTubeService.SearchVideosByIDOrURL(videoIdOrURL);
                            const [PlaylistVideoMatch] = PlaylistVideoMatches;
                            const DoesPlaylistVideoMatchExist = !Validator.TypeGuard.Default.IsNullOrUndefined(PlaylistVideoMatch);
                            if (DoesPlaylistVideoMatchExist) {
                                const PlaylistVideo = PlaylistVideoMatch;
                                return PlaylistVideo;
                            }
                            else {
                                const PlaylistVideo = undefined;
                                return PlaylistVideo;
                            }
                        };
                        const PlaylistVideos = await Promise.all(PlaylistVideosURL.map((_el, _ind, _arr) => GetPlaylistVideo(_el)));
                        const ValidPlaylistVideos = PlaylistVideos.filter((_el, _ind, _arr) => !Validator.TypeGuard.Default.IsNullOrUndefined(_el));
                        try {
                            const PlaylistEntity = new Playlist.default(PlaylistSearchByIDQueryResults, PlaylistAuthorChannel, ValidPlaylistVideos);
                            MatchedPlaylists.push(PlaylistEntity);
                        }
                        catch (e) { }
                    }
                }
            }
        }
        return MatchedPlaylists;
    }
    // TODO: JSDoc
    static async __SearchPlaylistsByTitle(searchQuery, searchLimit) {
        const Validator = GlobalModule.Classes.Validator;
        Validator.Strict(searchQuery, new Validator().Default.String().Required());
        Validator.Strict(searchLimit, new Validator().Default.Numeric().Number().Required().Integer().Min(1));
        const MatchedPlaylists = [];
        const PlaylistSearchQuery = searchQuery;
        const PlaylistURLValidator = new Validator().Default.String()
            .Required()
            .MinLength(1)
            .Custom((_) => YouTubeService.__IsPlaylistURL(_), (_) => []);
        const PlaylistsSearchByTitleResults = await YouTubeService.__GetPlaylistsResourcesByTitle(searchLimit, PlaylistSearchQuery, undefined);
        const PlaylistsSearchByTitleURLs = PlaylistsSearchByTitleResults.map((_el, _ind, _arr) => {
            const ExactPlaylistSearchByTitleQueryResult = _el;
            const PlaylistURL = [];
            const YTSRPlaylistInfo = ExactPlaylistSearchByTitleQueryResult[0];
            const DoesYTSRPlaylistInfoExist = !Validator.TypeGuard.Default.IsNullOrUndefined(YTSRPlaylistInfo);
            if (DoesYTSRPlaylistInfoExist) {
                PlaylistURL.push(YTSRPlaylistInfo.url);
            }
            const MatchedPlaylistURL = Validator.GetOneOf(PlaylistURL, PlaylistURLValidator);
            const DoesMatchedPlaylistURLExist = !Validator.TypeGuard.Default.IsNullOrUndefined(MatchedPlaylistURL);
            if (DoesMatchedPlaylistURLExist) {
                const PlaylistSearchByTitleQueryURL = MatchedPlaylistURL;
                return PlaylistSearchByTitleQueryURL;
            }
            else {
                const PlaylistSearchByTitleQueryURL = MatchedPlaylistURL;
                return PlaylistSearchByTitleQueryURL;
            }
        }).filter((_el, _ind, _arr) => !Validator.TypeGuard.Default.IsNullOrUndefined(_el));
        const SlicedPlaylistsSearchByTitleURLs = PlaylistsSearchByTitleURLs.length > searchLimit ? PlaylistsSearchByTitleURLs.slice(0, searchLimit) : PlaylistsSearchByTitleURLs;
        const GetMatchedPlaylistByID = async (playlistIdOrURL) => {
            const [Playlist] = await YouTubeService.SearchPlaylistsByIDOrURL(playlistIdOrURL);
            const DoesPlaylistExist = !Validator.TypeGuard.Default.IsNullOrUndefined(Playlist);
            if (DoesPlaylistExist) {
                MatchedPlaylists.push(Playlist);
            }
        };
        await Promise.all(SlicedPlaylistsSearchByTitleURLs.map((_el, _ind, _arr) => GetMatchedPlaylistByID(_el)));
        return MatchedPlaylists;
    }
}
export default YouTubeService;
//# sourceMappingURL=__api.js.map