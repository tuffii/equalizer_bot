# Документация

## Импорт модуля

- Импорт модуля осуществляется через стандартные пакетные менеджеры `Node.JS`

  ```bash
    $ npm install @var3n1k/server-core
  ```

  ```bash
    $ yarn add @var3n1k/server-core
  ```

  ```bash
    $ pnpm add @var3n1k/server-core
  ```

- [Инициализация модуля](#инициализация-модуля)
- [Использование функций модуля](#использование-функций-модуля)
- [Внешние API](#внешние-api)

## Инициализация модуля

```ts
import * as ServerCore from '@var3n1k/server-core'

import * as QRCode from 'qrcode'

const CustomDependencies = {
  // Дополнительные зависимости приложения, которые будут доступны из поля `Core.Dependencies` вместе со встроенными
  qrcode: QRCode,
} as const

const CustomDataSet = {
  // Дополнительный датасет приложения, который будет доступен из поля `Core.DataSet` вместе со встроенным
  Constants: {
    Color: {
      White: `#FFFFFF`,
    },
  },
} as const

const Log = (): void => {
  console.log(1234)
}
const CustomFunctions = {
  // Дополнительные функции приложения, которые будут доступны из поля `Core.Functions` вместе со встроенными
  Log: Log,
} as const

const CustomClasses = {
  // Дополнительные классы приложения, которые будут доступны из поля `Core.Classes` вместе со встроенными
} as const

const EnvFiles = [
  // Пути к файлам с переменными рабочей среди относительно корневой директории приложения
  `.env`,
]
const Core = new ServerCore.default(CustomDependencies, CustomDataSet, CustomFunctions, CustomClasses, EnvFiles)
```

## Использование функций модуля

- [Обработчик исключений](#обработчик-исключений)
- [Валидация параметров](#валидация-параметров)
- [Обработка параметров базовых типов](#обработка-параметров-базовых-типов)
- [Взаимодействие с консолью](#взаимодействие-с-консолью)
- [Обработчик событий](#обработчик-событий)
- [Система очередей](#система-очередей)

### Обработчик исключений

- Для запуска обработчика исключений используется инициализация основного класса `Core`

  ```ts
  import * as ServerCore from '@var3n1k/server-core'

  const Core = new ServerCore.default({}, {}, {}, {}, [`.env`])

  throw new Error(`тестовая ошибка`)
  ```

### Валидация параметров

- Для валидации параметров по типу используется класс `Validator`

  ```ts
  import * as ServerCore from '@var3n1k/server-core'

  function AnyFunction(parameter: unknown): any {
    const Validator = ServerCore.Engine.Module.Classes.Validator

    const ParameterIsString = Validator.TypeGuard.Default.IsString(parameter)
    if (ParameterIsString) {
      parameter // IDE выделит тип `string` для параметра и выдаст в автодополнении все методы и свойства для типа `string`
    }

    const ParameterIsNumber: boolean = Validator.TypeGuard.Default.IsNumber(parameter)
    if (ParameterIsNumber) {
      parameter // IDE НЕ выделит тип `number` для параметра, поскольку для значения `ParameterIsNumber` вручную указан тип `boolean`
    }

    if (Validator.TypeGuard.Default.IsFunction(parameter)) {
      parameter // IDE выделит тип `function` для параметра и выдаст в автодополнении все методы и свойства для типа `function`
    }
  }
  ```

- Для валидации параметров по значению также используется класс `Validator`

  ```ts
  import * as ServerCore from '@var3n1k/server-core'

  function AnyFunction(parameter: unknown): any {
    const Validator = ServerCore.Engine.Module.Classes.Validator
    Validator.Strict(
      parameter,
      new Validator().Default.String()
        .Required()
        .MinLength(8)
        .Of([`a`, `b`, `c`])
        .In([`abbbccac`, `bbacbbaa`])
        .Custom(
          (_) => false,
          (_) => [`Сообщение ошибки с окрашенным (`, undefined, `) параметром`]
        )
        .Or(new Validator().Default.Numeric().Number().Required().Integer())
    )
    // Валидатор проверит параметр на
    //   - Соответствие типу строки (.String())
    //   - Обязательное указание (.Required() -> не может быть `undefined` | `null`, и так далее)
    //   - Минимальную длину в 8 символов (.MinLength(8))
    //   - Содержание в себе исключительно символов (`a`, `b`, `c`) (.Of([`a`, `b`, `c`]))
    //   - Соответствие любому из предопределенных значений (`abbbccac`, `bbacbbaa`) (.In([`abbbccac`, `bbacbbaa`]))
    //   - Соответствие кастомному валидатору ((_) => false) и вывод кастомной ошибки [`Текст ошибки...`] при ошибке валидирования
    //   - Если параметр не соответствует хотя бы одному условию, начнется проверка на альтернативное условие (.Or())
    //   - Соответствие исчисляемому типу (.Numeric())
    //   - Соответствие числовому типу (.Number())
    //   - Обязательное указание (.Required() -> не может быть `undefined` | `null`, и так далее)
    //   - Соответствие целочисленному типу (.Integer())
    // В случае несоответствия параметра ожидаемому значению программа закончит работу с исключением, описывающим этот параметр

    const IsDefinedString = Validator.Soft(parameter, new Validator().Default.String().Required()).Status
    // Валидатор проверит параметр на
    //   - Соответствие типу строки (.String())
    //   - Обязательное указание (.Required() -> не может быть `undefined` | `null`, и так далее)
    // Валидатор вернет результат проверки в поле `Status` и в случае отрицательного результата исключение в поле `Error`
    // Вне зависимости от результата проверки программа закрыта НЕ БУДЕТ

    if (IsDefinedString) {
      parameter // IDE НЕ выделит тип `string` для параметра, поскольку комбинирование в валидаторе тайпгардов вызовет перегрузку типов
    }
  }
  ```

### Обработка параметров базовых типов

- Для обработки стандартных параметров таких типов, как `string`, `number`, `bigint`, `Array<any>`, `object`, `RegExp`, `boolean`, `Date`, `Function` и `Error` используется модуль `TypeManager`

  ```ts
  import * as ServerCore from '@var3n1k/server-core'

  const TypeManager = ServerCore.Engine.Module.Functions.Parameter.Type.Manager

  const InitialDate = new Date()

  const DateFullYear = true // Вывод полного номера года
  const DateNamedMonth = true // Вывод названия месяца, а не его номера
  TypeManager.Default.Date.GetStringDate(InitialDate, true, DateFullYear, DateNamedMonth) // 18 Марта 2023
  TypeManager.Default.Date.GetStringDate(InitialDate, true, !DateFullYear, DateNamedMonth) // 18 Марта 23
  TypeManager.Default.Date.GetStringDate(InitialDate, true, !DateFullYear, !DateNamedMonth) // 18.03.2023

  const TimeMilliseconds = true // Вывод миллисекунд
  TypeManager.Default.Date.GetStringTime(InitialDate, true, TimeMilliseconds) // 12:32:45.153
  TypeManager.Default.Date.GetStringTime(InitialDate, true, !TimeMilliseconds) // 12:32:45

  const InitialNumber = 6754673456
  TypeManager.Default.Numeric.ToRange(InitialNumber, -20 /*нижняя граница*/, 123 /*верхняя граница*/) // 123
  TypeManager.Default.Numeric.ToRange(InitialNumber, 500 /*нижняя граница*/, undefined) // 6754673456
  ```

### Взаимодействие с консолью

- Для отображения сообщений в консоли используется класс `Console`

  ```ts
  import * as ServerCore from '@var3n1k/server-core'

  const Console = ServerCore.Engine.Module.Classes.Console

  const LogWithMark = true // Вывод лога с префиксом
  const LigWithTimestamp = true // Вывод лога с отображением времени
  Console.Log.Custom(LogWithMark, LigWithTimestamp, `Обработка параметра `, 234, ` прошла успешно`) // ◉ [18 Марта 2023 | 12:32:45.153] Обработка параметра 234 прошла успешно
  Console.Log.Custom(!LogWithMark, LigWithTimestamp, `Обработка параметра `, 234, ` прошла успешно`) // [18 Марта 2023 | 12:32:45.153] Обработка параметра 234 прошла успешно
  Console.Log.Custom(!LogWithMark, !LigWithTimestamp, `Обработка параметра `, 234, ` прошла успешно`) // Обработка параметра 234 прошла успешно

  Console.Log.Preset.Success(`Обработка параметра `, 234, ` прошла успешно`) // ◉ [18 Марта 2023 | 12:32:45.153] [SUCCESS] Обработка параметра 234 прошла успешно
  ```

### Обработчик событий

- Для использования обработчика событий используется класс `EventEmitter` (обработчик событий, как правило, навешивается на значимые отлавливаемые классы)

  ```ts
  import * as ServerCore from '@var3n1k/server-core'

  const Core = new ServerCore.default({}, {}, {}, {}, [`.env`])

  const EventEmitter = ServerCore.Engine.Module.Classes.EventEmitter

  const NewEventName = {
    Test: `test`,
  } as const

  interface NewEvent {
    [NewEventName.Test]: (argument_1: number, argument_2: string) => void
  }

  const NewEventEmitter: ServerCore.Engine.Module.Classes.EventEmitter<NewEvent> = new EventEmitter()
  NewEventEmitter.Emit(NewEventName.Test, 234, `test_string`)

  const Console = ServerCore.Engine.Module.Classes.Console

  // На класс Core изначально навешен класс EventEmitter и используется в поле `Core.Event`
  // Обработчик событий устанавливается в сущности класса, а названия событий - статически в самом классе
  // Событие `Core.Event.Name.Init` вызывается по окончании инициализации приложения
  Core.Event.Emitter.On(ServerCore.default.Event.Name.Init, async () => {
    Console.Log.Preset.Success(`Приложение запущено`)
  })

  const InitializationFunction = (): Promise<void> => {
    // Функция, выполняемая непосредственно перед завершением инициализации приложения
  }

  await Core.Init(InitializationFunction)
  // ◉ [18 Марта 2023 | 12:32:45.153] [SUCCESS] Приложение запущено
  ```

### Система очередей

- Для создания и управления очередями используется класс `Queue`

  ```ts
  import * as ServerCore from '@var3n1k/server-core'

  const Sleep = ServerCore.Engine.Module.Functions.Sleep

  const Queue = ServerCore.Engine.Module.Classes.Queue

  const Console = ServerCore.Engine.Module.Classes.Console

  const QueueUpdateCooldown = 0 // Задержка перед обработкой следующей группы параметров
  const QueueUpdateStack = 2 // Размер группы параметров, которые будут обрабатываться за один раз
  const QueueUpdateFunction = async (parameter_1: number, parameter_2: number): Promise<void> => {
    await Sleep(500)

    Console.Log.Preset.Info(`Обработка первого параметра (`, parameter_1, `) в процессе`)
    Console.Log.Preset.Info(`Обработка первого параметра (`, parameter_2, `) в процессе`)

    await Sleep(500)
  }
  const NewQueue = new Queue(QueueUpdateCooldown, QueueUpdateStack, QueueUpdateFunction)

  NewQueue.Pause()
  NewQueue.IsPaused() // true

  NewQueue.Elements.AddTo.End(5, 23, 45, 456, 567, 45, 45)
  NewQueue.Elements.RemoveFrom.Start(2)

  NewQueue.Event.Emitter.On(NewQueue.Event.Name.Updating.End, async (elements) => {
    // Параметр `elements` без явного назначения типа выделяется IDE как тип `number` на основании функции `QueueUpdateFunction`, которая была передана в конструктор `Queue`

    NewQueue.Stop()
    // В отличие от события `End`, которое отлавливается текущей функцией и срабатывает при опустошении очереди, событие `Stop` эту очередь еще и прерывает, завершая цикл обновлений
  })
  NewQueue.Events.Emitter.On(NewQueue.Events.Name)

  NewQueue.Resume()
  NewQueue.IsPaused() // false
  ```

## Внешние API

- [WebServer | HTTP](#webserver--http)
- [DataBase | PostgreSQL](#database--postgresql)
- [Service | EMail](#service--email)
- [Service | YouTube](#service--youtube)

### WebServer | HTTP

- API `HTTPWebServer` используется для создания HTTP сервера, принимающего различные запросы (основан на [express.js](https://www.npmjs.com/package/express))

  ```ts
  import * as ServerCore from '@var3n1k/server-core'

  const HTTPRouter = ServerCore.Engine.API.WebServer.HTTP.API.Router.default

  const Console = ServerCore.Engine.Module.Classes.Console

  const UsersRegisterHTTPRouter = new HTTPRouter()
  UsersRegisterHTTPRouter.On.Post(`/register`, async (request, response) => {
    const RequestBody = request.Body // JSON

    Console.Log.Preset.Info(`Обработка POST запроса по эндпоинту ${request.Destination.Endpoint}`)
  })

  const UsersHTTPRouter = new HTTPRouter()
  UsersHTTPRouter.On.Get(`/users`, async (request, response) => {
    Console.Log.Preset.Info(`Обработка GET запроса по эндпоинту ${request.Destination.Endpoint}`)
  })
  UsersHTTPRouter.Add(`/users`, [UsersRegisterHTTPRouter]) // /api/users/register

  const APIHTTPRouter = new HTTPRouter()
  APIHTTPRouter.On.Get(`/api`, async (request, response) => {
    Console.Log.Preset.Info(`Обработка GET запроса по эндпоинту ${request.Destination.Endpoint}`) // /api

    const ResponseStatusCode = 200 // Статус запроса (200 -> OK)
    const ResponseHeaders = {}
    const ResponseMessage = { message: `Successful` } // Тело ответа на запрос
    await response.Responder.JSON(ResponseStatusCode, ResponseHeaders, ResponseMessage)
  })
  APIHTTPRouter.Add(`/api`, [UsersHTTPRouter]) // /api/users

  const IsHTTPWebServerRemote = false // HTTP сервер является удаленным (публичный IP / домен)
  const IsHTTPWebServerSecure = false // Подключение к HTTP серверу осуществляется по защищенному протоколу `https`
  const HTTPWebServerHostName = `localhost` // Домен HTTP сервера
  const HTTPWebServerPort = 5000 // Порт HTTP сервера
  const HTTPWebServerClientFolder = ServerCore.Engine.Module.Dependencies.Default.Node.path.join(
    ServerCore.Engine.Module.Classes.FileSystem.FormatPath(ServerCore.Engine.Module.Classes.Process.Source.Directory.Path.Get()),
    `public`,
    `assets`
  )
  const HTTPWebServer = new ServerCore.Engine.API.WebServer.HTTP.API.default(
    IsHTTPWebServerRemote,
    IsHTTPWebServerSecure,
    HTTPWebServerHostName,
    HTTPWebServerPort,
    HTTPWebServerClientFolder
  )
  HTTPWebServer.Connect(APIHTTPRouter)

  await HTTPWebServer.Init()
  ```

### DataBase | PostgreSQL

- API `PostgreSQLDataBase` используется для управления базами данных и таблицами PostgreSQL (основан на [pg](https://www.npmjs.com/package/pg))

  ```ts
  import * as ServerCore from '@var3n1k/server-core'

  const PostgreSQLAPI = ServerCore.Engine.API.DataBase.PostgreSQL.API.default

  const Console = ServerCore.Engine.Module.Classes.Console
  ```

  - Для декларации новой таблицы в базе данных рекомендуется придерживаться следующего шаблона

    ```ts
    import * as ServerCore from '@var3n1k/server-core'

    const TableName = `<название таблицы строчными буквами>`
    const TableFields = {
      ID: `id`, // Название стандартного поля таблицы. Как правило, используется автоматически инкрементируемое число для индексации записей таблицы
      CustomField: `custom_field`, // Название поля таблицы. Число таких полей ограничено лишь возможностями PostgreSQL
    } as const

    export interface Output {
      readonly [TableFields.ID]: number // Декларация типа данных, которое содержит поле при ВЫВОДЕ (все данные из записи)
      readonly [TableFields.CustomField]: string
    }

    export interface Input {
      readonly [TableFields.CustomField]: Output[typeof TableFields.CustomField] // Декларация типа данных, которое содержит поле при ВВОДЕ со ссылкой на декларацию этого же поля для вывода. Количество полей для ввода может быть меньше, чем количество полей для вывода (к примеру, поле id - автоинкрементирующееся число -> его не нужно указывать вручную)
    }

    export default class Table extends ServerCore.Engine.API.DataBase.PostgreSQL.API.DataBases.Tables.BaseTable<Input, Output> {
      public readonly Column: typeof TableFields = TableFields

      constructor(api: PostgreSQLAPI, database: ServerCore.Engine.API.DataBase.PostgreSQL.API.DataBases.BaseDataBase) {
        super(api, database, TableName, {
          [TableFields.ID]: {
            Type: ServerCore.Engine.API.DataBase.PostgreSQL.API.DataBases.Tables.DataType.Numeric.Int, // Тип поля -> INT
            MetaData: {
              DefaultValue: undefined, // У поля нет стандартного значения
              IsPrimary: true, // Поле является первичным ключом (идентификатором записи)
              IsRequired: true, // Поле обязательное и не может содержать NULL
              IsUnique: true, // Поле должно быть уникальным. Запрещается любое совпадение такого поля с другими записями этой таблицы
              MustBeAutoIncremented: true, // Поле должно инкрементироваться автоматически (ТОЛЬКО ДЛЯ ТИПОВ INT | INTEGER)
              Reference: undefined, // Внешняя ссылка на другую таблицу
            },
          },
          [TableFields.CustomField]: {
            Type: ServerCore.Engine.API.DataBase.PostgreSQL.API.DataBases.Tables.DataType.String.Text, // Тип поля -> TEXT
            MetaData: {
              DefaultValue: undefined, // У поля нет стандартного значения
              IsPrimary: false, // Поле является стандартным
              IsRequired: true, // Поле обязательное и не может содержать NULL
              IsUnique: false, // Поле не является уникальным и может совпадать с другими записями
              MustBeAutoIncremented: false, // Поле не должно инкрементироваться, так как имеет тип TEXT
              Reference: {
                // Внешняя ссылка на другую таблицу
                Table: {
                  Name: `table_1`, // Название внешней таблицы
                },
                Field: `field_1`, // Название поля внешней таблицы
              },
            },
          },
        })
      }
    }
    ```

  - Для декларации новой базы данных рекомендуется придерживаться следующего шаблона

    ```ts
    import * as ServerCore from '@var3n1k/server-core'

    import * as Tables from './Tables/__tables.js'

    interface DataBaseTables {
      readonly Users: Tables.Users.default // Тип импортированной таблицы
    }

    export default class DataBase extends ServerCore.Engine.API.DataBase.PostgreSQL.API.DataBases.BaseDataBase {
      public readonly Tables: DataBaseTables

      public async Init(): Promise<void> {
        const Validator = ServerCore.Engine.Module.Classes.Validator

        const TablesProperties = ServerCore.Engine.Module.Functions.Parameter.Type.Manager.Default.Object.GetFullProperties(this.Tables, (propertiesPath, value) => {
          const IsValueInstanceOfTable = Validator.TypeGuard.Default.IsInstanceOf(value, ServerCore.Engine.API.DataBase.PostgreSQL.API.DataBases.Tables.BaseTable)

          return IsValueInstanceOfTable
        })
        const Tables: Array<ServerCore.Engine.API.DataBase.PostgreSQL.API.DataBases.Tables.BaseTable<any, any>> = TablesProperties.map((_el, _ind, _arr) => _el.Value)

        await Promise.all(Tables.map((_el, _ind, _arr) => _el.CreateIfNotExist())) // Автоматическое подключение и создание всех таблиц базы данных
      }

      constructor(api: PostgreSQLAPI, name: string) {
        super(api, name)

        this.Tables = {
          Users: new Tables.Users.default(api, this), // Сущность импортированной таблицы
        }
      }
    }
    ```

    - После создания декларации таблицы, создавать дополнительный скрипт `.sql` для создания таблицы в самой базе данных **НЕ НУЖНО**. Таблица создается **АВТОМАТИЧЕСКИ**

### Service | EMail

- API `EMailService` используется для отправки сообщений через сервисы электронной почты (основан на [nodemailer](https://www.npmjs.com/package/nodemailer))

  ```ts
  import * as ServerCore from '@var3n1k/server-core'

  const EMailUser = {
    Name: `test.mail@gmail.com`, // Адрес почты, с которой будут отправляться письма
    Password: `dsfgshsdffdgh`, // Пароль от почты, с которой будут отправляться письма
  }
  const EmailHost = {
    Name: `smtp.gmail.com`, // Хост почтового сервиса
    Port: 587, // Порт почтового сервиса
  }

  const EMailServiceAPI = new ServerCore.Engine.API.Service.EMail.API.default(EMailUser.Name, EMailUser.Password, EmailHost.Name, EmailHost.Port)

  const TargetAdresss = `not.test.mail@gmail.com` // Адрес получателя
  const MailContent = {
    Subject: `Test subject`, // Тема письма
    Body: {
      Text: `Test body`, // Содержание письма ввиде текста
      HTML: `<div><h1>Test HTML</h1></div>`, // Содержание пиьсма в виде HTML разметки
    },
  }

  await EMailServiceAPI.SendMail(TargetAdresss, MailContent.Subject, MailContent.Body.Text, MailContent.Body.HTML)
  ```

### Service | YouTube

- API `YouTubeService` используется для поиска информации о треках и плейлистах в YouTube (основан на [ytdl-core](https://www.npmjs.com/package/ytdl-core), [ytsearch](https://www.npmjs.com/package/ytsearch), [ytsr](https://www.npmjs.com/package/ytsr), [ytpl](https://www.npmjs.com/package/ytpl))

  ```ts
  import * as ServerCore from '@var3n1k/server-core'

  const YouTubeServiceAPI = ServerCore.Engine.API.Service.YouTube.API.default

  const ValidVideoURL = `https://youtu.be/nMe5r4rL-tY`
  const InvalidVideoURL = `https://youtu.be/v/nMe5r4rL-tY`
  YouTubeServiceAPI.IsVideoURL(ValidVideoURL) // true
  YouTubeServiceAPI.IsVideoURL(InvalidVideoURL) // false

  if (YouTubeServiceAPI.IsVideoURL(ValidVideoURL)) {
    const VideoID = YouTubeServiceAPI.GetVideoID(ValidVideoURL) // nMe5r4rL-tY

    const VideosSearchLimit = 5 // Лимит поиска видеоресурсов

    const [Video] = await YouTubeServiceAPI.SearchVideosByIDOrURL(VideoID)
    const Videos = await YouTubeServiceAPI.SearchVideosByTitle(`Video Title`, VideosSearchLimit)
  }

  const ValidPlaylistURL = `https://youtube.com/playlist?list=PLNT83Pmw8EuKuC73riti9X2v4-rklh88M`
  const InvalidPlaylistURL = `https://youtube.com/list/PLNT83Pmw8EuKuC73riti9X2v4-rklh88M`
  YouTubeServiceAPI.IsPlaylistURL(ValidPlaylistURL) // true
  YouTubeServiceAPI.IsPlaylistURL(InvalidPlaylistURL) // false

  if (YouTubeServiceAPI.IsPlaylistURL(ValidPlaylistURL)) {
    const PlaylistID = YouTubeServiceAPI.GetPlaylistID(ValidPlaylistURL) // PLNT83Pmw8EuKuC73riti9X2v4-rklh88M

    const PlaylistsSearchLimit = 5 // Лимит поиска плейлистов

    const [Playlist] = await YouTubeServiceAPI.SearchPlaylistsByIDOrURL(PlaylistID)
    const Playlists = await YouTubeServiceAPI.SearchPlaylistsByTitle(`Playlist Title`, PlaylistsSearchLimit)
  }
  ```
